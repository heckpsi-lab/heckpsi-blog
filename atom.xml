<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HeckPsi Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.heckpsi.com/"/>
  <updated>2016-04-21T15:36:12.000Z</updated>
  <id>http://blog.heckpsi.com/</id>
  
  <author>
    <name>上海骇咕赛信息科技有限公司</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HeckPsi 2016 全新博客系统</title>
    <link href="http://blog.heckpsi.com/2016/04/21/heckpsi-blog-2016/"/>
    <id>http://blog.heckpsi.com/2016/04/21/heckpsi-blog-2016/</id>
    <published>2016-04-21T14:56:14.000Z</published>
    <updated>2016-04-21T15:36:12.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;HeckPsi 博客 2016 迎来了巨大的改版！&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;这是个啥？&quot;&gt;&lt;a href=&quot;#这是个啥？&quot; class=&quot;headerlink&quot; title=&quot;这是个啥？&quot;&gt;&lt;/a&gt;这是个啥？&lt;/h3&gt;&lt;p&gt;正如你所见，HeckPsi 的全新博客系统变得非常地 &lt;em&gt;清新&lt;/em&gt; 。在深思熟虑之后，我们发现，以前的主页，看似非常炫酷，实则净是废话。于是借由 HeckPsi 主页改版的机会，HeckPsi 博客系统也迎来了巨大的更新！&lt;/p&gt;
&lt;h4 id=&quot;这个博客用来干什么？&quot;&gt;&lt;a href=&quot;#这个博客用来干什么？&quot; class=&quot;headerlink&quot; title=&quot;这个博客用来干什么？&quot;&gt;&lt;/a&gt;这个博客用来干什么？&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;发布对于业内见闻的评论&lt;/li&gt;
&lt;li&gt;发布对科技相关的科普&lt;/li&gt;
&lt;li&gt;发布我们所坚持的价值观&lt;/li&gt;
&lt;li&gt;&lt;del&gt;瞎搞&lt;/del&gt; 实验性内容&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;所以，我们的博客需要什么&quot;&gt;&lt;a href=&quot;#所以，我们的博客需要什么&quot; class=&quot;headerlink&quot; title=&quot;所以，我们的博客需要什么&quot;&gt;&lt;/a&gt;所以，我们的博客需要什么&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;清晰高效的排版&lt;/li&gt;
&lt;li&gt;便于快速编辑（Markdown 什么的最好，可视化编辑器太累）&lt;/li&gt;
&lt;li&gt;静态化的页面&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;于是就有了现在你所看到的博客系统。它使用了 &lt;a href=&quot;https://github.com/hexojs/hexo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;hexo&lt;/a&gt; 项目生成静态页面，以及使用了 &lt;a href=&quot;https://github.com/pinggod/hexo-theme-apollo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;hexo-theme-apolo&lt;/a&gt; 项目的主题，并进行了一定地定制开发。&lt;/p&gt;
&lt;p&gt;相比之下，我们拥有了更加强大地对网站的控制权利，可以做更多地功能模块的定制，以进一步满足我们未来的要求。至于为什么没有使用 &lt;a href=&quot;https://jekyllrb.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Jekyll&lt;/a&gt; ，单纯是因为 hexo 更适合做博客，而 Jekyll 什么都适合做，有些无从下手。&lt;/p&gt;
&lt;h3 id=&quot;停更的几个月发生了啥？&quot;&gt;&lt;a href=&quot;#停更的几个月发生了啥？&quot; class=&quot;headerlink&quot; title=&quot;停更的几个月发生了啥？&quot;&gt;&lt;/a&gt;停更的几个月发生了啥？&lt;/h3&gt;&lt;p&gt;首先，HeckPsi 成立了在国内注册的公司，并以此申请了备案。所以我们的服务器现在可以运行在中华人民共和国境内，以提供更快的服务。&lt;/p&gt;
&lt;p&gt;其次，我们深刻考虑了我们未来的业务形态。最近也将会有比较大的动向，开出某个全新的板块，以及某些神秘的产品，尽请期待。&lt;/p&gt;
&lt;p&gt;最后就是旧博客的数据之前放在 AWS Japan 上，出了一些小问题，差点丢失。幸好已经通过完备的日志系统还原了大部分数据，并且将于近期还原。未来我们的博客数据都会实现多点异地备份，保证其安全性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;承蒙各位厚爱，HeckPsi 会坚持做下去。&lt;/strong&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;HeckPsi 博客 2016 迎来了巨大的改版！&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="站务" scheme="http://blog.heckpsi.com/tags/%E7%AB%99%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>认识 Y-Combinator</title>
    <link href="http://blog.heckpsi.com/2016/03/19/learn-y-combinator/"/>
    <id>http://blog.heckpsi.com/2016/03/19/learn-y-combinator/</id>
    <published>2016-03-19T00:50:00.000Z</published>
    <updated>2016-04-21T16:34:12.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;写在开始&quot;&gt;&lt;a href=&quot;#写在开始&quot; class=&quot;headerlink&quot; title=&quot;写在开始&quot;&gt;&lt;/a&gt;写在开始&lt;/h2&gt;&lt;p&gt;不得不说，当我开始学习函数式编程的时候，我并没有被匿名函数感到害怕，理解它的基本概念是极其容易的。但是当你试图去将你日常所书写的指令式的代码转换成函数式，特别是纯函数式的时候，你会感到这是不可能的。它和你之前的编程思想是完全脱离的。&lt;/p&gt;
&lt;p&gt;所以当我第一次见到 Y-Combinator（Y 组合子）的时候，我的感觉是懵逼的，这是什么玩意。然而当我一步一步，了解这个东西是什么，它是怎么工作的之后，我对函数式编程的认识有了很大的进步。&lt;/p&gt;
&lt;p&gt;即使是 C++ 这样的语言，也在 C++11 标准中引入了匿名函数，使得你有机会在 C++ 中使用函数式编程的特性。在编程中，如果能适当地使用函数式语法进行编程，将非常有助于你写出一些更好理解、更简单的代码。&lt;/p&gt;
&lt;p&gt;而在了解一些基本概念之后，了解一下 Y-Combinator 是一个极好的选择，这个东西证明了函数式编程对递归的语义理解，证明了其在递归上和指令式编程的等价之处。你可以通过观察等价的这两者的不同的实现方式，来加深对这两者思想的认识。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;与指令式编程的根本区别&quot;&gt;&lt;a href=&quot;#与指令式编程的根本区别&quot; class=&quot;headerlink&quot; title=&quot;与指令式编程的根本区别&quot;&gt;&lt;/a&gt;与指令式编程的根本区别&lt;/h2&gt;&lt;p&gt;大家看下面一段 C 代码&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;; i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;显然这是一个非常常见的循环。然而这样的循环显然已经被抽象过了，我们也许可以用一个更原始的方法来实现。且让我引入一个 C 开发中应尽量避免的语句 &lt;code&gt;goto&lt;/code&gt; 来解释。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;loop:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (i &amp;gt;= &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;goto&lt;/span&gt; next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;i++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;goto&lt;/span&gt; loop;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;next:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这两段代码除了变量 &lt;code&gt;i&lt;/code&gt; 的作用域有所区别以外几乎是等价的。相对的，第二段代码非常接近于编译到汇编时的指令，几乎是一一映射的。然而你可以发现，我们的循环都是依赖于跳转代码行数的，不得不说这种写法非常不函数式。&lt;/p&gt;
&lt;h2 id=&quot;第一个函数&quot;&gt;&lt;a href=&quot;#第一个函数&quot; class=&quot;headerlink&quot; title=&quot;第一个函数&quot;&gt;&lt;/a&gt;第一个函数&lt;/h2&gt;&lt;p&gt;我们可以用一个递归来把这个循环实现地更像一个函数：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (n == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) return &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  return loop(n - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;loop(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;虽然这个函数是倒过来循环的，但我们大可忽略这些细节，毕竟要做修改也是相对容易的。我们通过一个函数递归的方式来实现了一个循环。需要特别注意的是，如果根据递归的定义，那么这个循环一旦大起来在今天我们的计算机的计算模型（而不是 Lisp Machine）上是会爆栈的，但好在由于是个尾递归，通常是会直接被编译器优化成一个循环的。这确保了即使你写的是函数式代码，也可以最终编译成适合 CPU 运算的形式而不太影响性能。&lt;/p&gt;
&lt;p&gt;不过递归有一个问题，我们必须知道函数的名称才能这么做，在真正的 Lambda 运算模型上，函数是匿名的，也就是没有名字，这样你最后根本就无处调用你函数自己。因为你无法写出下面的代码（Ruby）：&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;lambda &amp;#123; &lt;span class=&quot;params&quot;&gt;|n|&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; n == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  puts &lt;span class=&quot;string&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  what_the_f**k_my_function_name_is(n-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;魔法少女-Lambda-酱&quot;&gt;&lt;a href=&quot;#魔法少女-Lambda-酱&quot; class=&quot;headerlink&quot; title=&quot;魔法少女 Lambda 酱&quot;&gt;&lt;/a&gt;魔法少女 Lambda 酱&lt;/h2&gt;&lt;p&gt;下面我们演示一种黑魔法，来使得你没有办法得到自己函数名时实现递归。简单来说就是把「函数」当成一个「参数」传输。&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;loop = lambda &amp;#123;&lt;span class=&quot;params&quot;&gt;|f, n|&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; n == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  puts &lt;span class=&quot;string&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  f.call(n-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;loop.call(loop, &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们把函数本身作为一个参数传了进去，达到了我们的想法。不过这里我们还不是一个完全的匿名函数，而是通过给匿名函数起了一个名字 &lt;code&gt;loop&lt;/code&gt;，在外面调用了一下。不过事到如今，去掉这个 &lt;code&gt;loop&lt;/code&gt; 已经很容易了。由于第一条的匿名函数定义中没有任何地方用到 &lt;code&gt;loop&lt;/code&gt; 只在第二条指令中用到。我们只要将第二条指令中的所有 &lt;code&gt;loop&lt;/code&gt; 都代换掉就行。我们就能得到下面的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;lambda &amp;#123;&lt;span class=&quot;params&quot;&gt;|f, n|&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; n == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  puts &lt;span class=&quot;string&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  f.call(n-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;.call(lambda&amp;#123;&lt;span class=&quot;params&quot;&gt;|f, n|&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; n == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    puts &lt;span class=&quot;string&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    f.call(n-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;, &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;柯里化，最后一步&quot;&gt;&lt;a href=&quot;#柯里化，最后一步&quot; class=&quot;headerlink&quot; title=&quot;柯里化，最后一步&quot;&gt;&lt;/a&gt;柯里化，最后一步&lt;/h2&gt;&lt;p&gt;Amazing！我们通过一个匿名函数的调用成功实现了一个 100 的循环。我们现在距离 Haskell Brooks Curry 先生当年推出 Y 组合子只差一步，那就是将我们做的事情「Currying」（柯里化）。所谓 Currying 就是使用一个高阶函数，将一个函数的多个参数精简成一个。我们看到我们现在的匿名函数还有 &lt;code&gt;f&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt; 两个参数，我们打算拿掉它。虽然其实并不是真正意义上的拿掉。柯里化，只不过把一个形如 &lt;code&gt;f(x, y)&lt;/code&gt; 的函数写成了 &lt;code&gt;f(x)(y)&lt;/code&gt;，也就是 &lt;code&gt;f(x)&lt;/code&gt; 的返回是一个匿名函数，而这个匿名函数再以 &lt;code&gt;y&lt;/code&gt; 为参数执行一次。这么搞一下，我们就得到了：&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;lambda &amp;#123;&lt;span class=&quot;params&quot;&gt;|p|&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; lambda &amp;#123; &lt;span class=&quot;params&quot;&gt;|f|&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; f.call(f);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;.call(lambda &amp;#123;&lt;span class=&quot;params&quot;&gt;|f|&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; p.call(lambda &amp;#123;&lt;span class=&quot;params&quot;&gt;|x|&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; f.call(f).call(x)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;.call(lambda &amp;#123;&lt;span class=&quot;params&quot;&gt;|f|&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; lambda &amp;#123;&lt;span class=&quot;params&quot;&gt;|i|&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; i == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      f.call(i-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;).call(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;由于柯里化后匿名函数和调用的参数都单一了，我们因此可以保证我们能将任意一个递归都表达成一个匿名函数的形式。按照 Lambda 演算的形式化表达  &lt;code&gt;Y := λf.(λx.(f (x x)) λx.(f (x x)))&lt;/code&gt; 。你只要将自己要递归的函数替换掉里面 &lt;code&gt;f&lt;/code&gt; 的位置，并最后执行一下这个匿名函数就成啦~&lt;/p&gt;
&lt;h2 id=&quot;折腾半天干什么&quot;&gt;&lt;a href=&quot;#折腾半天干什么&quot; class=&quot;headerlink&quot; title=&quot;折腾半天干什么&quot;&gt;&lt;/a&gt;折腾半天干什么&lt;/h2&gt;&lt;p&gt;你肯定想问，我们把一个循环写成这么复杂是为了什么。事实上我想展示的不是循环，而是递归。递归在图灵模型（我们通常 CPU 的计算模型）和丘奇模型（Lambda 演算）上都不是那么地原生的实现。&lt;/p&gt;
&lt;p&gt;在图灵模型上地最终形式是每次递归，追加进内存中，并重新 &lt;code&gt;goto&lt;/code&gt; 回函数开始，在退出时，再一步步内存推出来，并将递归的剩余部分执行完。&lt;/p&gt;
&lt;p&gt;而在 Lambda 演算中，最终表达为一个逻辑系统构成的严格的数学函数模型的执行。&lt;/p&gt;
&lt;p&gt;这两者便是具体化和形式化的极限，充分表现了两种模型的特点。从根本加深了对两种模型差异的认知，从而让我们在两种模型上都能通过正确的编程思想来写代码，以把代码写得更好。&lt;/p&gt;
&lt;p&gt;当然也是有一些实际意义的，比如在变量作用域严格的语言中，且又必须使用匿名函数的形式来书写你所需要的东西的时候，而你正好又需要递归才能达到你的要求，那么使用 Y-Combinator 是一个可选的方法。然而通常，出现这种情况大多是你写了错误的思想的代码所导致的，实际编程中几乎遇不到这种情况，毕竟将更抽象更容易理解的函数式编程写成这么一坨一眼看不懂的代码是很失败的。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在开始&quot;&gt;&lt;a href=&quot;#写在开始&quot; class=&quot;headerlink&quot; title=&quot;写在开始&quot;&gt;&lt;/a&gt;写在开始&lt;/h2&gt;&lt;p&gt;不得不说，当我开始学习函数式编程的时候，我并没有被匿名函数感到害怕，理解它的基本概念是极其容易的。但是当你试图去将你日常所书写的指令式的代码转换成函数式，特别是纯函数式的时候，你会感到这是不可能的。它和你之前的编程思想是完全脱离的。&lt;/p&gt;
&lt;p&gt;所以当我第一次见到 Y-Combinator（Y 组合子）的时候，我的感觉是懵逼的，这是什么玩意。然而当我一步一步，了解这个东西是什么，它是怎么工作的之后，我对函数式编程的认识有了很大的进步。&lt;/p&gt;
&lt;p&gt;即使是 C++ 这样的语言，也在 C++11 标准中引入了匿名函数，使得你有机会在 C++ 中使用函数式编程的特性。在编程中，如果能适当地使用函数式语法进行编程，将非常有助于你写出一些更好理解、更简单的代码。&lt;/p&gt;
&lt;p&gt;而在了解一些基本概念之后，了解一下 Y-Combinator 是一个极好的选择，这个东西证明了函数式编程对递归的语义理解，证明了其在递归上和指令式编程的等价之处。你可以通过观察等价的这两者的不同的实现方式，来加深对这两者思想的认识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Lambda" scheme="http://blog.heckpsi.com/tags/Lambda/"/>
    
      <category term="编程" scheme="http://blog.heckpsi.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Lisp" scheme="http://blog.heckpsi.com/tags/Lisp/"/>
    
  </entry>
  
  <entry>
    <title>AlphaGo 是怎么下棋的？</title>
    <link href="http://blog.heckpsi.com/2016/03/18/how-alphago-works/"/>
    <id>http://blog.heckpsi.com/2016/03/18/how-alphago-works/</id>
    <published>2016-03-18T15:09:00.000Z</published>
    <updated>2016-04-21T17:15:40.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本来其实不想写这个的，但是看到很多网友以及一些围棋职业选手提出了一些疑问，比如「Google 没有顶尖的棋手为什么能开发出顶尖的围棋机器人？」还有「机械为什么可以在如此直觉主导的游戏中战胜人类？」。这些问题事实上在人工智能领域已经有很多理论来做解释。而且这些理论也并不是 Google 提出的。AlphaGo 所使用的理论大多还是十余年前左右的论文的一些成果。在此之前，使用了这些理论开发出来的人工智能其实已经在 2006 年就已经在 9x9 的小棋盘上战胜周俊勋九段，之后在 2013 年 CrazyStone 程序就已经在让四子前提下战胜过石田芳夫九段，而就在去年，Facebook 的围棋机器人在不让子的前提下，胜过职业选手。至于之前「前百度深度学习研究院」的吴韧所开发的异构神机也使用的是类似的理论，也在前几天战胜过职业棋手。&lt;/p&gt;
&lt;p&gt;这些方法上，AlphaGo 并无太大创新，很大程度上是 Google 团队实现得相对完善以及训练程度更好，以及人工智能算法的实现和调参存在很大的偶然因素。那么究竟是什么方法让机械拥有了和人一样直觉，而不是简单的机械化的思考。这事我们还是要从头讲起。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;无法计算的数据量&quot;&gt;&lt;a href=&quot;#无法计算的数据量&quot; class=&quot;headerlink&quot; title=&quot;无法计算的数据量&quot;&gt;&lt;/a&gt;无法计算的数据量&lt;/h2&gt;&lt;p&gt;早在 1996 年，IBM 的深蓝计算机就战胜了国际象棋世界名将加里·卡斯帕罗夫。但象棋有一个特点，那就是每一步下的选择是相对非常有限的，最多也就十几种可能。哪怕是通过最最暴力的搜索方法，把每种都跑一遍，搜索几十步内的最优解。虽然这个方法随着搜索深度是指数级增长的，但事实上由于底数比饺小，依靠强大的算力还是可以解决的。而深蓝计算机正是这么一台拥有强大算力的超级计算机。&lt;/p&gt;
&lt;p&gt;然而在围棋上，这样就不行了，因为围棋每一步都有上百种选择，如此大的底数纯粹的暴力就显然无法满足了。至少硬件的发展并非每年成百倍成百倍地快速增长的。同样的方法，显然是不适合使用在围棋上的。&lt;/p&gt;
&lt;p&gt;在 2002 年之前，人们长期研究一个可以通过计算静态地分析出每一子的价值出来。然而这个方法的发展一直很慢。直到人们试图尝试一种动态评估一个博弈的一种方法，这就是靠&lt;strong&gt;猜&lt;/strong&gt;。这个方法被称为蒙特卡洛搜索树，其前身是非常著名的上世纪曼哈顿计划期间由乌拉姆和冯·诺依曼提出的&lt;strong&gt;蒙特卡洛方法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果我们想知道圆周率的值，我们如何利用猜的方法来猜出圆周率呢？我们只需要在一个方形中随机而均匀地扔飞镖，数一下，多少个飞镖扔在了以方形边长为直径的圆里，多少扔在了外面，根据圆的面积公式和方形的面积公式就能把 π 算出来。而蒙特卡洛搜索树就是利用蒙特卡洛方法来优化搜索树。简单来说，就是，我们认为这一步下在一个地方是最优的，而我们不知道这地方在哪里。我们先通过一系列随机的采样，从而去猜测一个值，这个值可能是最优解，也可能是一个接近最优解的解。但至少，这可以用来估算像围棋这样大的棋盘的东西了，而不需要把每个细枝末节都同等对待地来暴力搜索。&lt;/p&gt;
&lt;h2 id=&quot;⑨神的大局观&quot;&gt;&lt;a href=&quot;#⑨神的大局观&quot; class=&quot;headerlink&quot; title=&quot;⑨神的大局观&quot;&gt;&lt;/a&gt;⑨神的大局观&lt;/h2&gt;&lt;p&gt;解决完计算量的问题，我们还要来解决人类在围棋上最大的优势——直觉，或者说「大局观」。那么如何才能拥有大局观呢？我们想一下，人们在下围棋的时候，通常会先考虑下在哪个片区，以获得什么样的目的。而这就是所谓的大局观。&lt;/p&gt;
&lt;p&gt;AlphaGo 的另一部分重要思想，得益于神经科学的发展，即人类认识人大脑神经的发展。人类愈发了解了大脑内神经元的工作模式，包括人类学习、认知的神经模型。这样的非常基础的模型，极大地方便了利用计算机来模拟人类进行学习的过程。&lt;/p&gt;
&lt;p&gt;蒙特卡洛方法只是简化了计算，并不具备学习的能力。无论是单纯的蒙特卡洛搜索还是与 α-β 搜索结合的还是和置信区间结合一些版本，都与人类能越学越强的围棋技巧相比差上太多。至少，人脑是一个极其复杂的计算模型，哪怕是现在最好的计算机，其算力和整个大脑比起来还是差很多的。&lt;/p&gt;
&lt;p&gt;在 2007 年，一些科学家试图提出一个新的机器学习模型，即所谓的深度学习。所谓深度学习，你可以看做模拟许多许多人脑中的神经元构成的一个网络。网络的每一层，针对一个特性进行识别。网络的每一层，都是一个单纯分类的无监督学习模型。你可以想像一下，人眼看到一个图像。经过一系列神经元，首先识别出了里面的眼睛、然后识别了里面的鼻子、嘴，再根据这些特性，发现这是一个人。这样依次发现的机制。而学习是通过一个有监督的反向传播进行。即告诉你这张图像里有一条狗，然后反向的一步步调整网络，让网络适应符合怎么样鼻子、嘴、眼睛的是一条狗。通过不断地数据的训练，即可以让模型越来越优。这个模型在图像识别领域已经达到甚至有时超越了人的识别能力。&lt;/p&gt;
&lt;p&gt;而 AlphaGo 使用的就是深度学习来优化蒙特卡洛搜索树。在 AlphaGo 中有两个网络，一个是策略网络，一个是价值网络。策略网络即是一个大局观的网络，机器会先通过其经验，找出其应该做出进攻的反应还是防守的反应，表现在下在哪个片区是最为合适的，是不是应该跟棋之类的大问题。然后再通过蒙特卡洛搜索树去算出具体下在哪里是最合适的。&lt;/p&gt;
&lt;p&gt;而我们说到，深度学习模型是真的和人一样可以学习的。每下一次棋，它就可以进一步调优自己的策略网络。首先 AlphaGo 导入了上千个职业选手对弈的棋谱，使得自己有了一个基础的下棋策略。这时候的 AlphaGo 就和一个受过系统训练的围棋少年一样了。然而这和职业选手的区别还是很大。这也就是所谓的「Google 没有顶尖的棋手为什么能开发出顶尖的围棋机器人？」按照一般常理，AlphaGo 应该一段一段地和人挑战，越发提高自己能力。然而 AlphaGo 不是这么做的，它选择和自己对弈。两台 AlphaGo 来对弈，将对弈的结果调优自己的网络。这个听起来很奇怪，为什么两个下得都不怎么样的棋手一起下棋，棋艺能那么快提升呢？因为它一天能和自己下上百万盘棋，它可以把自己分身成几万份跑在几万台电脑上，以及可以昼夜不停也不会过劳死，而这是任何一个人类都做不到的。AlphaGo 的开发人员说，他曾在早期能下赢 AlphaGo，而很快，AlphaGo 的水平就远超了他。所以 AlphaGo 得到了飞速的提升。仅仅五六个月，AlphaGo 就能从战胜欧洲棋王挑战到世界顶尖选手的水平了。&lt;/p&gt;
&lt;h2 id=&quot;人工智能的基本法&quot;&gt;&lt;a href=&quot;#人工智能的基本法&quot; class=&quot;headerlink&quot; title=&quot;人工智能的基本法&quot;&gt;&lt;/a&gt;人工智能的基本法&lt;/h2&gt;&lt;p&gt;当然搞人工智能也要有基本法。这个基本法就是算力或者说是资源。虽然做了很大的优化，计算下围棋的计算量还是很大的。比起深蓝时依靠超级计算机来解决问题。AlphaGo 选择了一条适合 Google 的路径来解决算力问题。那就是分布式计算。使用分布式计算的 AlphaGo 版本比起不使用的版本其智能程度也是有相当大的提升。即使最简单，它也可以有更多时间来做随机的尝试，以找出更优的价值解。&lt;/p&gt;
&lt;p&gt;同样利用深度学习优化蒙特卡洛搜索的 Facebook 围棋团队，相比 Google 就没有那么壕力冲天了。无论是开发资源还是人员来说也是远少于 Google。Facebook 的围棋机器人之前也取得了相当好的成绩，大概可以击败职业二段选手的水平。但是比起 AlphaGo，还是差上许多。&lt;/p&gt;
&lt;p&gt;所以说，做这么一个人智能，背后的投入程度、重视程度也起到了很大的作用。这也是为什么深度学习目前做得很好的公司大多是一些顶尖的 IT 企业里的研发团队。&lt;/p&gt;
&lt;h2 id=&quot;后记&quot;&gt;&lt;a href=&quot;#后记&quot; class=&quot;headerlink&quot; title=&quot;后记&quot;&gt;&lt;/a&gt;后记&lt;/h2&gt;&lt;p&gt;比起 AlphaGo 在围棋上的成就，其实大多数人很好奇人工智能未来的何去何从。从这次中，我们看到计算机已经具备了人类大局判断能力，其本质是类似于人类的学习能力，即不告诉电脑应该怎么做，而让电脑看人类是怎么做的。这项的应用其实相当广泛，尤其在非常复杂的问题上。&lt;/p&gt;
&lt;p&gt;比如说，无人驾驶汽车之前发展很困难，是因为人们总是试图去把驾驶规则完全讲给电脑，而这点太过复杂，难以用纯逻辑说清。而今天 Google 的无人驾驶汽车也是使用的类似的深度学习的技术，让计算机观察人类开车并学习，从而模仿人类的判断。最终依靠计算机强大的算力和不会疲劳等特点，甚至超越人类的判断。&lt;/p&gt;
&lt;p&gt;短期来看，利用深度学习的人工智能在未来数年内将会得到很大的应用。而这也是 Google 热衷于下围棋的原因。醉翁之意不在酒，在乎山水之间也。Google 只是想利用围棋来显示他们在深度学习应用上的先进水平。&lt;/p&gt;
&lt;p&gt;就人工智能的最终目的来看，我们已经跨出了很大的一步。之前而言，我们很大程度局限于人类强大的抽象的思考能力，而模仿人类神经系统的模型已经很好地模拟了这种思考是怎么产生的了。进一步说，如果一个机器，拥有和人完全一样的眼睛、耳朵、鼻子、触觉等作为它的输入，以及类似于人类肌肉和关节的机械部件作为它的输出。并且模拟一个和人脑一样复杂程度的神经网络，并让它观察人类进行学习。是不是在某个未来，我们可以拥有和人类功能非常接近甚至超越人类的智能的出现。深度学习都为这样的强人工智能提出了理论上的基础。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本来其实不想写这个的，但是看到很多网友以及一些围棋职业选手提出了一些疑问，比如「Google 没有顶尖的棋手为什么能开发出顶尖的围棋机器人？」还有「机械为什么可以在如此直觉主导的游戏中战胜人类？」。这些问题事实上在人工智能领域已经有很多理论来做解释。而且这些理论也并不是 Google 提出的。AlphaGo 所使用的理论大多还是十余年前左右的论文的一些成果。在此之前，使用了这些理论开发出来的人工智能其实已经在 2006 年就已经在 9x9 的小棋盘上战胜周俊勋九段，之后在 2013 年 CrazyStone 程序就已经在让四子前提下战胜过石田芳夫九段，而就在去年，Facebook 的围棋机器人在不让子的前提下，胜过职业选手。至于之前「前百度深度学习研究院」的吴韧所开发的异构神机也使用的是类似的理论，也在前几天战胜过职业棋手。&lt;/p&gt;
&lt;p&gt;这些方法上，AlphaGo 并无太大创新，很大程度上是 Google 团队实现得相对完善以及训练程度更好，以及人工智能算法的实现和调参存在很大的偶然因素。那么究竟是什么方法让机械拥有了和人一样直觉，而不是简单的机械化的思考。这事我们还是要从头讲起。&lt;/p&gt;
    
    </summary>
    
    
      <category term="科普" scheme="http://blog.heckpsi.com/tags/%E7%A7%91%E6%99%AE/"/>
    
      <category term="AlphaGo" scheme="http://blog.heckpsi.com/tags/AlphaGo/"/>
    
      <category term="AI" scheme="http://blog.heckpsi.com/tags/AI/"/>
    
      <category term="Google" scheme="http://blog.heckpsi.com/tags/Google/"/>
    
      <category term="机器学习" scheme="http://blog.heckpsi.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>也谈 Android 应用的热更新</title>
    <link href="http://blog.heckpsi.com/2016/02/06/android-hot-patch/"/>
    <id>http://blog.heckpsi.com/2016/02/06/android-hot-patch/</id>
    <published>2016-02-05T16:29:00.000Z</published>
    <updated>2016-04-21T16:33:33.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;这几天支付宝的所谓「隐私门」的火热程度非同一般。至于支付宝有没有监控用户的隐私数据，双方至今也没有争论出一个结果出来。但我倒是被阿里官方所发的声明所惊讶到了，它们在声明中提到，他们可以在云端开关你手上支付宝的功能，这一点是违背对 Java 作为静态语言的常识的。而网友更是发现，这一点并不是用 API 来简单控制的，而是可以从云端下发代码下来来实现「热更新」，随时修改 apk 的本身。稍加研究，就发现了手机淘宝团队曾经在 QCon 上做过有关于相关主题的 &lt;a href=&quot;http://www.infoq.com/cn/presentations/mobile-phone-taobao-hotpatch-technology-introduction&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;演讲&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;手机淘宝的热更新技术基于他们所开发的 Dexposed 框架，而 Dexposed 框架其实就是一个应用内的 Xposed 框架，而手机淘宝团队也大方承认了他们的许多代码也是直接从 Xposed 的开源项目里拿的。通过这个技术，框架对应用内的类都实现了 hook，可以通过云端下发的 dex 对这些类进行动态的修改，并且只损失相当较小的性能。而这个技术脱离了传统想要动态修改代码必须把整个开发框架都更换为运行于脚本语言之上的尴尬。&lt;/p&gt;
&lt;p&gt;然而当我细究这个框架的时候发现了一些问题。阿里虽然对这一框架进行了 &lt;a href=&quot;http://github.com/alibaba/dexposed&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;开源&lt;/a&gt; 。但已经很久没有更新过新版本了。当前的版本只支持到了 Android 4.4。由于 5.0 起新的 ART 虚拟机、更严格的 SELinux 策略以及对 64 位的支持之类的事，使得 Xposed 都在开发上做了很多调整。我不知道 Dexposed 现在是否支持，但至少阿里没有开源。&lt;/p&gt;
&lt;p&gt;考虑到这些情况，我正在考虑我们是不是有一个其它的更加通用的路径在 Java 上来实现动态的修改方法从而进行热更新。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;警告&quot;&gt;&lt;a href=&quot;#警告&quot; class=&quot;headerlink&quot; title=&quot;警告&quot;&gt;&lt;/a&gt;警告&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;在本地动态执行远端下发的代码是极度危险的行为。利用此方法执行非法代码等或用于绕过 Google Play 等市场的审查是违反相关协议的，也是对用户极度不负责任的行为。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;ART-虚拟机带来的挑战&quot;&gt;&lt;a href=&quot;#ART-虚拟机带来的挑战&quot; class=&quot;headerlink&quot; title=&quot;ART 虚拟机带来的挑战&quot;&gt;&lt;/a&gt;ART 虚拟机带来的挑战&lt;/h2&gt;&lt;p&gt;Xposed 面对 ART 虚拟机的时候究竟是遇到了什么样的问题呢？这要从 ART 虚拟机的原理说起。Java 是一门编译成 ByteCode，并由本地的虚拟机进一步动态地解释成机器码的语言。在旧版本的 Android 上所使用的 Dalvik 虚拟机其运行原理与 Oracle 的官方虚拟机是非常接近的。这样的解释对性能的消耗，虽然有 JIT 对其运行的优化，比起像 Objective-C 这样的纯编译语言来说还是差上一些性能的。&lt;/p&gt;
&lt;p&gt;为了解决性能上的颓势，Android 在 4.4 版本上首次引入了默认不开启的测试版本的 ART 虚拟机，并在 Android 5.0 上成为了默认的虚拟机。其重要的变化是在 apk 的安装过程中，进行所谓 AOT(Ahead-of-Time) 的优化。即在安装过程中尽可能地将 ByteCode 静态编译了，并进行代码优化。这使得运行时注入的难度更高了。&lt;/p&gt;
&lt;p&gt;Xposed 框架通过修改了 libart.so 等相关虚拟机文件关闭了一系列的优化，才使得框架终在 Android 5.0 上运行。而相对的，Dexposed 并不能修改系统虚拟机文件，毕竟这只是应用内的框架，这就使得难度变得很高。代码一旦被静态编译甚至被优化后再做 Java 层面上的 hook 确实难度很高。那么我们能不能在 Java 本身上找到一种被语言本身所支持的 hook 方式以使得更好的兼容呢？&lt;/p&gt;
&lt;h2 id=&quot;Java-的馈赠&quot;&gt;&lt;a href=&quot;#Java-的馈赠&quot; class=&quot;headerlink&quot; title=&quot;Java 的馈赠&quot;&gt;&lt;/a&gt;Java 的馈赠&lt;/h2&gt;&lt;p&gt;显然，Java 是没有 eval() 函数的，也就是没有语言本身所支持的可以动态运行 Java 代码的方法。但当我在 Java 的文档里搜索 eval 的时候，我还真发现了一些什么。自 JDK 1.6 起，Java 内置了一个执行脚本的包 javax.script。目前支持的语言只有 JavaScript。也就是说 Java 内置了一个「动态语言」 JavaScript 的解释器！&lt;/p&gt;
&lt;p&gt;等一下，我并不是希望你用 JavaScript 来写 Android 应用，因为这毕竟不那么快，我们之所以写原生应用，性能是我们考虑的一大原因。但是如果我们仅在热更新时「临时地」插入一段 JavaScript 代码也并不是一件坏事。但这样的话就存在一个问题，那就是 Java 的变量和 JavaScript 变量如何绑定的问题了。没关系，ScriptEngine 早已实现了这一功能。你可以通过 ScriptEngine.put(String, Object) 的方法在运行前写入 JavaScript 的变量，在运行后通过 ScriptEngine.get(String) 的方法来获得变量。&lt;/p&gt;
&lt;p&gt;示例的 Java 代码：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ScriptEngine engine = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ScriptEngineManager().getEngineByName(&lt;span class=&quot;string&quot;&gt;&quot;javascript&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  engine.put(&lt;span class=&quot;string&quot;&gt;&quot;a&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  engine.put(&lt;span class=&quot;string&quot;&gt;&quot;b&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  engine.eval(&lt;span class=&quot;string&quot;&gt;&quot;var ans_1 = a + b; var ans_2 = a - b;&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  System.out.println(engine.get(&lt;span class=&quot;string&quot;&gt;&quot;ans_1&quot;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  System.out.println(engine.get(&lt;span class=&quot;string&quot;&gt;&quot;ans_2&quot;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Exception e)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;打印如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;3.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-1.0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;利弊&quot;&gt;&lt;a href=&quot;#利弊&quot; class=&quot;headerlink&quot; title=&quot;利弊&quot;&gt;&lt;/a&gt;利弊&lt;/h2&gt;&lt;p&gt;这样做的好处是很显然的，这是 Java 语言层的支持，兼容性好得惊人。而且，这不会影响到 ART 虚拟机的 AOT 优化，你的代码依然可以在 Android 5.0+ 上和原来一样快。&lt;/p&gt;
&lt;p&gt;但弊端也是很明显的。插入的代码由于是脚本语言，初始化脚本语言引擎和变量传递都是一个比较消耗性能的东西。但是你大可只在热更新的地方才初始化脚本语言引擎，在没有被更新到的地方依然正常地运行下去。不过在一些访问非常密集的地方使用热更新可能会对效率产生相对比较大的影响，应该避免使用。&lt;/p&gt;
&lt;h2 id=&quot;示例封装&quot;&gt;&lt;a href=&quot;#示例封装&quot; class=&quot;headerlink&quot; title=&quot;示例封装&quot;&gt;&lt;/a&gt;示例封装&lt;/h2&gt;&lt;p&gt;说完这些，我们可以对 Java 的 ScriptEngine 进行一些封装成为一个 HotPatch 类使得它更适合做热更新的工作。&lt;/p&gt;
&lt;p&gt;Hot Patch 需要注入的地方分为三个类型&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;入口 Activity&lt;/li&gt;
&lt;li&gt;类方法&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;入口-Activity&quot;&gt;&lt;a href=&quot;#入口-Activity&quot; class=&quot;headerlink&quot; title=&quot;入口 Activity&quot;&gt;&lt;/a&gt;入口 Activity&lt;/h3&gt;&lt;p&gt;对于入口 Activity，我们希望它能发送一个异步的网络请求检测是否有新的热补丁，如果有，那么下载。下载后将对应的需要 hook 的地方的名称和对应的代码以 key-value 的形式保存下来就行。出于方便，我们可以直接使用 Android 内置的 &lt;code&gt;SharedPreferences&lt;/code&gt; 来存储。这样我们只需要在 Activity 的 &lt;code&gt;onCreate&lt;/code&gt; 中通过一个 Annotation 来插入。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Bundle savedInstanceState)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.onCreate(savedInstanceState);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;meta&quot;&gt;@HotPatchUpdate&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;https://www.hotpatch.com/getUpdate&quot;&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;需要注意的是，这个 Update 的实现需要有几个注意点。这个管道一定要建立在 https 上，因为下发代码是极其危险的，如果被劫持，后果是无法想象的。其次请求时最好自动带上 Android 版本、手机型号、地区、版本号等信息，以方便更精确地下发，千万不能下发错。然后每次执行到这里时应先检查是否有已经下载好的补丁。如果有，请校验其是否合法，以避免用户升级后，相关的补丁已经过期却仍然被运行导致更大的问题。&lt;/p&gt;
&lt;h3 id=&quot;类方法&quot;&gt;&lt;a href=&quot;#类方法&quot; class=&quot;headerlink&quot; title=&quot;类方法&quot;&gt;&lt;/a&gt;类方法&lt;/h3&gt;&lt;p&gt;类方法里主要有两处做 hook 是最为有效的，一个是方法的一开始，而另一处是 return 处。只要将方法的 i/o hook 了，就能解决所有问题。&lt;/p&gt;
&lt;p&gt;所以我们分别在这两处插入两个 Annotation 的方法，在尽可能不影响优雅度地情况下插入代码。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Test&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; android.content.Context context;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Test&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(android.content.Context context)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.context = context;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@HotPatchHook&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;addStart&quot;&lt;/span&gt;, context, a, b)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; c = a + b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@HotPatchHook&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;addEnd&quot;&lt;/span&gt;, context, c)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; c;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中 &lt;code&gt;&amp;quot;addStart&amp;quot;&lt;/code&gt; 和 &lt;code&gt;&amp;quot;addEnd&amp;quot;&lt;/code&gt; 分别是两个索引，分别对应去寻找热补丁中对应的代码。而 context 必须传入是因为要找 &lt;code&gt;SharedPreferences&lt;/code&gt;，如果你通过其它方式来实现存储的话，则不需要。&lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 还有 &lt;code&gt;c&lt;/code&gt; 是被 Hook 的变量。有一点特别注意，当参数被 JavaScript 引擎传回时请校验其是否是 null。至于如果一个类型在 JavaScript 中找不到的话，Java 中的 ScriptEngine 所支持的 JavaScript 是可以插入 Java 的 import 包的，所以可以避开这样的问题。形如  &lt;code&gt;String jsCode = &amp;quot;importPackage(java.util);var list2 = Arrays.asList([&amp;#39;A&amp;#39;, &amp;#39;B&amp;#39;, &amp;#39;C&amp;#39;]); &amp;quot;;&lt;/code&gt;  的代码是可以被解释的。当然你也可以只传入 &lt;code&gt;int&lt;/code&gt;、&lt;code&gt;double&lt;/code&gt;、&lt;code&gt;boolean&lt;/code&gt; 类型，然后手动写 &lt;code&gt;set&lt;/code&gt; 和 &lt;code&gt;get&lt;/code&gt; 方法。这取决于你自己想要什么样的代码风格。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;至此，我们通过实现两个简单的 Annotation 的方法，实现在 Android 上 Java 语言层面所支持的热更新的方法。当然，这样的实现并不是太过完善，还需要做很多细节上的调整。但是对于简单的热更新来说已经是足够好用了，实现一遍的话所需要的代码数也很少。同时，稍作修改，我们可以将这样的代码运行在任何 Java 程序上，实现 Java 客户端的热更新，而不只局限于 Android。&lt;/p&gt;
&lt;p&gt;这样的热更新虽然会带来少许的性能问题，但比起将整个程序都跑在脚本上，这样的解决方案已经好上很多，更重要的是，当你没有热更新时，并不会对性能造成影响。同时，其 Java 语言层面的支持，也使得其兼容性非常良好，可以作为对于作为线上、线下调试的比较好的工具。&lt;/p&gt;
&lt;p&gt;相比 Dexposed，这样的方法还显得比较低级，也无法 hook 系统类，没有办法做更多更底层的操作，也无法支持 ndk。但一般意义上来说，这已经足够好用了。&lt;/p&gt;
&lt;p&gt;但是，最后还是要提醒一句：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在本地动态执行远端下发的代码是极度危险的行为。利用此方法执行非法代码等或用于绕过 Google Play 等市场的审查是违反相关协议的，也是对用户极度不负责任的行为。&lt;/strong&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;这几天支付宝的所谓「隐私门」的火热程度非同一般。至于支付宝有没有监控用户的隐私数据，双方至今也没有争论出一个结果出来。但我倒是被阿里官方所发的声明所惊讶到了，它们在声明中提到，他们可以在云端开关你手上支付宝的功能，这一点是违背对 Java 作为静态语言的常识的。而网友更是发现，这一点并不是用 API 来简单控制的，而是可以从云端下发代码下来来实现「热更新」，随时修改 apk 的本身。稍加研究，就发现了手机淘宝团队曾经在 QCon 上做过有关于相关主题的 &lt;a href=&quot;http://www.infoq.com/cn/presentations/mobile-phone-taobao-hotpatch-technology-introduction&quot;&gt;演讲&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;手机淘宝的热更新技术基于他们所开发的 Dexposed 框架，而 Dexposed 框架其实就是一个应用内的 Xposed 框架，而手机淘宝团队也大方承认了他们的许多代码也是直接从 Xposed 的开源项目里拿的。通过这个技术，框架对应用内的类都实现了 hook，可以通过云端下发的 dex 对这些类进行动态的修改，并且只损失相当较小的性能。而这个技术脱离了传统想要动态修改代码必须把整个开发框架都更换为运行于脚本语言之上的尴尬。&lt;/p&gt;
&lt;p&gt;然而当我细究这个框架的时候发现了一些问题。阿里虽然对这一框架进行了 &lt;a href=&quot;http://github.com/alibaba/dexposed&quot;&gt;开源&lt;/a&gt; 。但已经很久没有更新过新版本了。当前的版本只支持到了 Android 4.4。由于 5.0 起新的 ART 虚拟机、更严格的 SELinux 策略以及对 64 位的支持之类的事，使得 Xposed 都在开发上做了很多调整。我不知道 Dexposed 现在是否支持，但至少阿里没有开源。&lt;/p&gt;
&lt;p&gt;考虑到这些情况，我正在考虑我们是不是有一个其它的更加通用的路径在 Java 上来实现动态的修改方法从而进行热更新。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://blog.heckpsi.com/tags/Android/"/>
    
      <category term="JavaScript" scheme="http://blog.heckpsi.com/tags/JavaScript/"/>
    
      <category term="架构" scheme="http://blog.heckpsi.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS 是如何保证安全的？</title>
    <link href="http://blog.heckpsi.com/2015/11/01/how-https-makes-communication-secured/"/>
    <id>http://blog.heckpsi.com/2015/11/01/how-https-makes-communication-secured/</id>
    <published>2015-11-01T07:15:37.000Z</published>
    <updated>2016-04-21T17:37:15.000Z</updated>
    
    <content type="html">&lt;p&gt;每当我们讨论到信息安全的时候，我们最长接触到的信息加密传输的方式莫过于 HTTPS 了，当我们浏览器地址栏闪现出绿色时，就代表着这个网站支持 HTTPS 的加密信息传输方式，并且你与它的连接确实被加密了。但是 HTTPS 并不是一个单一的东西，它知识我们常见的 HTTP 协议和某个加密协议的一个混合，这个加密协议通常会是 TLS。那么 HTTPS 为什么安全呢？其实我们需要先考虑 HTTP 为什么不安全。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;假设你坐在一个教室里，你现在非常想把某个信息传递给教室里的另一个人，一般来说，会选择，传纸条。传纸条这个比喻其实非常正确，这就是互联网的一个基础协议 TCP/IP 协议基本的工作模式。而通常，HTTP 协议的数据是使用 TCP/IP 协议进行发送的。HTTP 指的是你在纸条上写明你要传送的目的地是哪个同学的坐位，然后再是要传递的内容。途径的同学拿到纸条后根据纸条上显示的地址依次传过去就好了。这样要面临的第一个问题就是：途径的同学可以完全知道你写了什么。&lt;/p&gt;
&lt;p&gt;这就是 HTTP 面临的第一个问题，这个问题通常被叫做 “窃听” 或者 “嗅探” ，指的是和你在同一个网络下或者是途径的路由上的攻击者可以偷窥到你传输的内容。这是 HTTPS 要解决的第一个问题。这种问题通常是通过“加密”来解决的。从非常原始的角度来考虑，其实就是双方约定一个暗号。用什么字母去替代什么字母之类的。不过考虑到互联网每天有无数信息需要加密，这种原始的加密方法似乎不太适合。不过实际上方法也差不多，一般是采用一种叫做 AES 的算法来解决的。这种算法需要一个 密钥 key 来加密整个信息，加密和解密所需要使用的 key 是一样的，所以这种加密一般也被称为“对称加密”。AES 在数学上保证了，只要你使用的 key 足够足够足够足够的长，破解是几乎不可能的。&lt;/p&gt;
&lt;p&gt;我们先假设这种破解确实是不可能的，而且目前也确实没有对 AES 本身能发动起有效的攻击的案例出现。&lt;/p&gt;
&lt;p&gt;我们再回到这个教室，你接着要传小纸条，你把地址写上后，把要传输的内容用 AES 蹭蹭蹭加密了起来。刚准备传，问题来了。AES 不是有一个 key 吗？key 怎么给目的地啊？如果我把密钥直接写在纸条上，那么中间的人不依然可以解密吗？在现实中你可以通过一些其它方法来把密钥安全传输给目的地而不被其他人看见，但是在互联网上，要想这么做难度就很大了，毕竟传输终究要经过这些路由，所以要做加密，还得找一个更复杂的数学方法。&lt;/p&gt;
&lt;p&gt;于是聪明的人们发明了一种更复杂的加密算法——非对称加密。这种加密或许理解起来比较困难，这种加密指的是可以生成一对密钥 (k1, k2)。凡是 k1 加密的数据，k1 自身不能解密，而需要 k2 才能解密；凡是 k2 加密的数据，k2 不能解密，需要 k1 才能解密。这种算法事实上有很多，常用的是 RSA，其基于的数学原理是两个大素数的乘积很容易算，而拿到这个乘积去算出是哪两个素数相乘就很复杂了。好在以目前的技术，分解大数的素因数确实比较困难，尤其是当这个大数足够大的时候（通常使用2的10次方个二进制位这么大），就算是超级计算机解密也需要非常长的时间。&lt;/p&gt;
&lt;p&gt;现在利用这种非对称加密的方法，我们来设想一个场景。你继续想要传纸条，但是传纸条之前你先准备把接下来通讯的对称加密密钥给传输过去。于是你用 RSA 技术生成了一对 k1、k2，你把 k1 用明文发送了出去，路经有人或许会截取，但是没有用，k1 加密的数据需要用 k2 才能解密。而此时，k2 在你自己的手里。k1 送达目的地后，目的地的人会去准备一个接下来用于对称加密传输的密钥 key，然后用收到的 k1 把 key 加密了，把加密好的数据传回来。路上的人就算截取到了，也解密不出 key。等到了你自己手上，你用手上的 k2 把用 k1 加密的 key 解出来，现在全教室就只有你和你的目的地拥有 key，你们就可以用 AES 算法进行对称加密的传输啦！这时候你和目的地的通讯将无法再被任何人窃听！&lt;/p&gt;
&lt;p&gt;当然，这时候你可能会问两个问题。&lt;/p&gt;
&lt;p&gt;既然 非对称加密 可以那么安全，为什么我们不直接用它来加密信息，而是去加密 对称加密 的密钥呢？&lt;/p&gt;
&lt;p&gt;这是因为 非对称加密 的密码对生成和加密的消耗时间比较长，为了节省双方的计算时间，通常只用它来交换密钥，而非直接用来传输数据。&lt;/p&gt;
&lt;p&gt;使用 非对称加密 是完全安全的吗？&lt;/p&gt;
&lt;p&gt;听起来确实是挺安全的，但实际上，还有一种更恶劣的攻击是这种方法无法防范的，这就是传说中的“中间人攻击”。我们继续让你坐在教室里传小纸条。现在你和目的地上途径一个中间人，他有意想要知道你们的消息。由于这个描述比较复杂，我们将你称为 A，你的目的地称为 B，而中间人称为 M。当你要和 B 完成第一次密钥交换的时候，途径了 M。M 知道你要进行密钥交换了，它把小纸条扣了下来，假装自己是 B，伪造了一个 key ，然后用你发来的 k1 加密了 key 发还给你，你以为你和 B 完成了密钥交换，实际上你是和 M 完成了密钥交换。同时 M 和 B 完成一次密钥交换，让 B 误以为和你完成了密钥交换。现在，由 A -&amp;gt; B完整的加密，变成了 A（加密连接1） -&amp;gt; M（明文）-&amp;gt;B（加密连接2）的情况了。这时候 M 依然可以知道 A 和 B 传输中的全部信息。&lt;/p&gt;
&lt;p&gt;对于这种事，我们似乎很难找到一个解决方法来解决这个问题，除非我们能从源头保证，你密钥交换的对象是安全的。这时候我们就要认识互联网 HTTPS 和你传纸条的微妙区别了。你传纸条时，你和你的目的地的关系几乎是对等的。而你访问网站时，你访问的对象通常是一个比较大的服务供应商，他们有充沛的资源，也许可以证明他们的合法性。&lt;/p&gt;
&lt;p&gt;这时候我们会引入一个第三方叫做 CA。CA 是一些非常权威的专门用于认证一个网站合法性的组织。服务商可以向他们申请一个证书，使得他们建立安全连接时可以带上 CA 的签名。而 CA 的安全性由操作系统或浏览器来认证。你的 Windows、Mac、Linux、Chrome、Safari 等会在安装时带上一个他们认为安全的 CA 证书列表。如果和你建立安全连接的人带着这些人的签名，那么认为这个安全连接是安全的，没有遭到中间人攻击。&lt;/p&gt;
&lt;p&gt;CA 证书通常情况下是安全的。因为一旦某个 CA 颁发出的某个证书被用于了非法用途，浏览器和操作系统一般会通过更新将整个 CA 颁发过的全部证书全部视为不安全。这使得 CA 通常在颁发证书时是比较小心的。&lt;/p&gt;
&lt;p&gt;所以通过 对称加密 + 非对称加密 + CA认证 这三个技术混合在一起，才使得 HTTP 的后面加上了一个 S —— Security。实际上 HTTPS 的协议比我这里描述的更复杂一些，我这里说的主要是基本的实现原理。因为其中任何一环稍有闪失，就会使得整个加密都将变得不安全。这也是为什么 HTTPS 的加密协议从SSL 1.0 升级到 SSL 3.0 再被 TLS 1.0 现在被 TLS 1.2 取代，其背后都是一环环细节上的修改，以防任何地方的闪失。&lt;/p&gt;
&lt;p&gt;但即使如此，你的 HTTPS 尽可能的保证了你传输的安全，但这种安全也不是绝对的。比如 CA 证书出了问题被用于了中间人攻击，在短期内，你的安全将会陷入直接的麻烦直到浏览器或操作系统重新更新了你的 CA 列表或者你手动调整了这个列表。但大多情况下不必杞人忧天，它基本上是安全的。&lt;/p&gt;
&lt;p&gt;当然了，路由也可以选择直接丢包，它看不到的，也不让你看到。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;每当我们讨论到信息安全的时候，我们最长接触到的信息加密传输的方式莫过于 HTTPS 了，当我们浏览器地址栏闪现出绿色时，就代表着这个网站支持 HTTPS 的加密信息传输方式，并且你与它的连接确实被加密了。但是 HTTPS 并不是一个单一的东西，它知识我们常见的 HTTP 协议和某个加密协议的一个混合，这个加密协议通常会是 TLS。那么 HTTPS 为什么安全呢？其实我们需要先考虑 HTTP 为什么不安全。&lt;/p&gt;
    
    </summary>
    
    
      <category term="HTTPS" scheme="http://blog.heckpsi.com/tags/HTTPS/"/>
    
      <category term="安全" scheme="http://blog.heckpsi.com/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="通讯" scheme="http://blog.heckpsi.com/tags/%E9%80%9A%E8%AE%AF/"/>
    
  </entry>
  
  <entry>
    <title>SA 屏究竟是一套什么样的技术？（上）</title>
    <link href="http://blog.heckpsi.com/2015/11/01/super-amoled-introduction-part-1/"/>
    <id>http://blog.heckpsi.com/2015/11/01/super-amoled-introduction-part-1/</id>
    <published>2015-11-01T07:15:00.000Z</published>
    <updated>2016-04-21T16:33:53.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;从 LED 聊到 Super AMOLED&lt;/strong&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;万物基于-MIUI-LED&quot;&gt;&lt;a href=&quot;#万物基于-MIUI-LED&quot; class=&quot;headerlink&quot; title=&quot;万物基于 MIUI LED&quot;&gt;&lt;/a&gt;万物基于 &lt;del&gt;MIUI&lt;/del&gt; LED&lt;/h3&gt;&lt;p&gt;LED 是一项非常古老的技术，如果我们追溯其起源，可以到达五十多年前的 1961 年。今天已经是世界第三大半导体制造商德州仪器（Texas Instruments）的两位研究员 Robert Biard 和 Gary Pittman 首次发现了基于砷化镓的半导体材料能够放射出红外线。次年，通用电气公司的（General Electiric Company）的 Nick Holonyak 制造出了首个可以发出可见光的 LED。&lt;/p&gt;
&lt;p&gt;LED，Light-Emitting Diode 即「发光二极管」究其本质当然是一种能发光的半导体。二极管的基本特性简单来理解是说当电流从一个方向流过时，能够很正常的导通。但从反方向流过时，会受到较大的电阻，只能产生微弱的电流。然而这样的特性对于发光特性并没有什么直接的联系。那 LED 为什么会成为一项主流的发光技术呢？那我们应该和另一项我们常见的发光技术来比较发光原理，那就是钨丝灯泡或卤素灯泡（钨卤灯泡）。&lt;/p&gt;
&lt;p&gt;电灯泡的基本原理是根据了黑体辐射理论（非常有意思的是黑体辐射理论作为量子力学的一部分提出在灯泡发明后的一百余年），物体在不同温度下能发出不同频率的光，当温度小的时候通常是肉眼不可见的红外线，而温度高了之后就能发出可见光了（比如我们看到打铁的时候铁块会发出红光）。这样的灯泡首先首先体积不小，其次温度很高，更糟糕的是，白炽灯只有少于 10% 的能量会成为光，发光效率非常低下。&lt;/p&gt;
&lt;p&gt;而 LED 由半导体材料组成，当电流从阳极（p极）流向阴极（n极）的时候，电子会跌落到较低能阶的轨道上，多出的能量会以电磁波（光子）的形式被释出。这样从理论上是发光效率极高的，因为少掉的能量几乎都变成了放出的电磁波。而我们只需要让放出的电磁波是可见光波段我们即可实现发光的作用了。体积、工作温度、发光效率都能远超电灯泡。&lt;/p&gt;
&lt;p&gt;对于 LED 的发展事实上只有一个问题需要考虑，那就是半导体的材料。材料决定了发出了光的频率即颜色。如今人们发现的 LED 无机材料已经超过了 20 多种。&lt;/p&gt;
&lt;h3 id=&quot;把不要显示的东西遮住，液晶显示器（LCD）的基本原理&quot;&gt;&lt;a href=&quot;#把不要显示的东西遮住，液晶显示器（LCD）的基本原理&quot; class=&quot;headerlink&quot; title=&quot;把不要显示的东西遮住，液晶显示器（LCD）的基本原理&quot;&gt;&lt;/a&gt;把不要显示的东西遮住，液晶显示器（LCD）的基本原理&lt;/h3&gt;&lt;p&gt;LED 的最经典的应用当然不是各种信号灯之类，而是是现在普遍使用的液晶显示器（LCD）了。LED 技术的出现意味着我们可以做出比起 CRT（阴极射线管）那样要远距离开枪发光的屏幕更薄更小的屏幕了。然而要利用 LED 做屏幕我们有几个非常关键的问题要解决。首先，LED 的成本并不低，如果我们为每个像素都配上红绿蓝三个 LED 这将变得非常昂贵。但如果我们不这么做的话是无法发出任何合成光的，至少，LED 发的光都是单色光，而像白色这样的光都是合成光，是无法实现的。&lt;/p&gt;
&lt;p&gt;读到这里的有些同学可能就要产生疑问了，既然如此，那我们平时看到商场里卖的白色 LED 灯泡又是怎么做的呢？事实上，现在我们看到的白光 LED 是蓝色或者紫外 LED，然后在灯泡内壁上涂上能吸收蓝光或紫外线发出红光绿光蓝光的荧光剂，从而发出红绿蓝的混合光，即白光。这时候我们就有个很大的消耗，就是荧光剂转换光的颜色的过程中会浪费一部分能量，所以我们看到白色 LED 的发热相比其他颜色还是要高一点的。&lt;/p&gt;
&lt;p&gt;除了利用荧光发出白光的 LED 的技术的发明，另一项重要的技术也是 LCD 发明的重要步骤，那就是液晶（Liquid Crystal）。液晶存在一个特殊的性质就是它的液晶相能改变偏光性。&lt;/p&gt;
&lt;p&gt;简单的你可以认为，一束光含有非常多的小的光子，每个光子在向前运动过程中，自身还会沿着某个随机的方向发生小的振动。而透过一片液晶后，横向振动的正常通过了；垂直振动的撞在了液晶上，能量被液晶吸收放出了热能，无法通过；斜着振动的，垂直部分的能量被吸收，而横向的能量保持，继续通过了液晶。从宏观的角度来看，亮度减少了一半。而如果连续通过两个液晶，而他们能通过的方向是正好垂直的，那么 100% 的光都可以被吸收，完全不发光。&lt;/p&gt;
&lt;p&gt;而液晶本身对电信号敏感，意味着我们能通过通电来改变液晶的方向，从而很容易地控制哪些光应该被遮住哪些应该被通过。屏幕上其实是有两块液晶构成的，第一块就是单纯只让一个方向的光通过，而第二层由电信号控制，来决定透过多少光，显示一个多亮的东西。&lt;/p&gt;
&lt;p&gt;LCD 显示器是由一块白色的 LED 背光，一片液晶和一片被电信号控制的液晶组成的。彩色的 LCD 显示器就是在背光上再贴上红色绿色蓝色的贴纸，来精确控制每个颜色的亮度而已。然而事实上，这种能量损耗是惊人的。首先 LED 由蓝色变成白色需要损失一部分能量，再贴上三色的贴纸又要损失 66% 的能量，通过一片液晶又会损失 50% 的能量。所以最下面的 LED 背光需要非常亮才行。&lt;/p&gt;
&lt;p&gt;尽管如此，这项技术随着时间的发展已经变得非常成熟，显示效果非常地好。直到智能手机发明后的好一段时间大家发现，手机的主要耗电都放在了屏幕上，而手机的电池又不那么够用。我们急需一项新技术来改进我们显示的功耗。&lt;/p&gt;
&lt;h3 id=&quot;OLED-——-更低的成本，更大的应用可能&quot;&gt;&lt;a href=&quot;#OLED-——-更低的成本，更大的应用可能&quot; class=&quot;headerlink&quot; title=&quot;OLED —— 更低的成本，更大的应用可能&quot;&gt;&lt;/a&gt;OLED —— 更低的成本，更大的应用可能&lt;/h3&gt;&lt;p&gt;我们之前说到 LED 决定颜色的主要关键在于材料，但我之前也说我们发现了超过 20 种无机材料，无机材料简单来说就是一些合金，组合的数量其实很少，可供选择的改进很少，已有的选项生产成本都不低。然而这时候我们需要谈到一个人，他叫做邓青云，他出生于英属香港，后在英属哥伦比亚大学得到化学理学士学位，后进入康奈尔大学获得物理化学博士学位，之后于 1975 年进入柯达公司 Rochester 实验室工作。在实验中意外发现了一些有机材料也可以成为这样的材料。OLED 使用了有机化合物作为半导体材料，工艺简单、成本低廉甚至还能用印刷方式制造。这意味着我们可以用 OLED 印刷出一个大面积的发光面。&lt;/p&gt;
&lt;p&gt;这些特性都是传统 LED 没有的。我们用红色、绿色、蓝色的 OLED 通过印刷方法就能得到一个很大的屏幕，通过电信号单独控制每个灯，我们就能精确发出光的亮度。在显示黑色的时候耗能几乎是 0，发光不透过彩色贴纸、不透过液晶、没有荧光粉，简直就是我们继续要找的这么一款用来做手机显示器的卓越材料。&lt;/p&gt;
&lt;h3 id=&quot;下篇预告&quot;&gt;&lt;a href=&quot;#下篇预告&quot; class=&quot;headerlink&quot; title=&quot;下篇预告&quot;&gt;&lt;/a&gt;下篇预告&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;AMOLED 与 PMOLED 的区别在于有没有 TFT（我并没有在开玩笑）&lt;/li&gt;
&lt;li&gt;Super AMOLED 与 OGS、InCell、OnCell&lt;/li&gt;
&lt;li&gt;拜耳阵列与 Pentile 排列的发展&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;从 LED 聊到 Super AMOLED&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="科普" scheme="http://blog.heckpsi.com/tags/%E7%A7%91%E6%99%AE/"/>
    
      <category term="Samsung" scheme="http://blog.heckpsi.com/tags/Samsung/"/>
    
      <category term="SuperAmoled" scheme="http://blog.heckpsi.com/tags/SuperAmoled/"/>
    
  </entry>
  
  <entry>
    <title>Nexus5 镜头进灰修复记</title>
    <link href="http://blog.heckpsi.com/2015/02/25/fix-nexus-5-lens/"/>
    <id>http://blog.heckpsi.com/2015/02/25/fix-nexus-5-lens/</id>
    <published>2015-02-25T10:16:02.000Z</published>
    <updated>2016-04-21T18:23:11.000Z</updated>
    
    <content type="html">&lt;p&gt;手上这台Nexus 5已经用了快要一年的时间了。大概三个月起摄像头画质出现了非常严重的问题。记得以前我们都说一个笑话：“Nexus 4的摄像头，哈哈哈哈哈哈哈哈”。 可是Nexus 5的摄像头还成啊，怎么突然画质变得这么糟糕呢。而且不是一般地糟糕，糟糕到几乎不能看的水平。我给大家上个图，大家感受一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2lcg.com1.z0.glb.clouddn.com/974_1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;就算是前置摄像头也拍不成这雾蒙蒙的一片啊！对比度和锐度严重下降，画面糊成一团。如果画面内有光源，光源甚至还能拉出好几条线出来。一开始还没注意，越用越不对劲。显然不是软件上的问题，这一定是摄像头哪里出了事啊！&lt;/p&gt;
&lt;p&gt;于是默默看了一眼摄像头，保护玻璃上全部都是灰！理论上像这种一体式的手机进灰比起以前可开后盖的难度高了不少，进一两粒也可以理解，也不会影响画质，但是这大片大片的进灰就不对了。我打开闪光灯给大家看一下进灰有多严重。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2lcg.com1.z0.glb.clouddn.com/974_2.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;显然地，为了正常使用这块摄像头，必须要进行灰尘清理了。据之前 iFixit 做的 &lt;a href=&quot;https://www.ifixit.com/Teardown/Nexus+5+Teardown/19016&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;拆机评测&lt;/a&gt;，显示只要不换屏幕，Nexus 5 的维修难度是极易的。那么我们就开始拆机维修吧。&lt;/p&gt;
&lt;p&gt;&amp;lt;img class=&amp;quot; aligncenter&amp;quot; src=&amp;quot;&lt;a href=&quot;http://7u2lcg.com1.z0.glb.clouddn.com/974_3.jpg&amp;amp;quot&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://7u2lcg.com1.z0.glb.clouddn.com/974_3.jpg&amp;amp;quot&lt;/a&gt;; alt=&amp;quot;&amp;quot; width=&amp;quot;663&amp;quot; height=&amp;quot;441&amp;quot; /&amp;gt;&lt;/p&gt;
&lt;p&gt;我并没有用塑料片打开后盖，因为找不到那么薄的塑料片……于是我用吸盘吸起了一个卡扣，然后用指甲一点点打开了后盖。使用吸盘是一个非常好用的拆机技巧。用来拆一体式后盖设计的机器非常方便。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2lcg.com1.z0.glb.clouddn.com/974_4.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;让人非常高兴的是，Nexus 5 的 NFC 天线并没有使用“飞线”来连接，而是使用了一组弹簧触片。这使得打开后盖后安装回去不需要用电烙铁焊回去，还是比较方便的。&lt;/p&gt;
&lt;p&gt;之前有人说用电吹风热档可以加热保护玻璃膨胀，然后直接从里面顶出来。答案是：不可以。事实上这样操作加热到 70°C 左右的时候玻璃依然不会掉出来，再加热上去可能会损坏其它元件，还是别这么干了。&lt;/p&gt;
&lt;p&gt;打开后盖后发现了，Nexus 5的保护玻璃并没有安装在后盖上，并不像 锤子 T1 那样后盖一开摄像元件就暴露在外面。同时，Nexus 5 的保护玻璃也没有单独安装在摄像元件的周围那么复杂。实际上保护玻璃是和散热中间件连在了一起，所以要想把保护玻璃取下，需要拆掉上半部分的中间件。&lt;/p&gt;
&lt;p&gt;不过这时候出现了一个问题，中间件是被一个 Y字螺丝 固定住的，而并不像下方扬声器是用 十字螺丝 固定的。我手上没有Y字螺丝刀，显然拆起来还挺费劲。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2lcg.com1.z0.glb.clouddn.com/974_5.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;不过发现我手上最小的 一字螺丝刀 正好能卡住这个 Y字螺丝的一条边，但转起来还是比较容易滑牙。一个比较方便的方法是按紧螺丝刀，然后旋转手机，就可以慢慢把螺丝卸下来。6个螺丝中有三个非常紧，而另外三个却很好拆，不知道是出于什么目的还是装配的问题弄成这样的。&lt;/p&gt;
&lt;p&gt;拆下所有螺丝后，用螺丝刀伸到中间件的背后，往外轻轻撬动，把卡扣撬开，中间件就连着保护玻璃一起下来了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2lcg.com1.z0.glb.clouddn.com/974_6.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;拆下后用 气吹 分别清理摄像头元件上的细灰尘和表面玻璃背后的灰尘。清理完毕后安装回去。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2lcg.com1.z0.glb.clouddn.com/974_7.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2lcg.com1.z0.glb.clouddn.com/974_8.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;清理完后表面只能看到一些玻璃的划痕了，毕竟 Nexus 5 摄像头凸在外面，划痕不可避。把螺丝拧上背盖安装上开机完工。&lt;/p&gt;
&lt;p&gt;最后我们来看看清理灰尘前后拍出照片的对比吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2lcg.com1.z0.glb.clouddn.com/974_1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2lcg.com1.z0.glb.clouddn.com/974_9.jpg&quot; alt=&quot;&quot;&gt; &lt;/p&gt;
&lt;p&gt;画质简直感人 QuQ&lt;/p&gt;
&lt;p&gt;至此，Nexus 5的摄像头恢复了正常的使用。Nexus 5的拆解还是比较容易的，但是这种易拆解的结构也确实导致了灰尘很容易进入，如果有遇到类似问题的同学，也不妨动动手，把这不能忍受的问题解决了吧。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;手上这台Nexus 5已经用了快要一年的时间了。大概三个月起摄像头画质出现了非常严重的问题。记得以前我们都说一个笑话：“Nexus 4的摄像头，哈哈哈哈哈哈哈哈”。 可是Nexus 5的摄像头还成啊，怎么突然画质变得这么糟糕呢。而且不是一般地糟糕，糟糕到几乎不能看的水平。我给大家上个图，大家感受一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2lcg.com1.z0.glb.clouddn.com/974_1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nexus" scheme="http://blog.heckpsi.com/tags/Nexus/"/>
    
      <category term="硬件" scheme="http://blog.heckpsi.com/tags/%E7%A1%AC%E4%BB%B6/"/>
    
      <category term="维修" scheme="http://blog.heckpsi.com/tags/%E7%BB%B4%E4%BF%AE/"/>
    
  </entry>
  
  <entry>
    <title>从我能吞下玻璃而不伤身体说字体测试</title>
    <link href="http://blog.heckpsi.com/2015/02/21/how-to-test-a-font/"/>
    <id>http://blog.heckpsi.com/2015/02/21/how-to-test-a-font/</id>
    <published>2015-02-21T08:38:54.000Z</published>
    <updated>2016-04-21T16:59:45.000Z</updated>
    
    <content type="html">&lt;p&gt;许多使用Ubuntu操作系统的用户都会惊讶于Ubuntu打开一个字体文件的时候用于测试字体而显示的文字：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;我能吞下玻璃而不伤身体。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2lcg.com1.z0.glb.clouddn.com/961_1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;为什么是用这样一句句子来测试字体呢？&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;这需要联系到一个由哈佛大学学生 Ethan Mollick 创建的一个语言学项目。叫做 &lt;a href=&quot;http://en.wikipedia.org/wiki/I_Can_Eat_Glass&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;I Can Eat Glass&lt;/a&gt;。根据 Ethan Mollick 的解释，他希望让一个人到一个陌生的国家后说出某句简单易学的话，但能让别人感觉他是这个语言的母语者，从而能更尊重地对待他。这句话要有这种神奇的吓唬人的力量，几经思考之后他们选择了 “I can eat glass, but it does not hurt me.” 这句句子。（虽然我完全没有办法理解为什么这句话有这样的作用）他们将这句话翻译成了许多种语言，并制作成了网页。非常糟糕的是，这些网页在今年已经无法正常访问，好在一些好心人制作了这一网站的 &lt;a href=&quot;http://reocities.com/nodotus/hbglass.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;镜像&lt;/a&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Wo ke yi chi bo li, wo bu huei sho shang.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;写作：我可藝吃玻璃，我不毀受傷。（显然地，他们还写了许多错别字）&lt;/p&gt;
&lt;p&gt;但是他们所做的神奇之处并不是他们达到了他们一开始想要达到的目的（显然他们不能），相反地，之后哥伦比亚大学的同学在试图制作 UTF-8 编码的样例的时候想到了这个项目。众所周知，UTF-8 编码希望能通过一种编码正常显示世界上所有语言。而哈佛的这个项目恰好已经把一句话翻译成了各种各样的语言，用来做 UTF-8 编码的显示样例再好不过了。于是哥大的同学就做了这么一个 &lt;a href=&quot;http://www.columbia.edu/~fdc/utf8/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;项目&lt;/a&gt;。并优化了其中的翻译，其中简体中文的翻译被翻译成了 “我能吞下玻璃而不伤身体。”，也就是现在的样子。&lt;/p&gt;
&lt;p&gt;那为什么 Ubuntu 会选择这样一句句子作为字体测试的句子呢？目的是为了测试编码的完整性，也就是这个字体支持的语言的数量。&lt;/p&gt;
&lt;p&gt;但是这样的测试真的是好的吗？或者说是足够好的吗？我想可能并不是这样。&lt;/p&gt;
&lt;p&gt;对于西文字体而言一个完整的字形测试也就四五十个字符（包含大小写和常用符号）。一种常见的测试方法是大家在 Windows 系统上常见到的范例句子。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;The quick brown fox jumps over the lazy dog.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面这句话使用了全部的26个字母（但并不包含每个大小写）。这样的句子基本上测试了西文字体在显示英文的主要效果。但是对于中文、日文、韩文这些非字母化的重灾区，几个字可能是很难测试好一个字体的。可能你能从中看出是衬线字体还是非衬线字体、宋体还是黑体，但对于其它很多问题并不能很好的测试到。比如对于常见的偏旁部首是怎么设计的、字体覆盖多少汉字、标点符号等宽还是不等宽之类的问题几个字是比较难测试的。靠一句“我能吞下玻璃而不伤身体。”几乎是没什么用的。而 Windows 的“中国智造，慧及全球”就更扯了，完全不能理解这句话能测试出什么东西出来。&lt;/p&gt;
&lt;p&gt;Mac OS X 字体册在测试日文的时候非常巧妙。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2lcg.com1.z0.glb.clouddn.com/961_3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;测试了假名、汉字、标点符号、复杂汉字的显示效果。选用的是日本诗人 宮沢賢治 的 &lt;a href=&quot;http://www.aozora.gr.jp/cards/000081/files/1935_19925.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《ポラーノの広場》&lt;/a&gt; 的一节。不但用了一个短小的文字，而且测试了实际使用中的大多数字形的问题，可以说是解决地非常巧妙。&lt;/p&gt;
&lt;p&gt;然而对于中文的字体测试显得就差了很多。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2lcg.com1.z0.glb.clouddn.com/961_2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;选择的几个字比起 Windows 和 Ubuntu 测试了更多的偏旁部首的显示，这点虽然更好一点，但堆砌了这样一堆没有意义的文字也不很能理解是出于什么样的目的。更重要的是，竟然没有测试标点符号，反而测试了一些奇奇怪怪的中文序号。这一点不但解决地不如日文测试时那么巧妙，甚至连功能都是不够完整的。不过 Mac OS X 在测试字体是支持“自定”测试，可以输入自己需要测试的内容保存下来，还是满足了功能上的需求。&lt;/p&gt;
&lt;p&gt;其实比较下来，Ubuntu 的字体测试是最为通用的测试，能覆盖UTF-8编码下各种语言的测试，但是对于每种语言的测试却是不足够的。Mac OS X 确实对于设计者最为友好，但在中文测试的时候还是不够全面优秀。至于 Windows 嘛……&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;微软唯一的问题是没品位，他们根本的绝对的没品位。——史蒂夫·乔布斯&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;所以指望 Windows 在字体上搞出点什么还是省省吧。如果在 Windows 上对字体有比较高的要求，建议使用第三方的字体管理软件，比如 Adobe Typekit 之类的……&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;许多使用Ubuntu操作系统的用户都会惊讶于Ubuntu打开一个字体文件的时候用于测试字体而显示的文字：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;我能吞下玻璃而不伤身体。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2lcg.com1.z0.glb.clouddn.com/961_1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;为什么是用这样一句句子来测试字体呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="字体" scheme="http://blog.heckpsi.com/tags/%E5%AD%97%E4%BD%93/"/>
    
      <category term="科普" scheme="http://blog.heckpsi.com/tags/%E7%A7%91%E6%99%AE/"/>
    
  </entry>
  
  <entry>
    <title>微软全新浏览器 Spartan 背后悲伤的故事</title>
    <link href="http://blog.heckpsi.com/2015/01/23/gossip-of-spartan/"/>
    <id>http://blog.heckpsi.com/2015/01/23/gossip-of-spartan/</id>
    <published>2015-01-23T07:16:21.000Z</published>
    <updated>2016-04-21T17:31:15.000Z</updated>
    
    <content type="html">&lt;p&gt;昨天凌晨在微软的产品发布会上大家知道搭载在 Windows 10 上的默认浏览器已经从 IE 变成了 Spartan —— 一个完全全新的产品。伴随我们日日夜夜，从当年最牛的主流浏览器最后走向用来安装其他浏览器的浏览器的IE终于走到了它人生的尾声。&lt;/p&gt;
&lt;p&gt;但是就我看来，Spartan 完全不是全新的产品，它其实就是IE 12。如果把它看成全新的产品，其实 IE 11 就已经焕然一新了，只不过大家早已经都忘了它。质疑 IE 显示各种不符合 W3C 的兼容性问题和吐槽性能差的同学我想有很多，但是我想问一个问题：“IE 11 的时候，真的还有这些问题吗？”&lt;/p&gt;
&lt;p&gt;我记得去年10月的时候我讲了一个笑话：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;虽然现在微软的IE11浏览器相较之前版本已经有了很大的进步，但是用户的普遍接受度已经不高。主要是IE6之后微软对IE的放置play已经使得IE这个品牌给用户留下了一个很不好的印象。我觉得一个比较好的办法是微软换一个浏览器品牌的名字，开个发布会，说一段什么“重归创业，情怀浏览”之类的话其实就好了嘛。。。至于换什么名字逼格比较高的话。。。不如叫iE吧。。。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;万万没想到的是，它应验了，IE真的改了名。而这背后，其实隐藏了一个历史悠久却又非常悲伤的故事……&lt;/p&gt;
&lt;p&gt;&lt;del&gt;闹了半天你们不就是喜欢听故事嘛，我讲，我讲还不行嘛。&lt;/del&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;IE 是作为 Netscape 的绝对竞争对手而出现的，其目的就是为了抢占 Netscape 在浏览器市场上的份额，使得微软能自己掌控互联网的入口。等到 Netscape 退出历史舞台后基本上很难有大竞争对手了。（当时继承了 Netscape 衣钵的 Firefox 还很小众，而 Chrome 根本没出现）&lt;strong&gt;尤其是IE6之后，微软已经占据了几乎全部的市场份额，&lt;/strong&gt;已经没有更大的商业价值可以挖掘了。你现在可能认为 IE 6 是一个很烂的产品，但是那是因为你以现在的眼光在看问题。如果你以当时的眼光来看，以当时的电脑性能并和其他浏览器相比，IE6是那个时代最棒的浏览器了。IE 已经不再是微软要解决的棘手问题了，原先IE团队中的大牛也基本走得差不多，他们接下来要做的是不过是来维持这个产品的统治地位。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;入则无法家拂士，出则无敌国外患者，国恒亡。然后知生于忧患而死于安乐者也。——《孟子·告子下》&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;微软用血与泪的教训向我们验证了这句话。IE 7、IE 8 的 IE 几乎就是一个完全的消极防守的状态。却不知道，世界格局正在发生悄悄的变化。苹果与 KHTML 的矛盾激化严重，使得苹果彻底与 KHTML 决裂不再合并代码，从而开启了另一分支，这一分支就是后来的 Webkit。这个内核随着 KDE 开发者的加入逐渐壮大，而 KHTML 逐渐衰落。之后，在 2005 年左右，Webkit 宣布了全面开源，之后 Google 发布的Google Chrome 浏览器更是使用了这一内核。随着 Google 的加入，竞争进入了白热化的境地。Google 之后推出了 V8 Javascript 渲染引擎更是将浏览器速度提升到了一个新的高度。从 2009 年到 2014 年，IE 的市场份额从 70% 降低到了接近 20%。微软丢失的市场被 Chrome、Firefox、Opera、Safari 一同吃得干干净净。&lt;br&gt;同时微软不义的举动再次成为千夫所指，所谓的不义就是浏览器没有按照 W3C 的开发标准来，对开发人员设计网页造成了很大的影响。根据标准设计的网页无法在 IE 上正常显示，不得不做出修改从而使得其他按照标准来的浏览器显示出错。但是请问了，对于一个市场占用超过 70% 的浏览器而言，谁才是真正的标准？在 IE 最红火的年代，W3C 的标准更像是装饰，而当微软份额丢尽时成为了推倒 IE 大山的罪证。并且，随着 HTML5 标准的进一步完善，各家都抢先在支持 HTML5 的新特性。因为 HTML4 标准已经很久远，不能满足日常所需。网页显示个视频都要依靠 Flash，浏览器不能掌握性能的生杀大权，HTML5 标准的提出显然是被各家所支持和推荐的。&lt;br&gt;到了 IE 9 的时候，微软终于意识到了事态的严重。微软已经从一个领头者成为了落后者。于是 IE 9 开始微软重振旗鼓要搞浏览器。在 IE 9 发布时，微软也提出了要跟进 HTML5，并且展示了许多 IE 9 兼容的 HTML5 新特性。但是除了这些新特性外，旧特性依然没有按照标准在走，所以没有得到市场的肯定。到了 IE 10，微软则进一步完善了自己浏览器的渲染，使得 IE 也紧跟上了标准的步伐，以求得市场的认同。&lt;br&gt;但是 IE 10 之后，微软发现了新的问题。&lt;br&gt;大量网页依然无法在 IE 10 上良好渲染。其问题并不是 IE 10 没跟着标准走，而是网页大量调用了 Webkit 内核支持的私有功能。因为如今除了 IE 和 Firefox，市面上几乎其它所有浏览器都是 Webkit 内核的。而 Firefox 也支持了一部分 Webkit 的私有功能。跟着标准走的 IE 再次吃了大亏。其实根本没有什么标准，谁有市场的主导权，谁就是标准。如今Chrome、Safari、Opera（当时 Opera 也转投了 Webkit 阵营）都在使用的 Webkit 内核成为了真正的市场主导者。他们功能中不符合 W3C 标准的地方却丝毫没人提出。&lt;br&gt;市场不会允许一次一次再一次的失败。IE 11 在技术上已经被微软孤注一掷，其核心团队几乎都是微软最顶尖的大牛。IE 11 不但要符合了 W3C 的标准，甚至在 IE 中实现了大量 Webkit 内核中才有的私有功能，全新的 Javascript 渲染引擎，速度已经走到了大家的平均水平，在开发人员工具等细节功能上更是做得非常到位。但这一代的 IE 恰恰安排在了让人理不清操作逻辑的 Windows 8 上。这一代 Windows 是让人失望的，而 IE 则更是被人遗忘在了不知道哪个角落里。纵使 IE 11 的速度已经不再慢、兼容性不再差、甚至有些地方做得还更好，甚至和 Chrome 那一卡一顿的滚动时的帧率问题比起来，IE 的滚动已经能和 Safari 一样流畅了。但生在被命运捉弄的 Windows 8 上，生在一个已经不属于它的世界上，IE 11 已经什么都没有了。很多人连 IE 都没怎么好好用过就把 IE 当作了慢、卡、不兼容的代名词。纵使在技术上下了大工夫，却还是失败了。&lt;br&gt;既然今天的 IE 已经和昨天有了翻天覆地的变化成为了完全不同的产品，但还是已经被人下了这样的定义，那么只有一条路可以走——改名。所以搭载在 Windows 10 上的浏览器不再是 IE 而是 Spartan，至少一个新名字可以告诉别人，它真的不是原来那个样子了。&lt;/p&gt;
&lt;p&gt;不过我倒是觉得微软要做的可能不止这点。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;IE9：我错了。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;用户：知道错哪了吗？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;IE9：我应该支持更多新功能的。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;用户：还有呢？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;IE9：还有？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;用户：你果然不知道自己错哪，哼╭(╯^╰)╮&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;IE10：我错了。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;用户：知道错哪了吗？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;IE10：我应该更多兼容标准的。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;用户：还有呢？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;IE10：还有？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;用户：你果然不知道自己错哪，哼╭(╯^╰)╮&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;IE11：我错了。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;用户：知道错哪了吗？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;IE11：我应该变得更快更好用，多学学 Webkit 的特性。还要支持更多人性化的小功能。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;用户：还有呢？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;IE11：还有？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;用户：你果然不知道自己错哪，哼╭(╯^╰)╮&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;IE11：你听我解释。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;用户：我不听我不听我不听。你肯定是仗着店大欺客，哼。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;IE11：。。。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;用户：我信你一回。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;（5分钟后）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;用户：怎么提示我没 Flash？我装了啊！然后下载最新版竟然提示我只能在 Windows Update 更新！好麻烦！不用了！&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;IE11：。。。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;IE11：试图减轻用户负担预装 Flash 并集成到 Windows Update 里了，谁知 道Adobe 家几天一更新坑我。。。玩脱了。。。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;用户：果然不行，哼╭(╯^╰)╮&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其实这个才是微软急需解决的问题吧。。。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;昨天凌晨在微软的产品发布会上大家知道搭载在 Windows 10 上的默认浏览器已经从 IE 变成了 Spartan —— 一个完全全新的产品。伴随我们日日夜夜，从当年最牛的主流浏览器最后走向用来安装其他浏览器的浏览器的IE终于走到了它人生的尾声。&lt;/p&gt;
&lt;p&gt;但是就我看来，Spartan 完全不是全新的产品，它其实就是IE 12。如果把它看成全新的产品，其实 IE 11 就已经焕然一新了，只不过大家早已经都忘了它。质疑 IE 显示各种不符合 W3C 的兼容性问题和吐槽性能差的同学我想有很多，但是我想问一个问题：“IE 11 的时候，真的还有这些问题吗？”&lt;/p&gt;
&lt;p&gt;我记得去年10月的时候我讲了一个笑话：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;虽然现在微软的IE11浏览器相较之前版本已经有了很大的进步，但是用户的普遍接受度已经不高。主要是IE6之后微软对IE的放置play已经使得IE这个品牌给用户留下了一个很不好的印象。我觉得一个比较好的办法是微软换一个浏览器品牌的名字，开个发布会，说一段什么“重归创业，情怀浏览”之类的话其实就好了嘛。。。至于换什么名字逼格比较高的话。。。不如叫iE吧。。。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;万万没想到的是，它应验了，IE真的改了名。而这背后，其实隐藏了一个历史悠久却又非常悲伤的故事……&lt;/p&gt;
&lt;p&gt;&lt;del&gt;闹了半天你们不就是喜欢听故事嘛，我讲，我讲还不行嘛。&lt;/del&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Microsoft" scheme="http://blog.heckpsi.com/tags/Microsoft/"/>
    
      <category term="Spartan" scheme="http://blog.heckpsi.com/tags/Spartan/"/>
    
      <category term="Edge" scheme="http://blog.heckpsi.com/tags/Edge/"/>
    
      <category term="浏览器" scheme="http://blog.heckpsi.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HeckPsi Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.heckpsi.com/"/>
  <updated>2017-01-18T17:33:01.000Z</updated>
  <id>http://blog.heckpsi.com/</id>
  
  <author>
    <name>上海骇咕赛信息科技有限公司</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于完全听不懂 Ruby 元编程在说什么的事（零）</title>
    <link href="http://blog.heckpsi.com/2017/01/07/ruby-meta-programming_0/"/>
    <id>http://blog.heckpsi.com/2017/01/07/ruby-meta-programming_0/</id>
    <published>2017-01-07T14:45:00.000Z</published>
    <updated>2017-01-18T17:33:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="元-meta-是什么？"><a href="#元-meta-是什么？" class="headerlink" title="元 (meta-) 是什么？"></a>元 (meta-) 是什么？</h2><p>很难用一个中文的词汇来概括英文中 meta- 词缀的含义。如果我们去找这个词缀词语的翻译的话，也很难找到究竟是什么时候，开始将这一类词翻译成「元XX」的。但我们可以看到的是，这一类词通常都很难翻译，比如说 physics 物理，metaphysics 形而上学；morphological 形态的 metamorphosis 质变。</p>
<p>对于这个词，我认为有个非常有趣的英语翻译，是捷克小说家卡夫卡的著名小说《Die Verwandlung》（变形记）的英语翻译《The Metamorphosis》。因为德语 Verwandlung 本身更接近于 change, transformation 的意思，而 metamorphosis 更突出了变化的彻底性，更体现了主人公格里高尔变成跳蚤之后个人、家人、社会对他的全面变化。</p>
<p>meta- 这个词缀更类似于关于 x 的 x 的这么一种感觉。比如 metaphysics 在讨论的是事物原理本身的原理，metamorphosis 讨论的是变化导致的根本变化。meta- 这个词缀源于希腊语前缀 μετά，意思是 “之后”、“之外”、“之上”、“之间”。中国大陆一般将这个词缀的词翻译成「元」，而台湾地区通常翻译成「後設」或「超」。</p>
<p>在讨论元编程之前，我们不如先讨论一下，元概念是如何被用于其它创作性工作的，这样我们可以更好理解元编程，以及如何将元编程用于编程工作之中。</p>
<a id="more"></a>
<h2 id="将元用于文学性创作"><a href="#将元用于文学性创作" class="headerlink" title="将元用于文学性创作"></a>将元用于文学性创作</h2><p>塞万提斯的《堂吉诃德》通常被认为是最早的元小说之一。故事发生在已经没有骑士的年代，主角堂吉诃德幻想自己是一个骑士。这种在小说作品中创作的形式就可以被认为是元小说。更严格的元小说通常是故事中的作家创造另一个故事或故事中的读者阅读一本书，比如《苏菲的世界》。</p>
<p>现代和后现代时期的元小说产生的一大特点是，故事主角对自己是故事的一部分这样的概念具有意识。这一类作品的特点也很大影响了其它类型作品，包括元电影和元游戏。</p>
<p>可交互性更是使得这种自我意识觉醒题材的元创作有了更多的创作型。比如著名独立游戏《史丹利的寓言》(The Stanley Parable) 就以玩家与旁白之间的听从与对抗作为手段，试图讨论游戏本质和玩家自我意识的概念。</p>
<h2 id="将元用于理学性创作"><a href="#将元用于理学性创作" class="headerlink" title="将元用于理学性创作"></a>将元用于理学性创作</h2><p>如果说当你将元用于文学性创作时，你是有意识地进行着元创作；当你将元用于理学性/科学性的创作的时候，你通常是无意识的。就好像相声中的传统段子《捧逗争哏》，就可以称之为元相声，只不过是没有人这么叫而已。</p>
<p>大学数学中有一门有关形式语言的课程叫范畴论。其实就是用抽象的方法来处理数学概念也可以称之为元数学。在计算机科学中，元概念的应用其实极其普遍，以至于我们其实在日常开发中无数次使用过。</p>
<p>当我们现在有一个 HTTP 服务器，用户访问服务器通常都会返回一个网页。但我们有时需要返回的是一个给用户下载的文件，在这种情况下，浏览器需要不同的方式来处理这是个网页还是文件。最常见的就是我们会通过 HTTP/1.1 的 Headers 中的 Content-Type 来定义浏览器应该如何处理收到的数据。而这些 Headers 定义了数据本身，作为一种描述数据的数据，我们就可以称之为元数据。</p>
<p>当你设计了一门编程语言，你需要为它实现一个编译器。而编译器的一开始，你需要做一个语法分析器 (parser)。由于一门编程语言的语法通常非常复杂，手动定义其中的关系有时不那么方便，于是很多时候我们会有类似于 yacc 之类的编译器编译程序 (compiler-compiler) 来生成。通常这样的程序会允许输入一个巴科斯范式 (BNF) 作为语法定义，而巴科斯范式本身就可以被认为是一种元编程，你在通过编程实现编程。</p>
<h2 id="Ruby-元编程"><a href="#Ruby-元编程" class="headerlink" title="Ruby 元编程"></a>Ruby 元编程</h2><p>我们通常把 Ruby 元编程单独拿出来说是因为 Ruby 可以通过编程修改 Ruby 语言自己。事实上，有这种能力的不止 Ruby 本身。且不论 Lisp 的各类方言，当年 C++ 模板元编程技术就够大家喝一大壶。如果说 Ruby 元编程被 Rubyist 经常单独出来说的原因是，我们可以通过元编程，不仅仅是给语言「增加」能力，或者是在 Ruby 上开发一个「DSL」，更多的是依靠 Ruby 本身丰富的语法糖设计，带来更好的编程范式和灵活性。</p>
<p>但 Ruby 元编程并非是一个有益而无害的东西，错误地使用元编程会给代码可读性和程序性能带来灾难性的后果。这一系列的文章将通过介绍 Ruby 元编程来达成以下目的：</p>
<ul>
<li>介绍 Ruby 元编程方法</li>
<li>介绍 Ruby 元编程陷阱</li>
<li>介绍 Ruby 元编程原理</li>
<li>相关方法在 YARV 中实现的变化</li>
<li>认为 Ruby 不再是魔法</li>
<li>能找到使用元编程技巧的正确场合</li>
<li>比较 Ruby 和其他语言的元编程实现</li>
</ul>
<p>写这些文章之前我反复读了《Ruby 元编程》和《Ruby 原理剖析》这两本书，结合我自己 Ruby 开发的经验和实例，在这系列文章中，将会由浅入深地从方法介绍深入到实现细节，更系统地就元编程问题进行讨论。</p>
<p>本系列文章采取月更，连载长度约为十二个月，每个月的内容大约 1500-3000 字之间。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;元-meta-是什么？&quot;&gt;&lt;a href=&quot;#元-meta-是什么？&quot; class=&quot;headerlink&quot; title=&quot;元 (meta-) 是什么？&quot;&gt;&lt;/a&gt;元 (meta-) 是什么？&lt;/h2&gt;&lt;p&gt;很难用一个中文的词汇来概括英文中 meta- 词缀的含义。如果我们去找这个词缀词语的翻译的话，也很难找到究竟是什么时候，开始将这一类词翻译成「元XX」的。但我们可以看到的是，这一类词通常都很难翻译，比如说 physics 物理，metaphysics 形而上学；morphological 形态的 metamorphosis 质变。&lt;/p&gt;
&lt;p&gt;对于这个词，我认为有个非常有趣的英语翻译，是捷克小说家卡夫卡的著名小说《Die Verwandlung》（变形记）的英语翻译《The Metamorphosis》。因为德语 Verwandlung 本身更接近于 change, transformation 的意思，而 metamorphosis 更突出了变化的彻底性，更体现了主人公格里高尔变成跳蚤之后个人、家人、社会对他的全面变化。&lt;/p&gt;
&lt;p&gt;meta- 这个词缀更类似于关于 x 的 x 的这么一种感觉。比如 metaphysics 在讨论的是事物原理本身的原理，metamorphosis 讨论的是变化导致的根本变化。meta- 这个词缀源于希腊语前缀 μετά，意思是 “之后”、“之外”、“之上”、“之间”。中国大陆一般将这个词缀的词翻译成「元」，而台湾地区通常翻译成「後設」或「超」。&lt;/p&gt;
&lt;p&gt;在讨论元编程之前，我们不如先讨论一下，元概念是如何被用于其它创作性工作的，这样我们可以更好理解元编程，以及如何将元编程用于编程工作之中。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Ruby" scheme="http://blog.heckpsi.com/tags/Ruby/"/>
    
      <category term="元编程" scheme="http://blog.heckpsi.com/tags/%E5%85%83%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>em-midori 100 天记</title>
    <link href="http://blog.heckpsi.com/2016/12/15/em-midori-100-days/"/>
    <id>http://blog.heckpsi.com/2016/12/15/em-midori-100-days/</id>
    <published>2016-12-15T15:58:04.000Z</published>
    <updated>2016-12-16T15:35:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上次在 40 天的时候介绍了一些<a href="https://ruby-china.org/topics/31358" target="_blank" rel="external">人生的经验</a>，做了些<a href="https://ruby-china.org/topics/31421" target="_blank" rel="external">微小的贡献</a>。一个人的命运啊，当然要靠自我奋斗，但是也要考虑到历史的进程，我绝对不知道我刚写了能跑 Hello World 的程序怎么把我选到 GitHub Trending 去了。这之后就莫名其妙上了 Ruby Weekly，还被 Matsumoto 桑给 retweet 了。然而上次那篇文章用的是中文写的，这直接导致一些不明真相的外国友人进行了<a href="https://www.reddit.com/r/ruby/comments/58kaqe/em_midori_lightweight_flexible_and_fast/" target="_blank" rel="external">迷之看空</a>的讨论。</p>
<p>不过在之后 60 天里，这个项目的 API 逐渐完善，对于原先很多的问题逐渐都在修正。我已经开始使用 em-midori 开发逻辑复杂的业务的尝试，并且目前进展非常顺利。在这 100 天之际，将 em-midori 的设计思路更好得整理一下，来仔细说说 em-midori 在解决什么问题，以及怎么解决。</p>
<a id="more"></a>
<h2 id="异步的思考"><a href="#异步的思考" class="headerlink" title="异步的思考"></a>异步的思考</h2><h3 id="瘾君子-JavaScript"><a href="#瘾君子-JavaScript" class="headerlink" title="瘾君子 JavaScript"></a>瘾君子 JavaScript</h3><p>JavaScript 不是所有语言中最早做异步的，但却是近年来非常引人瞩目的一个。这是因为，在并不十分快的 V8 虚拟机上，JavaScript 在主流解释型动态类型语言网络后端对比中，达到了不俗的性能表现。一般认为这是由 Node 纯异步设计带来的性能优势，然而事实上真的如此吗？</p>
<p>随手拿一段 Node 的代码，比如 <a href="https://github.com/nodejs/node-v0.x-archive/blob/842eaf4/src/http.js#L303" target="_blank" rel="external">http-parser</a> 的 JavaScript 示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">connection.addListener(<span class="string">"headers_complete"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">info</span>) </span>&#123;</div><div class="line">  incoming.httpVersion = info.httpVersion;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (info.method) &#123;</div><div class="line">    <span class="comment">// server only</span></div><div class="line">    incoming.method = info.method; </div><div class="line">    incoming.uri = node.http.parseUri(incoming.uri); <span class="comment">// TODO parse the URI lazily?</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// client only</span></div><div class="line">    incoming.statusCode = info.statusCode; </div><div class="line">  &#125;</div><div class="line"></div><div class="line">  stream.emit(<span class="string">"incoming"</span>, [incoming, info.should_keep_alive]);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">connection.addListener(<span class="string">"body"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</div><div class="line">  incoming.emit(<span class="string">"body"</span>, [chunk]);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">connection.addListener(<span class="string">"message_complete"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  incoming.emit(<span class="string">"complete"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>通过三个 <code>Listener</code> 来完成的 http parse 工作显然是异步的，画成流程应该是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">+-----------------+     callback     +----------------------------+</div><div class="line">|   parse header  | +--------------&gt; | req.header = parser.header |</div><div class="line">+-----------------+                  +----------------------------+</div><div class="line"></div><div class="line">+-----------------+     callback     +----------------------------+</div><div class="line">|   parse body    | +--------------&gt; | req.body.push(chunk)       |</div><div class="line">+-----------------+                  +----------------------------+</div><div class="line"></div><div class="line">+-----------------+     callback     +----------------------------+</div><div class="line">|   complete      | +--------------&gt; | ...                        |</div><div class="line">+-----------------+                  +----------------------------+</div></pre></td></tr></table></figure>
<p>然而事实上这整个异步都是假的，是特技的魔法。因为它的执行只有一种可能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">+-----------------+                  +----------------------------+</div><div class="line">|   parse header  | +--------------&gt; | req.header = parser.header |</div><div class="line">+-----------------+                  +---------------+------------+</div><div class="line">                                                     |</div><div class="line">         +-------------------------------------------+</div><div class="line">         |</div><div class="line">+--------v--------+                  +----------------------------+</div><div class="line">|   parse body    | +--------------&gt; | req.body.push(chunk)       |</div><div class="line">+---+-------------+                  +---------------+------------+</div><div class="line">    ^                                                |</div><div class="line">   N|    +-------------------------------------------+</div><div class="line">    |    |</div><div class="line">+---+----v--------+        Y         +----------------------------+</div><div class="line">|   complete?     | +--------------&gt; | ...                        |</div><div class="line">+-----------------+                  +----------------------------+</div></pre></td></tr></table></figure>
<p>如果你觉得这图有点晕，不如我们换个方向来看这个图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">     +-----------------+</div><div class="line">     |   parse header  |</div><div class="line">     +--------+--------+</div><div class="line">              |</div><div class="line">+-------------v--------------+</div><div class="line">| req.header = parser.header |</div><div class="line">+-------------+--------------+</div><div class="line">              |</div><div class="line">     +--------v--------+</div><div class="line">     |   parse body    |</div><div class="line">     +--------+--------+</div><div class="line">              |</div><div class="line">+-------------v--------------+</div><div class="line">| req.body.push(chunk)       &lt;---+</div><div class="line">+-------------+--------------+   |</div><div class="line">              |                  | N</div><div class="line">      +-------v---------+        |</div><div class="line">      |   complete?     +--------+</div><div class="line">      +-------+---------+</div></pre></td></tr></table></figure>
<p>这就算现在找个没怎么学过编程的学生来，也看得出这东西就是个依次运行的同步流程了吧。因为这几步之间是有关系的。如果 header 没处理完，你连 body 在哪都还没找到，怎么可能能异步呢？Node 的许多地方都是 <strong>语义异步，运行同步</strong> 的。之所以要这么做很大程度上是为了贯彻 Node 纯异步的本身，希望编程者把思路完全变成异步的思路。如果说想上面这个例子中，同步和异步并不存在运行上的差异，那么影响运行效率的到底是什么呢？</p>
<p>说到底是 <strong>阻塞</strong> 在作怪。 </p>
<p>如果一个核心一个线程一次只能正在处理一个队列的任务，每个任务耗时需要 1s 完成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">+---+  +---+  +---+  +---+  +---+</div><div class="line">|   |  |   |  |   |  |   |  |   |</div><div class="line">| 1 |  | 2 |  | 3 |  | 4 |  | 5 |</div><div class="line">|   |  |   |  |   |  |   |  |   |</div><div class="line">+---+  +---+  +---+  +---+  +---+</div><div class="line"></div><div class="line">+-------------------------------&gt;</div></pre></td></tr></table></figure>
<p>那么这个任务必然需要 5s 才能完成，无论这其中这几个任务如何排列顺序。异步在这种情况下不会带来任何性能上的好处。真正的好处出现在下面的图里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">+---+        +---+  +---+  +---+  +---+</div><div class="line">|   |        |   |  |   |  |   |  |   |</div><div class="line">| 1 |        | 1 |  | 2 |  | 3 |  | 4 |</div><div class="line">|   |        |   |  |   |  |   |  |   |</div><div class="line">+---+        +---+  +---+  +---+  +---+</div><div class="line"></div><div class="line">+-------------------------------------&gt;</div></pre></td></tr></table></figure>
<p>1 号任务处理了一半休眠了 1 秒，不处理任何东西，只是白白贡献了自己的 1 秒。如果我们的程序时异步的。那么 1 号任务可以让出处理权，先让 2 3 4 处理。而这种情况除非是有意的 <code>sleep</code> 操作，通常都是由于 <strong>I/O 阻塞</strong> 造成的，也就是处理了一半，正在等待一个网络请求或文件读写完成才能继续处理的这种情况。所以 Node 与其说是异步，不如说是由异步产生了一个无阻塞的网络框架产生的性能提升。</p>
<h3 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a>回调地狱</h3><p>那么说清楚了上面这个问题，我们就来说说，我们都不想这么写的原因：回调地狱 (callback hell)。如果我们在网上搜索一下，我想可以看到无数有关的段子。</p>
<p><img src="http://cdn.heckpsi.com/midori_3.png" alt="回调地狱"></p>
<p>然而事实上，在 Node 自己的样例中我们很少看到这种糟糕的代码，这种代码更多的是出现在我们的业务中。因为业务的实现主要就是 CRUD，而这些操作的明显特点就是每个业务都存在其自己内在的逻辑关系，有其自己的执行顺序，即使抽象也很难复用。而业务 API 通常都有着及时的反馈，这使得我们一定是：</p>
<ol>
<li>读入请求</li>
<li>解析请求</li>
<li>检查合法性</li>
<li>操作数据库</li>
<li>返回结果</li>
</ol>
<p>这四个操作的顺序不能颠倒的，但问题在于读入请求、操作数据库、返回结果都涉及 I/O 操作，确实将这几步通过回调异步可以有效避免阻塞提高性能。如果你的数据库操作复杂，涉及多次数据库操作，那么这个回调地狱自然而然就产生了。伪代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">connection.on(<span class="string">'received'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">  DB.query(<span class="string">'SELECT * FROM A WHERE x='</span> + data[<span class="string">'test'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</div><div class="line">    DB.query(<span class="string">'SELECT * FROM B WHERE x'</span> + data[<span class="string">'test2'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">result2</span>)</span>&#123;</div><div class="line">      connection.response(result + result2, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">        <span class="comment">// Response failed</span></div><div class="line">      &#125;)</div><div class="line">    &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">      <span class="comment">// DB query failed at query 2</span></div><div class="line">    &#125;))</div><div class="line">  &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="comment">// DB query failed at query 1</span></div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>显然，这种混乱的代码是 Node 工程师的日常。但是，回调地狱真的是不可避免的吗？事实上，暴露在业务中的 I/O 大多是有逻辑关联的，一旦有回调，就会回调地狱。但只要我们能把 CPU idle 率降到 0，避免掉所有的阻塞，我们的目的就已经达成，回调并不是异步必须要有的。</p>
<p>为了更好地解决问题，我们现在不妨忽略所有的细节，忘记业务本身，就看看回调地狱的形状长得像啥？</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(</div><div class="line">  (</div><div class="line">    (</div><div class="line">      ()</div><div class="line">    )</div><div class="line">  )</div><div class="line">)</div></pre></td></tr></table></figure>
<p>这种括号组成的语法关系是不是让人有一种：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="name">on</span> connection 'received (<span class="name">lambda</span> (<span class="name">data</span>)</div><div class="line">  (<span class="name">query</span> DB (<span class="name">format</span> <span class="literal">nil</span> <span class="string">"SELECT * FROM A WHERE x=~A"</span> (<span class="name">data</span> 'test)) (<span class="name">lambda</span> (<span class="name">result</span>) </div><div class="line">    (<span class="name">query</span> DB (<span class="name">format</span> <span class="literal">nil</span> <span class="string">"SELECT * FROM B WHERE x=~A"</span> (<span class="name">data</span> 'test2)) (<span class="name">lambda</span> (<span class="name">result2</span>) </div><div class="line">      (<span class="name">response</span> connection (<span class="name">+</span> result result2))</div><div class="line">    ) (<span class="name">lambda</span> (<span class="name">err2</span>) ())</div><div class="line">  )) (<span class="name">lambda</span> (<span class="name">err</span>) ())</div><div class="line">)))</div></pre></td></tr></table></figure>
<p>的错觉。这个错觉并没有错，JavaScript 可以说就是披着 C 语言外衣的 Lisp。它除了长得像 C 语法以外都和 Lisp 比较像。那么 Lisp 的括号嵌套是什么关系？本质上是栈的关系。所以一系列的回调本质是栈吗？稍有一些区别。回调被调用之时就是入栈之时，然而回调执行完并不是出栈之时，因为栈底的东西已经被执行完了。但如果我们更近一步，假设栈底什么都没有的话，那么我们就已经找到了一种非常基础的数据结构来描述这一行为的本质，这东西更像是一个 <strong>队列</strong>，每次回调只是在告诉队列，你可以处理下一项了。</p>
<p>也就是说，每个请求的处理都是一个队列，每个 I/O 操作都是队列中的一项，当这个队列被运行完了，这个请求就被处理完了。它和原先同步的代码比起来的唯一区别是，同步代码可以被认为这个队列是依次接连执行的，而现在队列中的每一项只在它可以执行的时候再执行，否则，我可以去执行其他队列里的东西，把 CPU 的 Idle 吃完，就能达到很好的性能。</p>
<h3 id="已有的尝试"><a href="#已有的尝试" class="headerlink" title="已有的尝试"></a>已有的尝试</h3><p>事实上在比如 Thin 或者 Puma 之类的 Web 服务器中都已经使用 EventMachine 实现了一部分的异步，也就是将网络的 I/O，读取请求和写回返回部分写了非阻塞的写法。所以如果你跑一个 Hello World 服务器，那么其实性能并不太差。</p>
<p>比如最简单的 sinatra 例子</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">require</span> <span class="string">'sinatra'</span></div><div class="line">get <span class="string">'/'</span> <span class="keyword">do</span></div><div class="line">  <span class="string">'Hello World'</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>如果用 Thin 来跑的话，一个核心大概有 2500+ req/s 的性能，如果再拿掉一些中间件，还能更快。即使和 Node 有一些差距，但是这种差距是线性的，并不是什么显著的问题。</p>
<p>只不过阻塞问题有个巨大的特点，那就是一处阻塞。Ruby 中常用的数据库连接、文件 IO 都是一些阻塞模型。一旦涉及数据库，Sinatra on Thin 的性能就会显著下滑。本质上来说，这件事情毫无道理，因为数据库的运算和 Web 框架无关，之和数据库程序有关。但由于 Web 程序一直在等待数据库返回而不去处理手上的事物了，这才导致了性能上的下滑。</p>
<p>要想彻底解决阻塞的问题，要把每一个 I/O 操作都变成非阻塞的才行。</p>
<h3 id="小绿的异步"><a href="#小绿的异步" class="headerlink" title="小绿的异步"></a>小绿的异步</h3><p>em-midori 与其说是一个异步的 Web 框架，不如说是提供了一系列无回调非阻塞 I/O 的工具集合。em-midori 利用 Fiber 存储当前作用域和让步/恢复的特性来处理刚刚我们所说的 <strong>队列</strong> 的特征。每个 I/O 操作都会被看作队列的一项，一旦被执行，它就会保存自己当前作用域下变量，然后让出自己的处理权让系统处理其它任务，而等 I/O 完毕后再恢复这个代码的继续运行。比如：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">require</span> <span class="string">'em-midori'</span></div><div class="line"><span class="keyword">require</span> <span class="string">'json'</span></div><div class="line"><span class="keyword">require</span> <span class="string">'em-midori/extension/file'</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Route</span> &lt; Midori::Route</span></div><div class="line">  get <span class="string">'/'</span> <span class="keyword">do</span></div><div class="line">    file = Midori::File.read(<span class="string">'./hello.txt'</span>)</div><div class="line">    &#123;<span class="symbol">text:</span> file&#125;.to_json</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line">Midori::Runner.new(Route).start</div></pre></td></tr></table></figure>
<p>当请求进来后，运行到</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Midori::File.read(<span class="string">'./hello.txt'</span>)</div></pre></td></tr></table></figure>
<p>这里时，程序就会让出自己的处理权，直到文件读取完，它会继续完成赋值</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">file = ...</div></pre></td></tr></table></figure>
<p>然后把整个 API 的接下来内容跑完。在业务代码中不会出现一行回调，但已经完成了所有的非阻塞的封装。</p>
<h2 id="API-设计"><a href="#API-设计" class="headerlink" title="API 设计"></a>API 设计</h2><h3 id="为什么不-await？"><a href="#为什么不-await？" class="headerlink" title="为什么不 await？"></a>为什么不 await？</h3><p>事实上，虽然出发点不同，但是从语义上看，这和 C# 中 <code>await</code> 的语义是非常接近的。意识到问题的 ECMAScript 7 标准中，也加入了类似的 <code>await</code> 语义。我非常支持 <code>await</code> 语义，并且 em-midori 内也提供了 <code>await</code> 语法的封装，但是我并不打算将其作为一个可以直接使用的 API 来看，而是各个驱动程序封装的工具。</p>
<p>因为当我们在使用 <strong>Web 框架</strong> 而不是在 <strong>造轮子</strong> 的时候，我们更关心的其实是业务。而一个业务处理的逻辑本身就是耦合的，是最小不可分的。使用 <code>await</code> 应该是默认的，而不是需要手动加入的。否则充斥 <code>await</code> 的语法并不是一个 <strong>Web DSL</strong> 该有的东西。</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>上述设计在实现时有个非常 tricky 的一点，就是异常处理。由于启动 Fiber 来处理异步的程序，在里面抛出的异常无法被外面的 <code>begin</code> <code>end</code> 语法捕获。而这一语法又恰恰只实现了程序的正确回调，却没有实现异常回调。为了弥补这一问题，<code>em-midori</code> 会自动捕获 Fiber 代码块中的一切异常，并遇到后在异常回调中抛出。开发者就可以正常使用 <code>begin</code> <code>end</code>  语法来捕获异常了。</p>
<p>同时，<code>em-midori</code> 还支持通过 <code>capture</code> 语法来定义全局错误处理，以更好处理一些常规错误例如 404, 500 等的通用处理返回。形如：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">require</span> <span class="string">'em-midori'</span></div><div class="line"><span class="keyword">require</span> <span class="string">'json'</span></div><div class="line"><span class="keyword">require</span> <span class="string">'em-midori/extension/file'</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Route</span> &lt; Midori::Route</span></div><div class="line">  get <span class="string">'/'</span> <span class="keyword">do</span></div><div class="line">    <span class="keyword">begin</span></div><div class="line">      file = Midori::File.read(<span class="string">'./hello.txt'</span>)</div><div class="line">      &#123;<span class="symbol">text:</span> file&#125;.to_json</div><div class="line">    <span class="keyword">rescue</span> Errno::ENOENT =&gt; _e</div><div class="line">      Midori::Response(<span class="number">404</span>,</div><div class="line">        &#123;&#125;,</div><div class="line">        &#123;<span class="symbol">err:</span><span class="string">'File not found'</span>&#125;.to_json)</div><div class="line">    <span class="keyword">rescue</span> =&gt; e</div><div class="line">      Midori::Response(<span class="number">500</span>,</div><div class="line">        &#123;&#125;,</div><div class="line">        &#123;<span class="symbol">err:</span> <span class="string">'Internal Server Error'</span>, <span class="symbol">detail:</span> e.traceback&#125;.to_json)</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line">Midori::Runner.new(Route).start</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">require</span> <span class="string">'em-midori'</span></div><div class="line"><span class="keyword">require</span> <span class="string">'json'</span></div><div class="line"><span class="keyword">require</span> <span class="string">'em-midori/extension/file'</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Route</span> &lt; Midori::Route</span></div><div class="line">  capture StandardError <span class="keyword">do</span> <span class="params">|e|</span></div><div class="line">    Midori::Response(<span class="number">500</span>,</div><div class="line">      &#123;&#125;,</div><div class="line">      &#123;<span class="symbol">err:</span> <span class="string">'Internal Server Error'</span>, <span class="symbol">detail:</span> e.traceback&#125;.to_json)</div><div class="line">  <span class="keyword">end</span></div><div class="line">  capture Errno::ENOENT <span class="keyword">do</span></div><div class="line">    Midori::Response(<span class="number">404</span>,</div><div class="line">      &#123;&#125;,</div><div class="line">      &#123;<span class="symbol">err:</span> <span class="string">'File not found'</span>&#125;.to_json)</div><div class="line">  <span class="keyword">end</span></div><div class="line">  get <span class="string">'/'</span> <span class="keyword">do</span></div><div class="line">    file = Midori::File.read(<span class="string">'./hello.txt'</span>)</div><div class="line">    &#123;<span class="symbol">text:</span> file&#125;.to_json</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line">Midori::Runner.new(Route).start</div></pre></td></tr></table></figure>
<h3 id="路由挂载"><a href="#路由挂载" class="headerlink" title="路由挂载"></a>路由挂载</h3><p><code>em-midori</code> 被设计成一个面向实际 Web 业务开发的框架，自然不是一个简单的轮子游戏，它为工程化的抽象做了不少考虑。比如支持 <code>mount</code> 来将一整个路由定义挂载到主路由上。</p>
<p>语法：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &lt; Midori::Route</span></div><div class="line">  get <span class="string">'/'</span> <span class="keyword">do</span></div><div class="line">    <span class="string">'Hello'</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &lt; Midori::Route</span></div><div class="line">  get <span class="string">'/'</span> <span class="keyword">do</span></div><div class="line">    <span class="string">'World'</span></div><div class="line">  <span class="keyword">end</span></div><div class="line">  mount <span class="string">'/a'</span>, A</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">Midori::Runner.new(B).start</div><div class="line"><span class="comment"># / =&gt; 'World'</span></div><div class="line"><span class="comment"># /a/ =&gt; 'Hello'</span></div></pre></td></tr></table></figure>
<p>事实上，这个路由挂载并不是一个栈递归调用，而是在初始化时通过一个深度优先搜索算法遍历，建立出整个中间件调用链。尽可能减少运行时的性能消耗，是个非常实用的设计。</p>
<h2 id="现有进度和未来路线"><a href="#现有进度和未来路线" class="headerlink" title="现有进度和未来路线"></a>现有进度和未来路线</h2><p><code>em-midori</code> 现在已经是一个勉强可用的状态。除了框架本身，简易的文件 I/O、Postgres 驱动、Sequel ORM 都已经被实现好。我已经开始着手使用这一框架用于生产，并已经有一些好的结果。并通过实际项目的建设也修复了不少不易察觉的 bug。</p>
<p>就目前的版本来说 <code>em-midori</code> 虽然较上次增加了很多功能，但性能和仍然能比 <code>sinatra</code> 快一倍以上，比 <code>rails 5 api mode</code> 快大约 6 倍。和 Node.js 上的 <code>express</code> 框架比较，性能不分上下，取决于具体运行机器。</p>
<p>不过，这个版本距离生产就绪的版本还有不少距离。从可用角度上来说，项目的测试覆盖率已达到 100%，但很多边缘情况都没有得到妥善的测试。在接下来的几个月需要更好的测试这一框架。</p>
<p>从学习角度来说，<code>em-midori</code> 还需要完善各方面的文档，补充 Tutorial 和 Guidelines 才能被其他人使用。并不可能让大家边读源代码边写业务。</p>
<p>在样例上，我选择了论坛项目作为一个官方 example，项目将作为 Tutorial 的一部分，给大家演示实际使用框架用于业务开发的各种细节。这些内容也会在 v1.0 版本前就绪。</p>
<p>从功能上来说，<code>em-midori</code> 抛弃了 Rack 作为 Web 接口，很大程度是我希望在接下来版本中加入完整的 HTTP/2 支持。但这也导致了需要重复造很多轮子，比如 rack-test 之类的配套功能。</p>
<p>时间上，我希望生产版本能在明年 3 月前发布。考虑到目前路线图的进度，开发进度仍领先于设定好的时间，所以我还是有不少把我做好这件事的。</p>
<p>最后祝大家写 Ruby 都能写得开心，写得愉快！</p>
<blockquote>
<p>Ruby is designed to make programmers happy.</p>
<p>–Yukihiro Matsumoto</p>
</blockquote>
<p><img src="http://cdn.heckpsi.com/midori_2.jpg" alt="If you are not happy"></p>
<p>项目地址：<a href="https://github.com/heckpsi-lab/em-midori" target="_blank" rel="external">em-midori</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上次在 40 天的时候介绍了一些&lt;a href=&quot;https://ruby-china.org/topics/31358&quot;&gt;人生的经验&lt;/a&gt;，做了些&lt;a href=&quot;https://ruby-china.org/topics/31421&quot;&gt;微小的贡献&lt;/a&gt;。一个人的命运啊，当然要靠自我奋斗，但是也要考虑到历史的进程，我绝对不知道我刚写了能跑 Hello World 的程序怎么把我选到 GitHub Trending 去了。这之后就莫名其妙上了 Ruby Weekly，还被 Matsumoto 桑给 retweet 了。然而上次那篇文章用的是中文写的，这直接导致一些不明真相的外国友人进行了&lt;a href=&quot;https://www.reddit.com/r/ruby/comments/58kaqe/em_midori_lightweight_flexible_and_fast/&quot;&gt;迷之看空&lt;/a&gt;的讨论。&lt;/p&gt;
&lt;p&gt;不过在之后 60 天里，这个项目的 API 逐渐完善，对于原先很多的问题逐渐都在修正。我已经开始使用 em-midori 开发逻辑复杂的业务的尝试，并且目前进展非常顺利。在这 100 天之际，将 em-midori 的设计思路更好得整理一下，来仔细说说 em-midori 在解决什么问题，以及怎么解决。&lt;/p&gt;
    
    </summary>
    
    
      <category term="开源" scheme="http://blog.heckpsi.com/tags/%E5%BC%80%E6%BA%90/"/>
    
      <category term="Ruby" scheme="http://blog.heckpsi.com/tags/Ruby/"/>
    
  </entry>
  
  <entry>
    <title>关于 eval 是否 evil 的一些想法</title>
    <link href="http://blog.heckpsi.com/2016/10/29/is-eval-evil/"/>
    <id>http://blog.heckpsi.com/2016/10/29/is-eval-evil/</id>
    <published>2016-10-28T19:53:25.000Z</published>
    <updated>2016-10-29T08:53:06.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引"><a href="#引" class="headerlink" title="引"></a>引</h3><p>对于大多数动态语言，都支持 <code>eval</code> 这个神奇的函数。这打他们太爷爷 Lisp 开始就支持这种方法。虽然写法（eg: <code>(eval &#39;(+ 1 2 3))</code> ）有稍许不同，但语义是一样的，就是说 <code>eval</code> 函数接受一个字符串类型作为参数，将其解析成语句并混合在当前作用域内运行。但我想大家也都听过这么一句话：</p>
<blockquote>
<p>eval is evil.</p>
</blockquote>
<p>但是 How evil is eval？那么既然 <code>eval</code> 如此罪恶，那么为什么它仍被那么多动态语言作为接口暴露呢？我们不妨来仔细探讨一下 <code>eval</code> 在使用中究竟会产生什么问题，在日常编程中究竟该不该使用 <code>eval</code>，如果要用，那么又该如何使用。</p>
<a id="more"></a>
<h3 id="字符串安全"><a href="#字符串安全" class="headerlink" title="字符串安全"></a>字符串安全</h3><p>说到 <code>eval</code> 第一个会被讨论的当然就是其安全性。比如说，我们现在来实现一个四则运算器：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">loop <span class="keyword">do</span></div><div class="line">  print(<span class="string">'Expression: '</span>)</div><div class="line">  puts(<span class="string">"result: <span class="subst">#&#123;eval gets.chomp&#125;</span>"</span>)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Expression: 1+1</div><div class="line">result: 2</div><div class="line">Expression: 2+2</div><div class="line">result: 4</div><div class="line">Expression: 3*4</div><div class="line">result: 12</div><div class="line">Expression: 4+(1*1)</div><div class="line">result: 6</div></pre></td></tr></table></figure>
<p>Awesome! 这段程序实现了全部四则运算的功能！只不过，这东西实现了 <strong>不止</strong> 四则运算的功能，事实上，它能处理任意 Ruby 语句，实际上这已经是一个 REPL（Read-Eval-Print Loop）了。我们可以运行一些「危险」的代码，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Expression: exit</div><div class="line">Process exit with code 0</div></pre></td></tr></table></figure>
<p>更实际的应用是，在 JavaScript 中，如果你想要支持 IE7 的话，<code>JSON.parse()</code> 是不被支持的，除非你引入一个 JSON 解析库，最方便的写法就是 <code>eval(json)</code>，因为毕竟 JSON 也是合法的 JavaScript 语句，这样的方法安全性问题是显然的。</p>
<p>这样的问题不止 <code>eval</code> 有，事实上，所有和字符串打交道的事情，或多或少都有类似的问题。比如「SQL 注入」说到底也就是这么一回事。再比如你在 Ruby 代码中试图操作 <code>git</code> 命令的时候，如果你使用反引号，也可能遇到这样的问题。</p>
<p>不过我们来看下面这个例子：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># gems/rest-client-1.6.7/bin/restclient 摘自《Ruby 元编程(第二版)》第 142 页</span></div><div class="line">POSSIBLE_VERBS = [<span class="string">'get'</span>, <span class="string">'put'</span>, <span class="string">'post'</span>, <span class="string">'delete'</span>]</div><div class="line">POSSIBLE_VERBS.each <span class="keyword">do</span> <span class="params">|m|</span></div><div class="line">  eval <span class="string">&lt;&lt;-end_eval</span></div><div class="line">    def <span class="subst">#&#123;m&#125;</span>(path, *args, &amp;b)</div><div class="line">      r[path].<span class="subst">#&#123;m&#125;</span>(*args, &amp;b)</div><div class="line">     end</div><div class="line">  end_eval</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>在这个例子中，也使用了 <code>eval</code>，也在 <code>eval</code> 中拼接了字符串，存在字符串拼接的安全性问题吗？并没有。因为是从常量数组中读取的字符串，并不存在用户任意输入导致注入的问题。</p>
<p>但，我们反过来说，SQL 驱动自带的 <code>query</code> 函数都可能存在注入，难道我们就不用 SQL 了吗？并没有。事实上，注入问题是可以被解决的。如果我们做好对用户输入的 <strong>过滤</strong> 和 <strong>转义</strong> 同样也能解决。问题就在于，这么做的成本和 <code>eval</code> 带来的动态性好处，哪个更大的权衡问题。</p>
<h3 id="Lexer-amp-Parser"><a href="#Lexer-amp-Parser" class="headerlink" title="Lexer &amp; Parser"></a>Lexer &amp; Parser</h3><blockquote>
<p>本来想用中文写这个小标题，但感觉「词法分析器和语法分析器」实在这标题太长了</p>
</blockquote>
<p>学过一些《编译原理》都知道，无论是解释器还是编译器，拿到字符串无非就是</p>
<p><code>词法分析 -&gt; 语法分析 -&gt; 语义检查 -&gt; 生成语法树 -&gt; 代码优化 -&gt; 生成目标代码/执行</code></p>
<p>使用 <code>eval</code> 函数意味着，你的程序需要在运行时经历全部的这些步骤。通常来说即使是脚本语言，在你加载所有文件初始化运行的过程中。前期步骤通常都已经完成了，只剩下最后一步执行了。不过加入 <code>eval</code> 之后就不一样了。因为 <code>eval</code> 传入的是字符串，所以这意味着它需要对这一部分代码从词法分析开始重新走一遍。事实上，词法分析、语法分析、语义检查并不快。</p>
<p>比如说，我们对比下面的代码</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">GC.disable <span class="comment"># 禁用 GC 以避免后一段代码在运行过程中遭遇 GC 对其不公</span></div><div class="line"></div><div class="line">time = Time.now.to_f</div><div class="line"><span class="number">1000000</span>.times <span class="keyword">do</span></div><div class="line">  rand+rand</div><div class="line"><span class="keyword">end</span></div><div class="line">puts <span class="string">"Without eval: <span class="subst">#&#123;Time.now.to_f - time&#125;</span>"</span></div><div class="line"></div><div class="line">time = Time.now.to_f</div><div class="line"><span class="number">1000000</span>.times <span class="keyword">do</span></div><div class="line">  eval(<span class="string">'rand+rand'</span>)</div><div class="line"><span class="keyword">end</span></div><div class="line">puts <span class="string">"With eval: <span class="subst">#&#123;Time.now.to_f - time&#125;</span>"</span></div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Without eval: 0.11499691009521484</div><div class="line">With eval: 6.516125917434692</div></pre></td></tr></table></figure>
<p>慢了 55 倍。如果我们用 Ruby 自带的 profiler 对这两段代码跑一下的话，结果如下：</p>
<p>没有 eval：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"> %   cumulative   self              self     total</div><div class="line">time   seconds   seconds    calls  ms/call  ms/call  name</div><div class="line">62.15    17.03     17.03  1000000     0.02     0.02  nil#</div><div class="line">18.65    22.14      5.11        1  5110.00 27400.00  Integer#times</div><div class="line">12.77    25.64      3.50  2000000     0.00     0.00  Kernel#rand</div><div class="line"> 6.42    27.40      1.76  1000000     0.00     0.00  Float#+</div><div class="line"> 0.00    27.40      0.00        2     0.00     0.00  Time.now</div><div class="line"> 0.00    27.40      0.00        2     0.00     0.00  Fixnum#fdiv</div><div class="line"> 0.00    27.40      0.00        2     0.00     0.00  Numeric#quo</div><div class="line"> 0.00    27.40      0.00        2     0.00     0.00  Time#to_f</div><div class="line"> 0.00    27.40      0.00        1     0.00     0.00  Float#-</div><div class="line"> 0.00    27.40      0.00        1     0.00     0.00  Float#to_s</div><div class="line"> 0.00    27.40      0.00        2     0.00     0.00  IO#write</div><div class="line"> 0.00    27.40      0.00        1     0.00     0.00  IO#puts</div><div class="line"> 0.00    27.40      0.00        1     0.00     0.00  Kernel#puts</div><div class="line"> 0.00    27.40      0.00        1     0.00     0.00  TracePoint#enable</div><div class="line"> 0.00    27.40      0.00        1     0.00     0.00  TracePoint#disable</div><div class="line"> 0.00    27.40      0.00        2     0.00     0.00  IO#set_encoding</div><div class="line"> 0.00    27.40      0.00        2     0.00     0.00  Fixnum#+</div><div class="line"> 0.00    27.40      0.00        2     0.00     0.00  Time#initialize</div><div class="line"> 0.00    27.40      0.00        1     0.00 27400.00  #toplevel</div></pre></td></tr></table></figure>
<p>有 eval：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"> %   cumulative   self              self     total</div><div class="line">time   seconds   seconds    calls  ms/call  ms/call  name</div><div class="line">57.58    25.67     25.67  1000000     0.03     0.03  Kernel#eval</div><div class="line">16.02    32.81      7.14  1000000     0.01     0.04  nil#</div><div class="line">13.14    38.67      5.86        1  5860.00 44580.00  Integer#times</div><div class="line"> 9.17    42.76      4.09  2000000     0.00     0.00  Kernel#rand</div><div class="line"> 4.08    44.58      1.82  1000000     0.00     0.00  Float#+</div><div class="line"> 0.00    44.58      0.00        2     0.00     0.00  Fixnum#fdiv</div><div class="line"> 0.00    44.58      0.00        2     0.00     0.00  Numeric#quo</div><div class="line"> 0.00    44.58      0.00        2     0.00     0.00  Time#to_f</div><div class="line"> 0.00    44.58      0.00        1     0.00     0.00  Float#-</div><div class="line"> 0.00    44.58      0.00        1     0.00     0.00  Float#to_s</div><div class="line"> 0.00    44.58      0.00        2     0.00     0.00  IO#write</div><div class="line"> 0.00    44.58      0.00        1     0.00     0.00  IO#puts</div><div class="line"> 0.00    44.58      0.00        1     0.00     0.00  Kernel#puts</div><div class="line"> 0.00    44.58      0.00        1     0.00     0.00  TracePoint#enable</div><div class="line"> 0.00    44.58      0.00        1     0.00     0.00  TracePoint#disable</div><div class="line"> 0.00    44.58      0.00        2     0.00     0.00  IO#set_encoding</div><div class="line"> 0.00    44.58      0.00        2     0.00     0.00  Fixnum#+</div><div class="line"> 0.00    44.58      0.00        2     0.00     0.00  Time#initialize</div><div class="line"> 0.00    44.58      0.00        2     0.00     0.00  Time.now</div><div class="line"> 0.00    44.58      0.00        1     0.00 44580.00  #toplevel</div></pre></td></tr></table></figure>
<p>虽然在 profile 的掺和下，差距被缩小到了几倍之内，但也可以看出 <code>eval</code> 函数自行的语法解析有多么耗时。所以说，如果你的 <code>eval</code> 是一次性运行与加载时候的，比如上面那个 Rest Client 的例子里，问题并不大，但如果你的 <code>eval</code> 是被频繁调用的话，使用 <code>eval</code> 是非常影响性能的，不应该这么使用。</p>
<h3 id="静态分析与代码优化"><a href="#静态分析与代码优化" class="headerlink" title="静态分析与代码优化"></a>静态分析与代码优化</h3><p>在分析这个问题前，我们先来看两段代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">recursion_loop</span><span class="params">(<span class="keyword">int</span> count)</span></span>&#123;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"Count: %d\n"</span>, count);</div><div class="line">  <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;<span class="keyword">return</span>;&#125;</div><div class="line">  recursion_loop(count - <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">  recursion_loop(<span class="number">100000</span>);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">recursion_loop</span><span class="params">(count)</span></span></div><div class="line">  puts(<span class="string">"Count: <span class="subst">#&#123;count&#125;</span>"</span>)</div><div class="line">  <span class="keyword">return</span> <span class="keyword">if</span> count == <span class="number">0</span></div><div class="line">  recursion_loop(count - <span class="number">1</span>)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">recursion_loop(<span class="number">100000</span>)</div></pre></td></tr></table></figure>
<p>为什么第一段代码在 C++ 中可以正确运行（注：需要开启 -O2 编译选项），而第二段代码在 Ruby 下会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/Users/Delton/RubymineProjects/untitled/script4.rb:2:in `puts&apos;: stack level too deep (SystemStackError)</div><div class="line">	from /Users/Delton/RubymineProjects/untitled/script4.rb:2:in `puts&apos;</div><div class="line">	from /Users/Delton/RubymineProjects/untitled/script4.rb:2:in `recursion_loop&apos;</div><div class="line">	from /Users/Delton/RubymineProjects/untitled/script4.rb:4:in `recursion_loop&apos;</div><div class="line">	from /Users/Delton/RubymineProjects/untitled/script4.rb:4:in `recursion_loop&apos;</div><div class="line">	from /Users/Delton/RubymineProjects/untitled/script4.rb:4:in `recursion_loop&apos;</div><div class="line">	from /Users/Delton/RubymineProjects/untitled/script4.rb:4:in `recursion_loop&apos;</div><div class="line">	from /Users/Delton/RubymineProjects/untitled/script4.rb:4:in `recursion_loop&apos;</div><div class="line">	from /Users/Delton/RubymineProjects/untitled/script4.rb:4:in `recursion_loop&apos;</div><div class="line">	 ... 10908 levels...</div><div class="line">	from /Users/Delton/RubymineProjects/untitled/script4.rb:4:in `recursion_loop&apos;</div><div class="line">	from /Users/Delton/RubymineProjects/untitled/script4.rb:7:in `&lt;top (required)&gt;&apos;</div><div class="line">	from -e:1:in `load&apos;</div><div class="line">	from -e:1:in `&lt;main&gt;&apos;</div></pre></td></tr></table></figure>
<p>报错的原因很显然，栈太深了。这个用递归实现的循环，需要建一个深度高达 100000 层深栈。一般的运行时都不会允许这么深的栈。诶？等一下，那为什么在 C++ 中这段代码可以正常运行呢？因为你的 C++ 编译器发现了这是一个「尾递归」，可以进行「尾递归优化」。尾递归可以被优化成一个非递归形式，自然就不需要那么深的栈了。</p>
<p>这就是 <code>词法分析 -&gt; 语法分析 -&gt; 语义检查 -&gt; 生成语法树 -&gt; 代码优化 -&gt; 生成目标代码/执行</code> 的倒数第二步。Ruby 中也有尾递归优化的选项，但默认不开启。开启的话方法也比较复杂，需要用到 <code>InstrctionSequence</code> 这个编译中间码的类，代码如下：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">RubyVM::InstructionSequence.compile_option = &#123;</div><div class="line">    <span class="symbol">:tailcall_optimization</span> =&gt; <span class="literal">true</span>,</div><div class="line">    <span class="symbol">:trace_instruction</span> =&gt; <span class="literal">false</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">source = <span class="string">&lt;&lt;-end_source</span></div><div class="line">  def recursion_loop(count)</div><div class="line">    puts("Count: \#&#123;count&#125;")</div><div class="line">    return if count == 0</div><div class="line">    recursion_loop(count - 1)</div><div class="line">  end</div><div class="line">  recursion_loop(<span class="number">100000</span>)</div><div class="line">end_source</div><div class="line"></div><div class="line">RubyVM::InstructionSequence.new(source).eval</div></pre></td></tr></table></figure>
<p><strong>注：事实上，这里开启的是尾调用优化，尾调用是尾递归的超集，开启尾调用优化不止会优化尾递归。</strong></p>
<p>但下面这段尾递归代码在即使开启优化的情况下，一样不会得到优化：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">recursion_loop</span><span class="params">(count)</span></span></div><div class="line">  puts(<span class="string">"Count: <span class="subst">#&#123;count&#125;</span>"</span>)</div><div class="line">  <span class="keyword">return</span> <span class="keyword">if</span> count == <span class="number">0</span></div><div class="line">  eval(<span class="string">'recursion_loop(count - 1)'</span>)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">recursion_loop(<span class="number">100000</span>)</div></pre></td></tr></table></figure>
<p>这段代码把一个明明是尾递归的情况破坏成了非尾递归。因为编译器静态分析的时候根本不知道你 <code>eval</code> 里是什么东西。怎么可能给你优化？</p>
<p>虽然这个例子非常极端，但其实不止 <code>eval</code>，比如：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@next_recursion = proc &#123; <span class="params">|count|</span></div><div class="line">  recursion_loop(count - <span class="number">1</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">recursion_loop</span><span class="params">(count)</span></span></div><div class="line">  puts(<span class="string">"Count: <span class="subst">#&#123;count&#125;</span>"</span>)</div><div class="line">  <span class="keyword">return</span> <span class="keyword">if</span> count == <span class="number">0</span></div><div class="line">  @next_recursion.call(count)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">recursion_loop(<span class="number">100000</span>)</div></pre></td></tr></table></figure>
<p>大多数动态方法，都没有办法被静态分析，以提供足够的优化。以至于动态语言的代码优化也一直是一大难点。</p>
<h3 id="对-eval-魔法的思考"><a href="#对-eval-魔法的思考" class="headerlink" title="对 eval 魔法的思考"></a>对 eval 魔法的思考</h3><p>总结一下，谈一谈对「eval 魔法」的思考。<code>eval</code> 在元编程里也一直属于接近于禁术的那种类型。就好像核武器一样可怕。在用 <code>eval</code> 的时候要充分认识到可能带来的后果，才能对其进行使用。核国家的战争也不一定非要互相丢核武器，如果常规武器可以解决的，不必如此大动干戈。比如说前面 rest-client 的例子，也可以不用 <code>eval</code>：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">POSSIBLE_VERBS = [<span class="string">'get'</span>, <span class="string">'put'</span>, <span class="string">'post'</span>, <span class="string">'delete'</span>]</div><div class="line">POSSIBLE_VERBS.each <span class="keyword">do</span> <span class="params">|m|</span></div><div class="line">  define_method(m) <span class="keyword">do</span> <span class="params">|path, *args, &amp;b|</span></div><div class="line">    r[path].send(m, *args, &amp;b)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>也可以解决这样的问题。不过 <code>define_method</code> 的方法，也不能给代码带来静态分析，而这又是在启动时一次性执行的代码，对性能的提升是微乎其微的。所以 rest-client 的 <code>eval</code> 实现并谈不上 evil。</p>
<p><code>eval</code> 被那么多语言至今沿用，其巨大的灵活性带来的便利是毋庸置疑的。只是说，使用 <code>eval</code> 包括使用任何元编程技巧的时候，都要充分考虑到这么做的可能造成的后果，以免莽撞瞎写，误伤自己。</p>
<h3 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h3><p>在 <a href="https://leetcode.com/problems/valid-parentheses/" target="_blank" rel="external">Leetcode #20</a> 括号匹配问题里，有一个可以用 JavaScript 的 <code>eval</code> 实现的魔法写法，非常有趣，大家可以看看开心开心。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * @param &#123;string&#125; s</div><div class="line"> * @return &#123;boolean&#125;</div><div class="line"> */</div><div class="line"><span class="keyword">var</span> isValid = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</div><div class="line">    s = s.replace(<span class="regexp">/\(/g</span>, <span class="string">'+('</span>);</div><div class="line">    s = s.replace(<span class="regexp">/\[/g</span>, <span class="string">'+['</span>);</div><div class="line">    s = s.replace(<span class="regexp">/\&#123;/g</span>, <span class="string">'+&#123;0:'</span>);</div><div class="line">    s = s.replace(<span class="regexp">/\)/g</span>, <span class="string">'+0)'</span>);</div><div class="line">    s = s.replace(<span class="regexp">/\]/g</span>, <span class="string">'+0]'</span>);</div><div class="line">    s = s.replace(<span class="regexp">/\&#125;/g</span>, <span class="string">'+0&#125;'</span>);</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">        <span class="built_in">eval</span>(s);</div><div class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引&quot;&gt;&lt;a href=&quot;#引&quot; class=&quot;headerlink&quot; title=&quot;引&quot;&gt;&lt;/a&gt;引&lt;/h3&gt;&lt;p&gt;对于大多数动态语言，都支持 &lt;code&gt;eval&lt;/code&gt; 这个神奇的函数。这打他们太爷爷 Lisp 开始就支持这种方法。虽然写法（eg: &lt;code&gt;(eval &amp;#39;(+ 1 2 3))&lt;/code&gt; ）有稍许不同，但语义是一样的，就是说 &lt;code&gt;eval&lt;/code&gt; 函数接受一个字符串类型作为参数，将其解析成语句并混合在当前作用域内运行。但我想大家也都听过这么一句话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;eval is evil.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是 How evil is eval？那么既然 &lt;code&gt;eval&lt;/code&gt; 如此罪恶，那么为什么它仍被那么多动态语言作为接口暴露呢？我们不妨来仔细探讨一下 &lt;code&gt;eval&lt;/code&gt; 在使用中究竟会产生什么问题，在日常编程中究竟该不该使用 &lt;code&gt;eval&lt;/code&gt;，如果要用，那么又该如何使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Ruby" scheme="http://blog.heckpsi.com/tags/Ruby/"/>
    
  </entry>
  
  <entry>
    <title>自制开源 Web 框架的 40 天</title>
    <link href="http://blog.heckpsi.com/2016/10/18/em-midori-40-days/"/>
    <id>http://blog.heckpsi.com/2016/10/18/em-midori-40-days/</id>
    <published>2016-10-17T18:59:12.000Z</published>
    <updated>2016-10-18T04:47:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引"><a href="#引" class="headerlink" title="引"></a>引</h2><p>这篇文章写在 <a href="https://github.com/heckpsi-lab/em-midori" target="_blank" rel="external">em-midori</a> 项目建立的第 40 天，从决定写这样一个框架，到现在勉强能用只花了 40 天里空闲的日子。从原先写开源代码光挖坑不填，到这次能把项目带到即将 development ready 的地步，确实在开发和思考的过程有非常多的不同。于是我变把这些地方记录下来，希望给以后的开发和诸位提供一些些帮助。</p>
<a id="more"></a>
<h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><h3 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h3><p>最早有类似于我开发的这个框架的想法大概已经过去了大半年的时间里。在此之前，我使用的 Web 框架主要是 Rails 和 Sinatra。Rails 的强大我想不必多述，在生产中大量使用 Sinatra 还是出于几个原因。一个是使用 Vue.js 做前端框架后，后端做 API 就足够了，而 Rails API Standalone 则是 Rails 5 发布的，相对来说晚一些；Sinatra 有一个设计良好的 DSL，在做路由的时候更加直观和灵活；最后就是 Rails 基于栈实现的路由匹配速度略慢，导致了大约是 Sinatra 性能的一半。</p>
<p>不过说起性能，无论是 Sinatra 还是 Rails 都是 IO 阻塞 的。主要的原因当然是 IO 非阻塞的框架在用起来的时候通常非常反人类。但 IO 阻塞模型在高并发或长连接下确实表现不佳，以至于 Rails 在 ActionCable 的实现中也不得不使用了非阻塞的 EventMachine。</p>
<p>在 Ruby 上比较有名的，出过三个非阻塞 IO 的 Web 框架，他们是 cramp，sinatra-synchrony 和 angelo。然而前两者都出现在 EventMachine 出现的早期，一个很早就停止维护了，而另一个也受限于完全照搬 sinatra 对异步仅限于网络 IO 的层面。而后者使用了 Celluloid::IO 作为事件模型的实现，然而其开发进度极慢，并有不维护的迹象，因为其特别的 IO 库，也愈发地有不维护的可能。</p>
<p>试图想改变这一问题之前，我考虑过很多问题。一方面是如何优雅地解决问题，而另一方面则是 Ruby 现有生态是否会接受。</p>
<h3 id="转机"><a href="#转机" class="headerlink" title="转机"></a>转机</h3><p>此事出现转机主要是两件事。</p>
<p>一个是我们做的某个项目，需要对政府的接口做代理并封装。而这个政府的 API 接口访问奇慢，以至于出现了严重的阻塞导致了性能问题。在一台四核的机器上最后只有 20 req/s 的性能，简直是不能忍受。</p>
<p>另一件事是去 RubyKaigi 2016 听了不少的安利，发现许多演讲更是一个比一个激进。与其说去讨论现有生态是否会接受，不如先把事情做得足够优秀来得更重要。至少，我自己现在有用这东西的需求不是吗。</p>
<h2 id="开坑"><a href="#开坑" class="headerlink" title="开坑"></a>开坑</h2><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>2016 年 9 月 9 日是 RubyKaigi 2016 的第二天，在 10:25，也就是某个日本人正要介绍如何更好地做语法绑定之前，我开启了这个弥天大坑。一开始考虑的问题是依赖、路线和 API 设计。</p>
<p>我一开始就打算好用 EventMachine 作为事件模型的实现。然而如何减少恼人的 callback，我决定选择在 Fiber 上构建一个类似于 async/await 的语法来避免。至少，依靠元编程的力量，我们无需做把 ES7 编译成 ES5 这种奇怪的工作，也不需要 import future，只需要把它当做框架理所当然的一部分就好了。</p>
<p>今天设计 Web 框架毫无疑问需要对 WebSocket 和 EventSource 进行良好的支持，而不是在 Rack 上打一层奇怪的补丁之类的。至少，我在设计 API 的过程中，参考了 sinatra, grape, rack, angelo 的设计，并阅读了相应的源代码，也是做好了完全的准备。所以，一开始在我脑中的 API 设计很快就变成了<a href="https://github.com/heckpsi-lab/em-midori/blob/master/example/route.rb" target="_blank" rel="external">这样</a>。</p>
<p>总体来说，它看起来很像 sinatra 和它的姊妹们。但稍有不同的还是有一些地方。</p>
<p>比如：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">websocket <span class="string">'/websocket'</span> <span class="keyword">do</span> <span class="params">|ws|</span></div><div class="line">  ws.on <span class="symbol">:open</span> <span class="keyword">do</span></div><div class="line">    ws.send <span class="string">'Hello'</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>虽然，WebSocket 在 HTTP/1.1 上其实是个 GET 请求，但作为一个 DSL，不应该让开发者考虑底层是什么实现的，而是考虑应用上是怎么做的。所以把 WebSocket 和 EventSource 单独拿出来当动词。</p>
<p>还有例如：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">post <span class="string">'/user/login'</span> <span class="keyword">do</span></div><div class="line">  define_error <span class="symbol">:forbidden_request</span>, <span class="symbol">:unauthorized_error</span></div><div class="line">  <span class="keyword">begin</span></div><div class="line">    request = JSON.parse(@request.body)</div><div class="line">    UserController.login(request[<span class="string">'username'</span>], request[<span class="string">'password'</span>]).to_json</div><div class="line">    <span class="comment"># =&gt; &#123;code: 0, token: String&#125;</span></div><div class="line">  <span class="keyword">rescue</span> ForbiddenRequest =&gt; _e</div><div class="line">    Midori::Response.new(<span class="number">403</span>, &#123;<span class="symbol">code:</span> <span class="number">403</span>, <span class="symbol">message:</span> <span class="string">'Illegal request'</span>&#125;.to_json)</div><div class="line">  <span class="keyword">rescue</span> UnauthorizedError =&gt; _e</div><div class="line">    Midori::Response.new(<span class="number">401</span>, &#123;<span class="symbol">code:</span> <span class="number">401</span>, <span class="symbol">message:</span> <span class="string">'Incorrect username or password'</span>&#125;.to_json)</div><div class="line">  <span class="keyword">rescue</span> =&gt; _e</div><div class="line">    Midori::Response.new(<span class="number">400</span>, &#123;<span class="symbol">code:</span> <span class="number">400</span>, <span class="symbol">message:</span> <span class="string">'Bad Request'</span>&#125;.to_json)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>在这个例子中，考虑了一个路由的重要特性，那就是希望做到「路由即文档」。请求的类型、参数、可能的错误、错误处理方式都被代码本身描述出来了。唯独正确处理的返回需要单独写一下文档。</p>
<p>当然在这个例子中，还没有使用中间件，而使用中间件能更好解决问题。</p>
<p>相比 Rack 的中间件，我考虑再三，最后把其设计成 Android Xposed 那样 hook 的形式。简单来说中间件流程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">请求 -&gt; 中间件 1 -&gt; 中间件 2 -&gt; 处理 -&gt; 中间件 2 -&gt; 中间件 1 -&gt; 返回</div></pre></td></tr></table></figure>
<p>这使得 JSON API 的实现变得非常容易，只需要把最靠近处理的那一层加入如下的中间件：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">JSONMiddleware</span> &lt; Middleware</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">before</span><span class="params">(request)</span></span></div><div class="line">    request.body = JSON.parse(request.body) unless request.body == <span class="string">''</span></div><div class="line">    request</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">after</span><span class="params">(_request, response)</span></span></div><div class="line">    response.header[<span class="string">'Content-Type'</span>] = <span class="string">'application/json'</span></div><div class="line">    response.body = response.body.to_json</div><div class="line">    response</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">body_accept</span></span></div><div class="line">    [Hash, Array]</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>另外，中间件还允许跳过，类似于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">请求 -&gt; 中间件 1 -&gt; (跳过) -&gt; 中间件 1 -&gt; 返回</div></pre></td></tr></table></figure>
<p>这使得实现登录校验功能的中间件变得异常方便和容易。</p>
<p>我在一开始就给项目设定了一些重要的指标，比如持续集成、code coverage 必须是 100%、code climate 评分必须是 4.0。并且提前设计了路线图。这之后被证明是非常有效的，极大且有效避免了我想偷懒而制造理由。这些东西我非常推荐在项目一开始就做。否则当中期加进去发现有巨多事情要做时，就基本失去了做这件事的动力。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>真正激励到我的，是 <code>v0.0.4</code> 后的一次关于 Hello World 的性能 benchmark。</p>
<p>在 <strong>单核单线程</strong> 的情况下进行了如下框架的测试对比</p>
<table>
<thead>
<tr>
<th style="text-align:left">框架</th>
<th style="text-align:right">req/s</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Rails</td>
<td style="text-align:right">817</td>
</tr>
<tr>
<td style="text-align:left">Rails API Mode</td>
<td style="text-align:right">930</td>
</tr>
<tr>
<td style="text-align:left">Sinatra</td>
<td style="text-align:right">2563</td>
</tr>
<tr>
<td style="text-align:left">express.js</td>
<td style="text-align:right">6129</td>
</tr>
<tr>
<td style="text-align:left">em-midori</td>
<td style="text-align:right">11440</td>
</tr>
</tbody>
</table>
<p>虽然一些特性还没有实现，所以跑得会比之后版本更快。但这充分说明了 Ruby 不但不慢，而且可以非常快。这大大增加了我继续开发的动力。</p>
<h3 id="元编程"><a href="#元编程" class="headerlink" title="元编程"></a>元编程</h3><p>关于元编程，我最喜欢的一句话来自于《Ruby 元编程》的后记：</p>
<blockquote>
<p>元编程不过是编程。</p>
<p>Meta Programming is Just Programming.</p>
</blockquote>
<p>元编程做到不伤害，是重要且困难的。在 DSL 中使用元编程实际上是对元编程本身的约束。也就是说，你希望给用户一个无害的新特性。比如路由中  <code>define_error</code>  的实现如下：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">module</span> <span class="title">Kernel</span> <span class="comment">#:nodoc:</span></span></div><div class="line">  <span class="comment"># This method is implemented to dynamically generate class with given name and template.</span></div><div class="line">  <span class="comment"># Referenced from &#123;Ruby China&#125;[https://ruby-china.org/topics/17382]</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">define_class</span><span class="params">(name, ancestor = Object)</span></span></div><div class="line">    Object.const_set(name, Class.new(ancestor))</div><div class="line">    Object.const_get(name).class_eval(&amp;Proc.new) <span class="keyword">if</span> block_given?</div><div class="line">    Object.const_get(name)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">define_error</span><span class="params">(*args)</span></span></div><div class="line">    args.each <span class="keyword">do</span> <span class="params">|arg|</span></div><div class="line">      class_name = arg.to_s.split(<span class="string">'_'</span>).map &#123; <span class="params">|word|</span> word[<span class="number">0</span>] = word[<span class="number">0</span>].upcase; word &#125;.join</div><div class="line">      define_class(class_name, StandardError)</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>与其直接暴露一个 <code>define_class</code> ，暴露 <code>define_error</code> 就能完成我们对路由定义错误的需求，也不至于被滥用。设计元编程 API 的时候需要多考虑类似的问题。但实际上，好的 DSL API 的设计本身不就是对这些问题能否考虑周到吗？</p>
<p>Ruby 对元编程极好的支持是 Ruby 重要的特性，与其说害怕而放之不用，不如说好好学习如何无害地使用。比如当我试图加入 await 关键字的时候，我一点都不觉得害怕，因为加入带来的好处，以及清晰的实现思路使得其变成非常自然的事情。这也正是「元编程不过是编程」的含义。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在 WebSocket 开发中，由于是通过阅读 RFC 标准实现的，实现出了许多常见客户端并没有的功能。这使得测试变得异常困难。这些一开始考虑时根本没想到会遇到的问题，无疑会严重影响开发的进程。这个测试问题甚至导致了路线图的修改和部分的延误。但这些问题与其说避免，不如说只有不断遇到才能以后更好解决。100% 的测试覆盖率非常难达到，但既然是奔着负责的开源项目去的，又是一个框架项目，这样的问题是不能逃避的。</p>
<p>一开始甚至想要重新造一遍客户端轮子。但再三思考下，还是放弃而直接写入二进制数据流的方式来处理。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">it <span class="string">'should decode masked Hello String correctly'</span> <span class="keyword">do</span></div><div class="line">  websocket.decode(StringIO.new([<span class="number">0x81</span>, <span class="number">0x85</span>, <span class="number">0x37</span>, <span class="number">0xfa</span>, <span class="number">0x21</span>, <span class="number">0x3d</span>, <span class="number">0x7f</span>, <span class="number">0x9f</span>, <span class="number">0x4d</span>, <span class="number">0x51</span>, <span class="number">0x58</span>].pack(<span class="string">'C*'</span>)))</div><div class="line">  expect(websocket.msg).to eq(<span class="string">'Hello'</span>)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<h2 id="以后的计划"><a href="#以后的计划" class="headerlink" title="以后的计划"></a>以后的计划</h2><p>要做一个完善的开源框架的路是非常长的。短短列一下计划就有很多，比如：</p>
<ul>
<li>实现异步文件读写</li>
<li>实现异步数据库读写驱动</li>
<li>驱动接入数据库 ORM</li>
<li>实现 helpers 帮助方法</li>
<li>用中间件重构早期硬编码</li>
<li>…</li>
</ul>
<p>其实平时司空见惯的很多东西，仔细一想只会越来越多。但只要有良好的规划，稳健的迭代，相信最终都能克服的。</p>
<p>写下这篇文章与各位 Rubyist 共勉，虽然只做了微小的工作。希望 Ruby 社区能在越来越多开源项目的帮助下发展得越来越好。</p>
<p>最后，不要脸地求 Star  <a href="https://github.com/heckpsi-lab/em-midori" target="_blank" rel="external">em-midori</a> （逃</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引&quot;&gt;&lt;a href=&quot;#引&quot; class=&quot;headerlink&quot; title=&quot;引&quot;&gt;&lt;/a&gt;引&lt;/h2&gt;&lt;p&gt;这篇文章写在 &lt;a href=&quot;https://github.com/heckpsi-lab/em-midori&quot;&gt;em-midori&lt;/a&gt; 项目建立的第 40 天，从决定写这样一个框架，到现在勉强能用只花了 40 天里空闲的日子。从原先写开源代码光挖坑不填，到这次能把项目带到即将 development ready 的地步，确实在开发和思考的过程有非常多的不同。于是我变把这些地方记录下来，希望给以后的开发和诸位提供一些些帮助。&lt;/p&gt;
    
    </summary>
    
    
      <category term="开源" scheme="http://blog.heckpsi.com/tags/%E5%BC%80%E6%BA%90/"/>
    
      <category term="Ruby" scheme="http://blog.heckpsi.com/tags/Ruby/"/>
    
  </entry>
  
  <entry>
    <title>从来没有什么企业价值观</title>
    <link href="http://blog.heckpsi.com/2016/09/16/why-i-support-alibaba-in-the-problem-of-mooncake/"/>
    <id>http://blog.heckpsi.com/2016/09/16/why-i-support-alibaba-in-the-problem-of-mooncake/</id>
    <published>2016-09-16T13:40:44.000Z</published>
    <updated>2016-09-16T14:02:04.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引"><a href="#引" class="headerlink" title="引"></a>引</h3><p>这几天打开什么技术论坛或者群都在讨论阿里巴巴月饼事件。支持的双方的观点一个出于行为，认为「技术人员能使用脚本工具抢购月饼有失公允」，另一方面则在讨论结果，认为「技术人员的测试出自本能，并没有造成不良后果」。然而很快就有了第三派，拿出 <a href="https://www.zhihu.com/question/50614384/answer/121891652" target="_blank" rel="external">Google 抢 T 恤</a> 作例子，认为「既然没有明令禁止，行为不但任何过错」，并认为「鼓励技术人员这样做有利于公司发展」。</p>
<p>然而我对这三个观点都是不支持的，无论是哪种其实都没有从根本上在探讨这一问题，大多数人都是在讨论是否抢购是否是一种游戏需要「公平」作为大前提或利用自身优势行为是不是「合规」的问题上。然而作为一个社会，亦或是像如此大规模的公司，考虑相对的「公平性」是重要的，但显然它需要给更多的东西让步，真正决定阿里决策的事情是「利益」的权衡。</p>
<a id="more"></a>
<h3 id="与-Google-的比较"><a href="#与-Google-的比较" class="headerlink" title="与 Google 的比较"></a>与 Google 的比较</h3><p>一句话解释为什么 Google 允许程序员通过技术手段抢免费 T 恤，而阿里不能通过技术手段抢购月饼：程序员是 Google 的大爷，而不是阿里的。如果 Google 允许程序员通过工作优势抢 T 恤，优点自然是调动起了员工在技术上的积极性，也让程序员更认为自己被尊重；而缺点呢，自然是其他职位的人抢不到 T 恤，而 Google 并不认为这些行政职位的人对这件事所能产生的不满，是不足以影响公司利益的，是不足于允许抢带来的好处更重要。</p>
<p>而对于阿里来说，阿里技术对公司的影响虽然不能说是可有可无的，但是作为一家电子商务公司，更好的售后、更好的活动设计、更好的行政交流无疑比起技术带来的优势大太多。那么，阿里固然会对行政人员进行偏袒，拒绝技术人员对行政人员在公司福利上享有优势。技术部门人员会跟风辞职吗？比起 Google 小团队高效率模式的技术开发，阿里这种大象式的开发不会因为几个技术，哪怕是十几个技术辞职而影响。而真的会有几十个几十个的辞职，就为了月饼吗？和 Google 考虑行政人员的状态一样，阿里也是这样考虑技术人员的。阿里允许程序员这么做，是不会「有利于公司发展」的。</p>
<h3 id="权力"><a href="#权力" class="headerlink" title="权力"></a>权力</h3><p>自我读高中以来就知道阿里是一家 HR 权力大过天际的公司，但显然，这和我们熟知的其他互联网巨头有着显著的区别。试想一下，如果百度每年要实现营收增长 100%，除非指望莆田系医院每年都能扩增 20%，就只能希望自己广告业务的转化率增加 100% 了，或者广告的展示量增加 100%。今天看到一页广告，那么 3 年后你就可以看到 8 页广告了。显然，百度还没有能恶心到这个地步，所以通过技术手段提高自己的营收能力在百度一直以来都是非常重要的事情。哪怕这几年看到百度在机器学习领域做了很多收效甚微的事情，那也是其不惜资本不得不做出的尝试。</p>
<p>而反观阿里，虽然我们也知道有个叫「阿里妈妈」的广告平台，但淘宝本来就是消费的最大入口，比起从其他网页点击进去。而商品的展示和搜索，虽然也是在海量数据里万里挑一，但相对也是格式化的数据，并且量和网页爬虫比起来实在是简单太多。在阿里，从来就没有一个时间是技术主导的，就算淘宝没有商品卖，你也知道淘宝有一段时间靠非法商家的信用卡套现服务也能过活。技术和行政的关系，从来就是和其他互联网公司倒过来的。你就算开除掉一个 P9 甚至是 P10 P11 也不会有任何影响。这次开除的 5 名员工中，甚至一些是才刚刚转正的，开除掉，不但能解 HR 的心头之恨，更没有人会有所怀疑。</p>
<h3 id="耍流氓"><a href="#耍流氓" class="headerlink" title="耍流氓"></a>耍流氓</h3><p>云舒在 <del>不知道赔了多少个 10 万而阿里不给报销</del> 离职后，对阿里也没有留下任何好的印象。一个在阿里待了十年甚至当上了技术总监的技术高层，对这家公司也留下负面的印象，那么哪个技术在死心塌地为公司工作呢。</p>
<p>然而马云去年就在<a href="https://www.zhihu.com/question/30362644" target="_blank" rel="external">《谈离职事件》</a>里说：</p>
<blockquote>
<p>我提醒某些同事，如果你真恨这个组织，真恨那些同事，你真恨公司一切事情都是对着你干，就是让你不好，建议你离开公司。如果你觉得这么讨厌公司，那你待在里面干什么？你自己从来不犯错误？如果你不犯错误，你那么完美，你不应该在我们这么糟糕的公司里面呆着。</p>
<p>我发现很多人现在躲在草莓群里面天天骂，如果你在内网上面 speak up，认为彭蕾这句话讲得不对，我尊重；躲在后面骂，我讨厌那些人天天骂老婆不好，又不离婚，天天骂，又不完善，待在这个公司干什么。</p>
</blockquote>
<p>马云试图把员工与企业的结合和婚姻划上等号。但显然，工作是为了钱，而婚姻不是。人在公司里自然有苟活的理由。如果决策者认为员工的负面情绪影响了公司，那么开除是公司该做出的决定，而不是把这部分压力转让给员工，美其名曰「自愿离职」。但事实，阿里对技术人员的剥削和歧视，已经分布在各个层次和领域，成为其「企业文化」的一部分了。</p>
<h3 id="错误的印象"><a href="#错误的印象" class="headerlink" title="错误的印象"></a>错误的印象</h3><p>我们都曾认为「互联网公司」就该是「技术驱动」，或者说技术是其盈利的首要手段，是资本追逐的首要目标，是优先考虑的。当然，如果你认为今天阿里五个月饼把你的错误印象摆正了的话，你还是 Too young, too simple。正确来说，阿里从一开始就不是我们想象的那样，如 Google 似的互联网公司，阿里在前端放置的各种数字水印，与其说是当员工，倒不如说是处处提防的奴隶。如此种种花边，又非一两天或是一两年，说是打醒，还不如说就是茶余饭后的笑话而已。</p>
<h3 id="结：如果非要探讨公平"><a href="#结：如果非要探讨公平" class="headerlink" title="结：如果非要探讨公平"></a>结：如果非要探讨公平</h3><p>那么就月饼这事，就事论事来说，那么我也有几个问题。</p>
<ul>
<li>那么一个在阿里工作的人通过苦练玩游戏，拥有超出常人的反应速度和鼠标操作的 APM 是不是也是利用自身优势，破坏公平性呢？</li>
</ul>
<p>以及</p>
<ul>
<li>一个通过激素药物提高运动水平参加奥运会的公不公平？</li>
<li>一个天生某些腺体发达，激素分泌异于常人，没有进行任何药物干预的人，参加奥运会公不公平？</li>
<li>一个通过转基因技术，移植了一个特殊腺体基因的人，参加奥运会公不公平？</li>
<li>一个人在去太空旅游后收到宇宙辐射影响发生了基因突变，他孩子产生了这种腺体，参加奥运会公不公平？</li>
</ul>
<p>最后</p>
<ul>
<li>国家派大量人员去太空照射辐射，为了筛选出有这种特殊基因的后代，以定向培养运动员，参加奥运会公不公平？</li>
</ul>
<p>究竟什么是公平，什么行为是正义，公司的条款究竟是对行为的黑名单，还是粗略扔出一句「价值观」这样的白名单，就留给诸位读者自己理解了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引&quot;&gt;&lt;a href=&quot;#引&quot; class=&quot;headerlink&quot; title=&quot;引&quot;&gt;&lt;/a&gt;引&lt;/h3&gt;&lt;p&gt;这几天打开什么技术论坛或者群都在讨论阿里巴巴月饼事件。支持的双方的观点一个出于行为，认为「技术人员能使用脚本工具抢购月饼有失公允」，另一方面则在讨论结果，认为「技术人员的测试出自本能，并没有造成不良后果」。然而很快就有了第三派，拿出 &lt;a href=&quot;https://www.zhihu.com/question/50614384/answer/121891652&quot;&gt;Google 抢 T 恤&lt;/a&gt; 作例子，认为「既然没有明令禁止，行为不但任何过错」，并认为「鼓励技术人员这样做有利于公司发展」。&lt;/p&gt;
&lt;p&gt;然而我对这三个观点都是不支持的，无论是哪种其实都没有从根本上在探讨这一问题，大多数人都是在讨论是否抢购是否是一种游戏需要「公平」作为大前提或利用自身优势行为是不是「合规」的问题上。然而作为一个社会，亦或是像如此大规模的公司，考虑相对的「公平性」是重要的，但显然它需要给更多的东西让步，真正决定阿里决策的事情是「利益」的权衡。&lt;/p&gt;
    
    </summary>
    
    
      <category term="百度" scheme="http://blog.heckpsi.com/tags/%E7%99%BE%E5%BA%A6/"/>
    
      <category term="Google" scheme="http://blog.heckpsi.com/tags/Google/"/>
    
      <category term="阿里巴巴" scheme="http://blog.heckpsi.com/tags/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4/"/>
    
  </entry>
  
  <entry>
    <title>围绕 MacBook Pro 打造的工作站设计日志</title>
    <link href="http://blog.heckpsi.com/2016/06/21/workstation-setup-guide/"/>
    <id>http://blog.heckpsi.com/2016/06/21/workstation-setup-guide/</id>
    <published>2016-06-21T12:41:31.000Z</published>
    <updated>2016-06-21T12:55:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><h4 id="为什么我一定要用-macOS？"><a href="#为什么我一定要用-macOS？" class="headerlink" title="为什么我一定要用 macOS？"></a>为什么我一定要用 macOS？</h4><p>这个问题需要放在一上来就被解释清楚，尤其当你发现这个 setup 的性价比其实非常低。然而这么设计自然有它存在的意义。首先，这和我的工作性质有关。我的日常开发同时涉及后端、前端和设计。尤其是我的后端围绕着 Ruby 展开。Ruby 的 native extensions 在 Windows 上不免没有那么好用，甚至在兼容性上有一些问题。使用一个 POSIX 兼容的操作系统是非常必要的。然而涉及前端的用户界面设计时，我还需要用到 Illustrator、Photoshop、Sketch 等一些软件。哪怕不使用 Sketch，剩下的软件也没有 Linux 的兼容版本。这使得 macOS 是我能避免频繁切换操作系统的唯一选择。</p>
<a id="more"></a>
<h4 id="为什么不使用台式机的选项？"><a href="#为什么不使用台式机的选项？" class="headerlink" title="为什么不使用台式机的选项？"></a>为什么不使用台式机的选项？</h4><p>在组建这个工作站系统的一开始，我希望围绕一款苹果的台式机来开始。苹果目前仍然在销售的台式机有 Mac Mini、Mac Pro 和 iMac，其中 iMac 带一块 27 寸的 5K 屏幕。但是 Mac Mini 和 iMac 本质上使用的仍然是移动级别的 CPU。而 Mac Pro 由于长久没有更新，目前的购买选项性价实在太差，并且 Mac Pro 的风道虽然设计非常合理，但是很多使用经验表明，数个月后当灰尘覆盖底部后风道会收到极严重的影响，故不作考虑。</p>
<h3 id="如何"><a href="#如何" class="headerlink" title="如何"></a>如何</h3><h4 id="屏幕设置"><a href="#屏幕设置" class="headerlink" title="屏幕设置"></a>屏幕设置</h4><p><img src="http://cdn.heckpsi.com/screen-setup.jpg" alt="Screen Setup"></p>
<p>中间是 34 英寸 21:9 带鱼屏幕，用来做视频剪辑等素材复杂的工作时能很好胜任。写代码时也能同时照顾多个文件。右侧 24 英寸 16:9 屏幕竖放，用于看适合竖着看的内容，比如开发文档、论文，不看的时候把聊天窗口丢在右侧避免对主要工作视线的干扰。上方 23 英寸 16:9 屏幕，用于连接 PC，用于偶尔需要看的 Visual Studio 上的项目，或者玩一些 PC 独占的游戏等。</p>
<p>这里我使用了 Synergy 软件，来给两台电脑共享键盘和鼠标。由于 Synergy 跨平台支持，只要简单配置屏幕的位置，就能提供鼠标、键盘和剪贴板的双机共享了。</p>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>当两块高分辨率的屏幕插入 MacBook Pro 后，你能看到显著的性能下滑，发热非常明显。如果试图利用 21:9 屏幕的优势玩一些 macOS 系统兼容的游戏比如 欧洲卡车模拟器 的时候哪怕在全低画质下也不能流畅运行。如果跑视频渲染、压片等操作时，同样的性能问题明显。相反在一些 CPU 密集的应用场景下，比如编译程序的时候，反而没有太大的问题。而内存上，16GB 也基本够使用，虽然如果是 32GB 或者 64GB 的配置的话，性能上更游刃有余一些。</p>
<p>综上我们可以发现，主要问题出在 MacBook Pro 的显卡上。那么想到的方案自然就是外置显卡。不过，凡是做过 expressCard 外置显卡的人都知道，对显卡性能的损失是非常严重的。这是因为 expressCard 虽然是总线接口，但是其带宽只有 PCI-E x1。然而 MacBook Pro 所提供的雷电接口，在 Thunderbolt 2.0 协议下就有 20Gbps 的带宽，这相当于 PCI-E x4 的带宽，哪怕使用 GTX 970 这样的显卡，也只有 10% 的性能损失。</p>
<p>我使用的外置 PCI-E 盒子是 AKiTiO 的产品。外包装上明显标注，不支持显卡。这是因为显卡需要额外的供电，而盒子只能提供 60W 的供电，远小于显卡的需求，直接插上用可能会把显卡烧坏。所以我们将显卡盒外壳拆开后，单独接一个 400W 电源到显卡的 8pin 上。只不过，只这么操作，电源并不会认为自己开机了，所以不会供电。我们还需要用回形针把电源 24pin 的 13 引脚短接到地线，来模拟一个开机的情况。在我用了一天后，我发现 Dell 曾经为他们的迷你电脑推出过一款电源，其输出正是 12V 的 8pin，并且功率高达 220W，这是 Dell DA-2 电源适配器。所以如果不想魔改电源的话，可以使用这一解决方案。</p>
<p>驱动上的话，NVIDIA 只为 Mac Pro 推出过显卡驱动，而不是 MacBook Pro。当然，操作系统层面的事情，当然我们可以魔改驱动，有一个一键安装的脚本项目在此 <a href="https://github.com/goalque/automate-eGPU" target="_blank" rel="external">automate-eGPU</a>。不过由于新的 Mac 的安全策略，你还需要 Command + R 开机进入恢复模式，在实用工具-终端中输入命令关闭驱动签名校验，才能正常使用，这一点这个一键脚本也会做出相应的提示。</p>
<p>至此，我们解决了显卡性能上的问题。</p>
<h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><p>买 256GB 版本 MacBook Pro 省下来的钱就是脑袋里进的水。为了解决把笔记本变为工作站后增加的大量数据，不得不寻找外置的存储方案进行妥协。最常见的解决方案当然就是移动硬盘。但事实上，移动硬盘通过 USB 3.0 连接，经常容易发生连接不稳定的情况，从而导致一些存储意外发生，我曾因这些原因导致过数据丢失一次。直到我见到了 Transcend 的 256GB 扩容存储卡，其长度比一般卡还要短一些，插入 MacBook Pro 中能几乎贴合于卡槽，从而避免了携带和使用上的不安全。唯一麻烦的是拿出来的时候需要使用一把面包刀或者尖锐的支架才能让卡与机器分离。</p>
<h4 id="噪音"><a href="#噪音" class="headerlink" title="噪音"></a>噪音</h4><p>虽然我们把显卡外置了，理论上机器散热没有任何压力。但实际上，Thunderbolt 2 的连接处由于非常巨大的数据交换，实际上左侧发热相对还是有点严重。考虑到，MacBook Pro 不止通过风道具有很强的散热能力，其铝合金外壳本身也被设计成其散热的一部分，我们大可通过降低外壳温度来降低整体温度。我选择了目前还只有在日本市场销售的 USB 水冷套件，为我的 MacBook Pro 做进一步降温。</p>
<h4 id="外设"><a href="#外设" class="headerlink" title="外设"></a>外设</h4><p>关于键盘，不多说，参考之前的文章<a href="http://blog.heckpsi.com/2016/05/14/customized-machanical-keyboard/">《一款祖传的机械键盘》</a>。在我使用的那么多的鼠标中，没有一款鼠标能比 Logitech M558 更适合 Mac 了，说实话 Apple Magic Mouse 还是省省吧，那东西就是个能挪动的触摸板。M558 从设计到重量甚至是电池，简直就是天生为 MacBook 准备的。而且，很便宜，并不是 Logitech 的高端产品。</p>
<h4 id="便携"><a href="#便携" class="headerlink" title="便携"></a>便携</h4><p>虽然我们对整个 setup 进行了巨大的改动。但是其便携性没有遭到下降。我只需要关机后断开先开连接，就能带出门。而我的数据、执行了一半的工作流都能随身携带。续航也能维持在 8 - 9 小时的 MacBook Pro 的正常续航水平，而选择的 60% 键盘和 Logitech M558 也都很适合携带。这是单独搭建的工作站无法得到的优秀体验。</p>
<h3 id="购物列表"><a href="#购物列表" class="headerlink" title="购物列表"></a>购物列表</h3><table>
<thead>
<tr>
<th>选项</th>
<th>价格（人民币元）</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>MacBook Pro 15’’</td>
<td>14288</td>
<td>国行</td>
</tr>
<tr>
<td>Transcent JetDrive Lite 256GB</td>
<td>1099</td>
<td></td>
</tr>
<tr>
<td>x86 兼容机</td>
<td>5000</td>
<td></td>
</tr>
<tr>
<td>AOC Q3477FQ</td>
<td>2399</td>
<td></td>
</tr>
<tr>
<td>AKiTiO Thunderbolt 2 PCI-E</td>
<td>1200</td>
<td>二手</td>
</tr>
<tr>
<td>NVIDIA GTX 970 ITX</td>
<td>1700</td>
<td>二手</td>
</tr>
<tr>
<td>Dell DA-2 Adapter</td>
<td>32</td>
<td>二手</td>
</tr>
<tr>
<td>ViewSonic VA2462H</td>
<td>899</td>
<td></td>
</tr>
<tr>
<td>ViewSonic VA2349S</td>
<td>699</td>
<td></td>
</tr>
<tr>
<td>乐歌 D3 显示器支架</td>
<td>199</td>
<td></td>
</tr>
<tr>
<td>乐歌 L1 显示器支架</td>
<td>79</td>
<td></td>
</tr>
<tr>
<td>Logitech M558</td>
<td>169</td>
<td></td>
</tr>
<tr>
<td>客制化机械键盘</td>
<td>1290</td>
<td></td>
</tr>
<tr>
<td>笔记本水冷套价 USBWATC2</td>
<td>583.73</td>
<td>日本 Amazon</td>
</tr>
<tr>
<td><strong>总计</strong></td>
<td>29604.73</td>
</tr>
</tbody>
</table>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li><strong>当 CPU 和内存遇到了瓶颈</strong>：由于使用的是移动的 CPU 和内存，虽然都算不错，但在一些任务上依然会遇到瓶颈，比如机器学习或者大型编译。于是我在房间里准备了一台 22 核 44 线程 64GB 内存的服务器，让 Mac 可以随时随地远程登录来执行这部分任务。</li>
<li><strong>内置的屏幕无法关闭</strong>：当系统默认显卡切换为 GTX 970 时，把屏幕盖子盖上后，虽然屏幕已不作显示，但操作系统仍然认为该屏幕存在并耗费资源进行渲染。这可以被认为是 macOS 的一个 bug。暂时没有解决方案。</li>
<li><strong>Synergy 在多屏下检测有误</strong>：Synergy 跨机器的检测逻辑是你达到了屏幕的边缘，而这个边缘是指你最边缘的那块屏幕的边缘。比如我的设置中，我无法向 Synergy 正确描述我 PC 的位置。从而不能使得跨机器的使用完全符合直觉。</li>
<li><strong>音频</strong>：由于盖上盖子的 MacBook Pro 发出的声音很奇怪会破音。而几块屏幕的声音几乎就是只能用「听个响」来形容，所以需要外接一个音响。同时 PC 和 MacBook Pro 的音频不能在同一个音响输出。我试图使用 3.5mm音频线一分二母 立体声音频转接线，但实际上还存在一点问题，仍然在解决中。</li>
</ul>
<h3 id="以后的搭建"><a href="#以后的搭建" class="headerlink" title="以后的搭建"></a>以后的搭建</h3><p>由于这些都是在我卧室床头搭建的，以满足我起床就能写代码，写累了就睡的要求。当然我还购买了一把没有腿的椅子，这样我能长时间坐在床上而不至于腰背疼痛。那么既然是卧室，还需要点娱乐设施。所以打算把窗帘拆了改装成投影幕，加装投影仪供 PS4 使用，在 120 英寸的屏幕上畅玩 PS4。目前仍然在筹划中，如果搭建完了，会给大家分享相关的日志。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;为什么&quot;&gt;&lt;a href=&quot;#为什么&quot; class=&quot;headerlink&quot; title=&quot;为什么&quot;&gt;&lt;/a&gt;为什么&lt;/h3&gt;&lt;h4 id=&quot;为什么我一定要用-macOS？&quot;&gt;&lt;a href=&quot;#为什么我一定要用-macOS？&quot; class=&quot;headerlink&quot; title=&quot;为什么我一定要用 macOS？&quot;&gt;&lt;/a&gt;为什么我一定要用 macOS？&lt;/h4&gt;&lt;p&gt;这个问题需要放在一上来就被解释清楚，尤其当你发现这个 setup 的性价比其实非常低。然而这么设计自然有它存在的意义。首先，这和我的工作性质有关。我的日常开发同时涉及后端、前端和设计。尤其是我的后端围绕着 Ruby 展开。Ruby 的 native extensions 在 Windows 上不免没有那么好用，甚至在兼容性上有一些问题。使用一个 POSIX 兼容的操作系统是非常必要的。然而涉及前端的用户界面设计时，我还需要用到 Illustrator、Photoshop、Sketch 等一些软件。哪怕不使用 Sketch，剩下的软件也没有 Linux 的兼容版本。这使得 macOS 是我能避免频繁切换操作系统的唯一选择。&lt;/p&gt;
    
    </summary>
    
    
      <category term="日志" scheme="http://blog.heckpsi.com/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>从零开始 Ruby on PHP</title>
    <link href="http://blog.heckpsi.com/2016/06/11/ruby-on-php-abc/"/>
    <id>http://blog.heckpsi.com/2016/06/11/ruby-on-php-abc/</id>
    <published>2016-06-10T22:54:40.000Z</published>
    <updated>2016-06-10T23:08:11.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于什叶派-PHP-教徒"><a href="#关于什叶派-PHP-教徒" class="headerlink" title="关于什叶派 PHP 教徒"></a>关于什叶派 PHP 教徒</h3><p>PHP 早期的设计意图下整个语言都是模板驱动的。也就是说主要就是写个静态页面，在适当的需要动态的场合插入一些短小的 CGI 代码。然而逊尼派 PHP 教徒确认为 PHP 可以变成一门大而全的语言，摇身一变，强行又是 MVC 又是 MVC 的。各种框架层出不穷，抄完 Spring 又抄 Rails，甚至在一门模板驱动的语言中再搞一个模板渲染引擎。简直是异教。</p>
<h3 id="Ruby-on-PHP"><a href="#Ruby-on-PHP" class="headerlink" title="Ruby on PHP"></a>Ruby on PHP</h3><p>考虑到 Ruby 是一门强大的支持元编程的语言。很容易地我们能够将 Ruby 写成一门以模板来驱动的 CGI 语言。通过几行代码</p>
<a id="more"></a>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">require</span> <span class="string">'sinatra'</span></div><div class="line"></div><div class="line">get <span class="string">'/'</span> <span class="keyword">do</span></div><div class="line">  redirect <span class="string">'/index.php'</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">get /^\/(.*?)\.php$/ <span class="keyword">do</span> <span class="params">|c|</span></div><div class="line">  erb c.to_sym</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">post /^\/(.*?)\.php$/ <span class="keyword">do</span> <span class="params">|c|</span></div><div class="line">  erb c.to_sym</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>这样，只需要在 <code>./view</code> 下创建 erb 文件就可以当做 php 来写了，甚至连子目录都可以。<br>当然这样有一些小问题，比如，传进 erb 后连 request 来什么请求都不知道了。<br>所以我们可以稍作修改。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">require</span> <span class="string">'sinatra'</span></div><div class="line"></div><div class="line">get <span class="string">'/'</span> <span class="keyword">do</span></div><div class="line">  redirect <span class="string">'/index.php'</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">get /^\/(.*?)\.php$/ <span class="keyword">do</span> <span class="params">|c|</span></div><div class="line">  erb c.to_sym, <span class="symbol">locals:</span> &#123;<span class="symbol">request:</span> request&#125;</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">post /^\/(.*?)\.php$/ <span class="keyword">do</span> <span class="params">|c|</span></div><div class="line">  erb c.to_sym, <span class="symbol">locals:</span> &#123;<span class="symbol">request:</span> request&#125;</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>这样我们就有了一切 request 的数据了。自己在里面继续二次处理就是了。</p>
<h3 id="模板渲染"><a href="#模板渲染" class="headerlink" title="模板渲染"></a>模板渲染</h3><p>erb 模板是有趣的，但是像 PHP 那样一次性插十几行代码就不是很方便了。其实 erb 里也有这样的方法，只是 deprecated 而已。<br><figure class="highlight erb"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">  &lt;%<span class="ruby"></span></div><div class="line">    puts <span class="string">'foo'</span></div><div class="line">    puts <span class="string">'bar'</span></div><div class="line">  %&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure></p>
<p>然而问题来了，erb 里并不支持 echo 那样的命令。这样我们没法在一坨 Ruby 代码中输出某个东西到网页。<br>但是，Rails 里的 ActionView 不是支持 concat 吗？那么我们稍稍用点元编程的技巧，支持一下 echo 咯。<br>所以我们得到了最终代码<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># This is yet another PHP project</span></div><div class="line"><span class="keyword">require</span> <span class="string">'sinatra'</span></div><div class="line"><span class="keyword">require</span> <span class="string">'action_view'</span></div><div class="line"></div><div class="line">lookup_context = ActionView::LookupContext.new(<span class="string">'./views'</span>)</div><div class="line">lookup_context.cache = <span class="literal">false</span> <span class="keyword">if</span> development?</div><div class="line">view_context = ActionView::Base.new(lookup_context)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">module</span> <span class="title">ActionView::Helpers::TextHelper</span></span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">echo</span><span class="params">(string)</span></span></div><div class="line">    output_buffer &lt;&lt; string</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">get <span class="string">'/'</span> <span class="keyword">do</span></div><div class="line">  redirect <span class="string">'/index.php'</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">get /^\/(.*?)\.php$/ <span class="keyword">do</span> <span class="params">|c|</span></div><div class="line">  view_context.render(<span class="symbol">file:</span> c, <span class="symbol">locals:</span> &#123;<span class="symbol">request:</span> request&#125;)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">post /^\/(.*?)\.php$/ <span class="keyword">do</span> <span class="params">|c|</span></div><div class="line">  view_context.render(<span class="symbol">file:</span> c, <span class="symbol">locals:</span> &#123;<span class="symbol">request:</span> request&#125;)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>我们也能在 erb 里愉快地 echo 了<br><figure class="highlight erb"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">  &lt;body&gt;</div><div class="line">    Proudly Powered By </div><div class="line">    &lt;br&gt;</div><div class="line">  &lt;%<span class="ruby"></span></div><div class="line">    echo <span class="string">'PHP'</span></div><div class="line">  %&gt;</div><div class="line">  &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<h3 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h3><p>根据上面的做法，我们把 Ruby 变成了一门什叶派 PHP 心目中 PHP 本该有的样子了。<br>顺便还带来了一点副作用那就是，Wappalyzer 把这个项目完全当做 PHP 项目了。<br>假如黑客试图用 PHP 的漏洞来攻击你，就等着看好戏吧。诶嘿~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;关于什叶派-PHP-教徒&quot;&gt;&lt;a href=&quot;#关于什叶派-PHP-教徒&quot; class=&quot;headerlink&quot; title=&quot;关于什叶派 PHP 教徒&quot;&gt;&lt;/a&gt;关于什叶派 PHP 教徒&lt;/h3&gt;&lt;p&gt;PHP 早期的设计意图下整个语言都是模板驱动的。也就是说主要就是写个静态页面，在适当的需要动态的场合插入一些短小的 CGI 代码。然而逊尼派 PHP 教徒确认为 PHP 可以变成一门大而全的语言，摇身一变，强行又是 MVC 又是 MVC 的。各种框架层出不穷，抄完 Spring 又抄 Rails，甚至在一门模板驱动的语言中再搞一个模板渲染引擎。简直是异教。&lt;/p&gt;
&lt;h3 id=&quot;Ruby-on-PHP&quot;&gt;&lt;a href=&quot;#Ruby-on-PHP&quot; class=&quot;headerlink&quot; title=&quot;Ruby on PHP&quot;&gt;&lt;/a&gt;Ruby on PHP&lt;/h3&gt;&lt;p&gt;考虑到 Ruby 是一门强大的支持元编程的语言。很容易地我们能够将 Ruby 写成一门以模板来驱动的 CGI 语言。通过几行代码&lt;/p&gt;
    
    </summary>
    
    
      <category term="Ruby" scheme="http://blog.heckpsi.com/tags/Ruby/"/>
    
      <category term="PHP" scheme="http://blog.heckpsi.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>Google 的终极目标是天网</title>
    <link href="http://blog.heckpsi.com/2016/05/19/google-io-2016-review/"/>
    <id>http://blog.heckpsi.com/2016/05/19/google-io-2016-review/</id>
    <published>2016-05-19T13:19:17.000Z</published>
    <updated>2016-05-19T13:30:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引"><a href="#引" class="headerlink" title="引"></a>引</h3><p>Google I/O 2016 的 Keynote 部分结束后，各大媒体总会开始进行报道。然而作为一项面向开发者的活动，一般媒体都将其当作产品发布会来报道，以至于通篇流水账，完全不知所云。我今年是在桂林路的 GDG Shanghai Launchpad 和许多人一起观看了 Google I/O 2016 的直播。报名人数远超预期，导致场馆拥挤不堪，说实话，我甚至只能看半个屏幕。好在我英语听力水平不次，回来又看了一遍重播，对于 Google 在这次 Keynote 中想表达的大概有了清晰的认识。</p>
<a id="more"></a>
<h3 id="Google-的机器学习能力有多深？"><a href="#Google-的机器学习能力有多深？" class="headerlink" title="Google 的机器学习能力有多深？"></a>Google 的机器学习能力有多深？</h3><p>Google 在这次会议上确实是以「产品」作为支撑发布会结构的。但是 Google Home, Google Assistant, Allo 再到 SyntaxNet，Google 在试图表达的重要观点是他们在机器学习，特别是自然语义处理（Netural Language Processing, NLP）上绝对过人的天赋。</p>
<p>要说人工智能，不得不提到 Allan Turing 在 1950 年发表的论文<a href="http://loebner.net/Prizef/TuringArticle.html" target="_blank" rel="external">「COMPUTING MACHINERY AND INTELLIGENCE」</a>，机器计算和智能。在这篇论文中，Allan Turing 革命性提出了 <strong>人工智能</strong> 的判断标准，也就是所谓 <strong>图灵测试</strong>。在这篇论文中，图灵特意举出了一些机器在做智能时需要克服的点，尤其是机器需要对上下文拥有智能。</p>
<p>Google Now 的进化版本，Google Assistant 就拥有上下文的智能。你可以先问「这附近有什么好吃的意大利菜吗？」「能预定后天去这家餐厅吗？」「能告诉 Allen 一起来吗？」Google Assistant 具有理解上下文的能力，所以它知道你说的这家餐厅是上文中由 Google 推荐的意大利菜餐厅，以及你希望通知给 Allan 的是你想约他去这家餐厅在后天吃饭的事情。这就是不可多得的上下文理解能力，它并不是受限于实际规定好的语音助手对话的思路，而是完全基于其对自然语义的理解。</p>
<p>拥有了对上下文理解的神奇能力，Google 自然可以做更多。除了终端形态的 Google Home 以外，Allo 其实是 Google Assistant 的进阶产品。有些国内媒体报道说 Allo 是 Google 向社交领域的又一次新的尝试，这绝对是无中生有的事情，Google 可从来没有这么说过。拥有了上下文理解的能力，Google 可以依据上下文为你的回复提出建议，从而使你处理消息的效率得到空前的提高。至于 Due 的视频聊天、可以变化的聊天框之类的，不过是丰富产品功能，而不是发布一个原型的点睛之笔而已。</p>
<p><strong>Google Assistant 是 Siri 的竞品吗？你就胡扯吧，Google Assistant 是 Skynet 的竞品。</strong></p>
<p>Google 今天拥有了任何其他互联网公司都难以匹敌的机器学习的能力，Google 现在所作的，就是将这种空前的智能，尽可能多地运用到 Google 的产品中。这是这场 I/O 大会上，花最大篇幅讲的事情。</p>
<h3 id="VR-需要怎样的生态？"><a href="#VR-需要怎样的生态？" class="headerlink" title="VR 需要怎样的生态？"></a>VR 需要怎样的生态？</h3><p>Google Daydream 的提出不是孤立的，它是 Android N 的一部分，大可不能孤立来看。VR 设备对于渲染的要求是空前的，对于相同场景的渲染，其算力的要求几乎是数倍于传统 3D 应用的。所以我们见到 VR 设备通常需要一台性能强大的主机作为其算力的提供。手机能作为 VR 的运算显示设备吗？</p>
<p>首先，为什么要用手机作 VR 的运算显示设备。在今天，VR 还没有广泛普及，更实际的情况是，大多数人都没有体验过 VR 的神奇。VR 设备昂贵的价格注定了它推广和铺货难度极高。在三年前的 Google I/O 大会上 Google 拿出的 Cardboard 将 VR 的成本一下子降低到了一个极低的程度，中国现在销售的大多数 VR 设备，无疑就是 Cardboard，以及基于 Cardboard 设计修改的延伸产品。</p>
<p>但 Cardboard 的体验无疑是比较差的，受限于手机的算力，手机的 VR 场景过于简单。Google 所构想的手机 VR 是「可用于体验」的，而不是「存在于技术」的。作为一家软件公司，Google 所作的是支持 Vulkan API 大幅提高渲染性能、新的 JIT 编译器大幅提高运算性能、提出硬件标准给予参考。而这三者都囊括在了 Android N 的更新之中。</p>
<p>硬件 -&gt; API -&gt; 应用 的完整生态由 Google 所构建。没有便于开发的 API，大多数开发者都没有足够的性能优化能力。没有合适的硬件标准，那么硬件厂商也只会随心所欲地设计而不能兼容。Google 所作的比起国内大多数 VR 公司想得都清楚和明白得多，而 Google 也有这个技术能力去实现它。</p>
<h3 id="Android-N"><a href="#Android-N" class="headerlink" title="Android N"></a>Android N</h3><p>Android N 还有一些其它关键的点。Google 这次 N Preview 提出得非常早，现在又放出给 N 的开发代号起名字的活动。以及这次放出的 Android Wear 2.0 的系统，我们可以看成 Android Wear N 的版本。其实际是希望开发者参与到 Android N 的开发中来，由开发者的实际使用来进化 Android N 的 API 设计。Android N 从某种角度就是微软的 Windows 10，一个由社区推动，不断更新的操作系统。不过好在 Google 似乎对于品控非常在意，就目前的测试版来看，也不至于存在那么多 bug。也避免新版本系统对应用适配存在问题。</p>
<p>另一方面 Android N 与 Android Studio 的新更新结合非常紧密。Android Studio 所提出的 Instant Deploy，也就是在测试程序时，通过分析修改了的部分的代码，部分更新程序而不必整个重新运行，大大方便了软件开发过程中调试的过程。而利用这种部分更新的特性，Google 这次也带来了可以即时运行的程序，让 App 的体验省去了下载的步骤。虽然是细微的变化，但带来的用户体验的提升是非常好的，同时也证明了 Google Android Studio 的开发与 Android Platform 的开发步调一致。</p>
<h3 id="后"><a href="#后" class="headerlink" title="后"></a>后</h3><p>Google 这次通过 Google I/O 所展示的，并不是一个个孤立的产品。其实所要展示的是 Google 产品之间的联系、生态，以及 Google 在这些产品背后的技术实力。这种贯穿始终的硬实力，是任何一家国内靠情怀、贬低友商、炒股票和耍猴为生的国内互联网厂商所根本无法达到的。看起来相似的演说、场地和产品发布，其背后的深度实在是大为不同。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引&quot;&gt;&lt;a href=&quot;#引&quot; class=&quot;headerlink&quot; title=&quot;引&quot;&gt;&lt;/a&gt;引&lt;/h3&gt;&lt;p&gt;Google I/O 2016 的 Keynote 部分结束后，各大媒体总会开始进行报道。然而作为一项面向开发者的活动，一般媒体都将其当作产品发布会来报道，以至于通篇流水账，完全不知所云。我今年是在桂林路的 GDG Shanghai Launchpad 和许多人一起观看了 Google I/O 2016 的直播。报名人数远超预期，导致场馆拥挤不堪，说实话，我甚至只能看半个屏幕。好在我英语听力水平不次，回来又看了一遍重播，对于 Google 在这次 Keynote 中想表达的大概有了清晰的认识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Google" scheme="http://blog.heckpsi.com/tags/Google/"/>
    
      <category term="Google I/O" scheme="http://blog.heckpsi.com/tags/Google-I-O/"/>
    
  </entry>
  
  <entry>
    <title>一款祖传的机械键盘</title>
    <link href="http://blog.heckpsi.com/2016/05/14/customized-machanical-keyboard/"/>
    <id>http://blog.heckpsi.com/2016/05/14/customized-machanical-keyboard/</id>
    <published>2016-05-14T08:31:15.000Z</published>
    <updated>2016-05-15T03:20:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引"><a href="#引" class="headerlink" title="引"></a>引</h2><p>去年的时候就打算购买一款 60% 键盘以方便日常携带。时值开源哥在搞团购 Vim 布局的机械键盘的订购，就订了一把，结果由于一些原因，这单子被取消了。于是我就购买了一把 HHKB pro 2 静电容键盘。虽然说 HHKB 的键位设置和跳线的设计携带起来非常好，但是缺乏段落感的按键还是让人没有那种敲打起来的爽快感。于是我就打算客制化一把机械键盘来满足这个要求。</p>
<a id="more"></a>
<h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><p>如果要说 60% 的客制化套件的话，主要还是以 GH60 以及其延伸的一系列板子为主。开源哥之前推荐我使用 NerD60 的板子，可惜这块板子在国内并不容易买到。</p>
<p>轴体的选择使用了相对非常激进的 Cherry 绿轴，比起青轴，同样拥有二段式设计的绿轴的压力克数更高（clerk 声也更响），敲击感非常强，反馈非常明确，当然，对于害怕吵到其他人的话，这轴显然不是一个好选择。</p>
<p>键帽使用了三种颜色搭配的 PBT 无刻键帽，主要是因为现成的刻字键帽来说，显然是无法印刷修改非常严重的自定义按键的，而定制刻字的 PBT 键帽成本又太高，索性也就选择了无刻。</p>
<p>虽然阳极氧化铝的底座轻便又质感十足，通常是首选。不过既然作为一款码农世家祖传的键盘，最终选择了相对来说观感上更有冲击力的红花梨木底座。其余配置见下表：</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>选料</th>
</tr>
</thead>
<tbody>
<tr>
<td>主板</td>
<td>GH60 (Rev.CHN)</td>
</tr>
<tr>
<td>轴体</td>
<td>Cherry 绿轴</td>
</tr>
<tr>
<td>键帽</td>
<td>PBT 无刻（红色、灰色、白色）</td>
</tr>
<tr>
<td>LED</td>
<td>白色</td>
</tr>
<tr>
<td>定位板</td>
<td>黑色阳极氧化铝上色</td>
</tr>
<tr>
<td>底座</td>
<td>红花梨木</td>
</tr>
<tr>
<td>USB</td>
<td>LINDY Mini-USB</td>
</tr>
</tbody>
</table>
<p>由于我这个烙铁苦手，就上淘宝找了一家常州的 <a href="https://yikewaishe.taobao.com/shop/view_shop.htm?user_number_id=134583372" target="_blank" rel="external">厂家</a>（并没有广告关系，也没有肮脏的交易），对方当天就组装完发货，第二天一大早竟然就送到了。于是拿到手后就进入了修改固件，修改键位的过程了。</p>
<p>到手的货物长这样：</p>
<p><img src="http://cdn.heckpsi.com/keyboard-2.jpg" alt=""></p>
<p><img src="http://cdn.heckpsi.com/keyboard-1.jpg" alt=""></p>
<h2 id="固件"><a href="#固件" class="headerlink" title="固件"></a>固件</h2><p>客制化键盘的一大好处就是客制化的按键配列，这一点在 60% 和 40% 的键盘上非常重要。我结合我之前 HHKB 的使用经验，我就大致设计了一个如下的配列：</p>
<p><img src="http://cdn.heckpsi.com/keyboard_5.png" alt=""></p>
<p>（其中左前方的按键为 Fn 组合键，右前方的是 Fn1 组合键）</p>
<p>然而客制化固件的刷入还有一些问题。首先这板子是 Rev.CHN 的，一上来刷入就失败了好几次。直到看到了大鹰的 <a href="https://bigeagle.me/2015/07/gh60/" target="_blank" rel="external">这篇文章</a>（没想到大鹰去年也参了开源哥的团，后来也从同一个卖家手里组装了键盘）。</p>
<p>当然这之前我找到了一个简便的选择 <a href="http://www.enjoyclick.org/tkg/#help" target="_blank" rel="external">TKG Keypad Generator</a>，它能自动生成 avr 单片机的 eep 文件，理论上可以直接刷入。但是我刷入之后无法正常引导键盘，所以还是需要使用 <a href="https://github.com/kairyu/tmk_keyboard_custom" target="_blank" rel="external">tmk-keyboard-custom</a> 自己编译刷入（<code>git clone</code> 的时候切记加入 <code>recursive</code> 参数，因为核心模块以 <code>submodule</code> 的形式出现在这个 <code>repository</code> 中）。不过还是可以使用 TKG Keypad Generator 所生成的 c 语言代码，稍作修改进行编译即可。</p>
<p>首先把生成的文件命名成 <code>keypad_xxx.c</code> 文件，<code>xxx</code> 为你配列自己的命名。不过直接刷入似乎会遇到一些编译问题，需要在文件后加入如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> KEYMAP_IN_EEPROM_ENABLE</span></div><div class="line"><span class="keyword">uint16_t</span> keys_count(<span class="keyword">void</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">sizeof</span>(keymaps) / <span class="keyword">sizeof</span>(keymaps[<span class="number">0</span>]) * MATRIX_ROWS * MATRIX_COLS;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">uint16_t</span> fn_actions_count(<span class="keyword">void</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">sizeof</span>(fn_actions) / <span class="keyword">sizeof</span>(fn_actions[<span class="number">0</span>]);</div><div class="line">&#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<p>然后按下键盘背后的 dfu 按钮，使用命令行指令刷入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">make KEYPAD=xxx</div><div class="line">make KEYPAD=xxx dfu</div></pre></td></tr></table></figure>
<p>刷入后拔掉 USB 线，按住 BackSpace + Space，插入线缆，3 秒后放掉按键刷新 EEPROM 后，新配列即可工作。</p>
<p>然后我发现我设计的三个多媒体用途的键中，只有暂停键是可用的，上一首和下一首都不能正常工作，仔细研究后才发现 Mac 机器的上一首和下一首的 KeyCode 和 PC 略有区别，修改后重新编译了固件，按键都能正常工作了。</p>
<h2 id="后"><a href="#后" class="headerlink" title="后"></a>后</h2><p>当然这块键盘有哪些不满意的地方呢，还是有的。一个问题是右上角的大按键如果拆成两个小按键，对于 <code>BackSpace</code> 和 <code>\</code> 的设计会变得方便更多，这个实在定位板的选择上出了一些问题。</p>
<p>另一个就是白色的 LED 灯，哪怕是最低亮度也能轻易地透过白色的按键却无法透过别的按键，这使得这个灯的开启变成了一个比较尴尬的问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引&quot;&gt;&lt;a href=&quot;#引&quot; class=&quot;headerlink&quot; title=&quot;引&quot;&gt;&lt;/a&gt;引&lt;/h2&gt;&lt;p&gt;去年的时候就打算购买一款 60% 键盘以方便日常携带。时值开源哥在搞团购 Vim 布局的机械键盘的订购，就订了一把，结果由于一些原因，这单子被取消了。于是我就购买了一把 HHKB pro 2 静电容键盘。虽然说 HHKB 的键位设置和跳线的设计携带起来非常好，但是缺乏段落感的按键还是让人没有那种敲打起来的爽快感。于是我就打算客制化一把机械键盘来满足这个要求。&lt;/p&gt;
    
    </summary>
    
    
      <category term="键盘" scheme="http://blog.heckpsi.com/tags/%E9%94%AE%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>当今计算机教学的普遍问题</title>
    <link href="http://blog.heckpsi.com/2016/04/24/problems-of-it-textbooks-now/"/>
    <id>http://blog.heckpsi.com/2016/04/24/problems-of-it-textbooks-now/</id>
    <published>2016-04-23T17:10:44.000Z</published>
    <updated>2016-04-23T17:53:03.000Z</updated>
    
    <content type="html"><![CDATA[<p> 今天的计算机行业，特别是互联网行业，又一次成为了人人谈论的朝阳产业，越来越多的人希望加入到这个行业里。但是，不得不指出的是，计算机科学，作为一门工程与科学相结合的学科，并没有任何捷径可走。任何人，如果想在这个行业中哪怕是进入一个平均水平，也需要系统地进行学习。</p>
<p>越来越多的人渴望得到计算机科学上的教学，但同时，计算机行业又在以一个非常快速的方式在发展和进步着。每年、每个月甚至是每天，都能见到一些令人兴奋的新特性、新技术的产生。不得不说，今天的计算机教学，很大程度上，与计算机行业的发展已经拖了钩。任何一门课程、教科书都无法及时跟上最新技术发展的脚步，成为了新人进入行业很大的阻碍。</p>
<a id="more"></a>
<p>如果一位老师，从事计算机教学，却不从事实际的开发工作，那么他的技术栈也将很快落后于行业。这意味着，我们无法像过去那样，通过专业的「师范」教学，培养优秀的计算机科学教师。落后的教学内容很可能是「无用的」或者用处「极少的」，因为他们通常会在一些已经被解决的问题上浪费太多的时间。而更要命的是一些教学不只是「无用的」，甚至可能是「有害的」。</p>
<p>从标准被制定到采纳并应用于某项技术中需要多久？在今天社区协同的环境下，这些事情的发生有时只要几天。当一项实用的新技术被加入进来后，到教科书的再版需要多久？从再版到教师去学会了这些内容，并能将其教授给学生需要多久？如果这时间花费很长，那么很可能就会教出很多无用的内容。然而相反，从标准被废除到采纳并应用于某项技术中需要多久？废除后能写进教科书再版需要多久？而教师学会并能教授又需要多久？如果这个步骤时间很长，那么，教授的内容就更是「有害的」了。</p>
<p>更何况，人非圣贤孰能无过。编写教科书的人以及教师的编程经历本身都会影响其对技术的理解。几乎每个老师都难免在教授过程中出现错误。BASIC 出身的谭浩强老师的《C 语言程序设计》整本书仿佛都写着「错误」两字，却依然能走进我国大多数的大学课堂。这样的例子数不胜数，我们无法估量这背后的影响有多大。</p>
<p><strong>落后、无用、有害，能够从根本上被改变吗？</strong></p>
<p>如果要回答如何缩短技术的更新到教科书更新的时间，我们不妨先问这样一个问题：为什么互联网技术更新如此迅速呢？其答案是互联网技术本身。基于互联网、社区的协同办公，使得一项技术得到社区的普遍认同变得前所未有的迅速。然而教科书在今天，依然还是依赖于传统的编写、审稿、出版的步骤。为什么我们不能依赖互联网技术本身、依赖社区，来编写教科书呢？</p>
<p>这样操作甚至能带来一个连带的作用，那就是，利用社区的力量来减少教科书中出现错误的可能性。谭浩强老师的《C 语言程序设计》整本书仿佛都写着「错误」两字，但正是由于广泛的使用，几乎每个错误你都能在网上找到。但如果社区从编写教科书时就参与，是不是错误能从教科书中就被直接删除呢？</p>
<p>今天，长期关注于计算机教学领域的 HeckPsi 将启动全新的实验性项目<a href="http://edu.heckpsi.com" target="_blank" rel="external">「HeckPsi Education」/「HeckPsi 公开课」</a> —— 一个依赖于社区进行的免费、开源、实时的教科书计划。一个社区中的每个人都能参与新建、更新、修正教科书的计划，它让教学变得前所未有地与时俱进。而 HeckPsi 从中扮演的角色，仅限于审核的工作。在未来数日内，HeckPsi 将逐步公开社区参与的具体流程，我们希望这次试验能使得计算机科学的教学迈上真正的计算机时代。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 今天的计算机行业，特别是互联网行业，又一次成为了人人谈论的朝阳产业，越来越多的人希望加入到这个行业里。但是，不得不指出的是，计算机科学，作为一门工程与科学相结合的学科，并没有任何捷径可走。任何人，如果想在这个行业中哪怕是进入一个平均水平，也需要系统地进行学习。&lt;/p&gt;
&lt;p&gt;越来越多的人渴望得到计算机科学上的教学，但同时，计算机行业又在以一个非常快速的方式在发展和进步着。每年、每个月甚至是每天，都能见到一些令人兴奋的新特性、新技术的产生。不得不说，今天的计算机教学，很大程度上，与计算机行业的发展已经拖了钩。任何一门课程、教科书都无法及时跟上最新技术发展的脚步，成为了新人进入行业很大的阻碍。&lt;/p&gt;
    
    </summary>
    
    
      <category term="站务" scheme="http://blog.heckpsi.com/tags/%E7%AB%99%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>HeckPsi 2016 全新博客系统</title>
    <link href="http://blog.heckpsi.com/2016/04/21/heckpsi-blog-2016/"/>
    <id>http://blog.heckpsi.com/2016/04/21/heckpsi-blog-2016/</id>
    <published>2016-04-21T14:56:14.000Z</published>
    <updated>2016-04-21T15:36:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>HeckPsi 博客 2016 迎来了巨大的改版！</em></strong></p>
<a id="more"></a>
<h3 id="这是个啥？"><a href="#这是个啥？" class="headerlink" title="这是个啥？"></a>这是个啥？</h3><p>正如你所见，HeckPsi 的全新博客系统变得非常地 <em>清新</em> 。在深思熟虑之后，我们发现，以前的主页，看似非常炫酷，实则净是废话。于是借由 HeckPsi 主页改版的机会，HeckPsi 博客系统也迎来了巨大的更新！</p>
<h4 id="这个博客用来干什么？"><a href="#这个博客用来干什么？" class="headerlink" title="这个博客用来干什么？"></a>这个博客用来干什么？</h4><ol>
<li>发布对于业内见闻的评论</li>
<li>发布对科技相关的科普</li>
<li>发布我们所坚持的价值观</li>
<li><del>瞎搞</del> 实验性内容</li>
</ol>
<h4 id="所以，我们的博客需要什么"><a href="#所以，我们的博客需要什么" class="headerlink" title="所以，我们的博客需要什么"></a>所以，我们的博客需要什么</h4><ol>
<li>清晰高效的排版</li>
<li>便于快速编辑（Markdown 什么的最好，可视化编辑器太累）</li>
<li>静态化的页面</li>
</ol>
<p>于是就有了现在你所看到的博客系统。它使用了 <a href="https://github.com/hexojs/hexo" target="_blank" rel="external">hexo</a> 项目生成静态页面，以及使用了 <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank" rel="external">hexo-theme-apolo</a> 项目的主题，并进行了一定地定制开发。</p>
<p>相比之下，我们拥有了更加强大地对网站的控制权利，可以做更多地功能模块的定制，以进一步满足我们未来的要求。至于为什么没有使用 <a href="https://jekyllrb.com/" target="_blank" rel="external">Jekyll</a> ，单纯是因为 hexo 更适合做博客，而 Jekyll 什么都适合做，有些无从下手。</p>
<h3 id="停更的几个月发生了啥？"><a href="#停更的几个月发生了啥？" class="headerlink" title="停更的几个月发生了啥？"></a>停更的几个月发生了啥？</h3><p>首先，HeckPsi 成立了在国内注册的公司，并以此申请了备案。所以我们的服务器现在可以运行在中华人民共和国境内，以提供更快的服务。</p>
<p>其次，我们深刻考虑了我们未来的业务形态。最近也将会有比较大的动向，开出某个全新的板块，以及某些神秘的产品，尽请期待。</p>
<p>最后就是旧博客的数据之前放在 AWS Japan 上，出了一些小问题，差点丢失。幸好已经通过完备的日志系统还原了大部分数据，并且将于近期还原。未来我们的博客数据都会实现多点异地备份，保证其安全性。</p>
<p><strong>承蒙各位厚爱，HeckPsi 会坚持做下去。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;HeckPsi 博客 2016 迎来了巨大的改版！&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="站务" scheme="http://blog.heckpsi.com/tags/%E7%AB%99%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>认识 Y-Combinator</title>
    <link href="http://blog.heckpsi.com/2016/03/19/learn-y-combinator/"/>
    <id>http://blog.heckpsi.com/2016/03/19/learn-y-combinator/</id>
    <published>2016-03-19T00:50:00.000Z</published>
    <updated>2016-04-21T16:34:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在开始"><a href="#写在开始" class="headerlink" title="写在开始"></a>写在开始</h2><p>不得不说，当我开始学习函数式编程的时候，我并没有被匿名函数感到害怕，理解它的基本概念是极其容易的。但是当你试图去将你日常所书写的指令式的代码转换成函数式，特别是纯函数式的时候，你会感到这是不可能的。它和你之前的编程思想是完全脱离的。</p>
<p>所以当我第一次见到 Y-Combinator（Y 组合子）的时候，我的感觉是懵逼的，这是什么玩意。然而当我一步一步，了解这个东西是什么，它是怎么工作的之后，我对函数式编程的认识有了很大的进步。</p>
<p>即使是 C++ 这样的语言，也在 C++11 标准中引入了匿名函数，使得你有机会在 C++ 中使用函数式编程的特性。在编程中，如果能适当地使用函数式语法进行编程，将非常有助于你写出一些更好理解、更简单的代码。</p>
<p>而在了解一些基本概念之后，了解一下 Y-Combinator 是一个极好的选择，这个东西证明了函数式编程对递归的语义理解，证明了其在递归上和指令式编程的等价之处。你可以通过观察等价的这两者的不同的实现方式，来加深对这两者思想的认识。</p>
<a id="more"></a>
<h2 id="与指令式编程的根本区别"><a href="#与指令式编程的根本区别" class="headerlink" title="与指令式编程的根本区别"></a>与指令式编程的根本区别</h2><p>大家看下面一段 C 代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</div><div class="line">  <span class="built_in">puts</span>(<span class="string">"Hello World"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>显然这是一个非常常见的循环。然而这样的循环显然已经被抽象过了，我们也许可以用一个更原始的方法来实现。且让我引入一个 C 开发中应尽量避免的语句 <code>goto</code> 来解释。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">loop:</div><div class="line"><span class="keyword">if</span> (i &gt;= <span class="number">100</span>) <span class="keyword">goto</span> next;</div><div class="line"><span class="built_in">puts</span>(<span class="string">"Hello World"</span>);</div><div class="line">i++;</div><div class="line"><span class="keyword">goto</span> loop;</div><div class="line">next:</div></pre></td></tr></table></figure>
<p>这两段代码除了变量 <code>i</code> 的作用域有所区别以外几乎是等价的。相对的，第二段代码非常接近于编译到汇编时的指令，几乎是一一映射的。然而你可以发现，我们的循环都是依赖于跳转代码行数的，不得不说这种写法非常不函数式。</p>
<h2 id="第一个函数"><a href="#第一个函数" class="headerlink" title="第一个函数"></a>第一个函数</h2><p>我们可以用一个递归来把这个循环实现地更像一个函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">loop</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  <span class="built_in">puts</span>(<span class="string">"Hello World"</span>);</div><div class="line">  <span class="keyword">return</span> loop(n - <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line">loop(<span class="number">100</span>);</div></pre></td></tr></table></figure>
<p>虽然这个函数是倒过来循环的，但我们大可忽略这些细节，毕竟要做修改也是相对容易的。我们通过一个函数递归的方式来实现了一个循环。需要特别注意的是，如果根据递归的定义，那么这个循环一旦大起来在今天我们的计算机的计算模型（而不是 Lisp Machine）上是会爆栈的，但好在由于是个尾递归，通常是会直接被编译器优化成一个循环的。这确保了即使你写的是函数式代码，也可以最终编译成适合 CPU 运算的形式而不太影响性能。</p>
<p>不过递归有一个问题，我们必须知道函数的名称才能这么做，在真正的 Lambda 运算模型上，函数是匿名的，也就是没有名字，这样你最后根本就无处调用你函数自己。因为你无法写出下面的代码（Ruby）：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">lambda &#123; <span class="params">|n|</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">if</span> n == <span class="number">0</span></div><div class="line">  puts <span class="string">"Hello World"</span></div><div class="line">  what_the_f**k_my_function_name_is(n-<span class="number">1</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="魔法少女-Lambda-酱"><a href="#魔法少女-Lambda-酱" class="headerlink" title="魔法少女 Lambda 酱"></a>魔法少女 Lambda 酱</h2><p>下面我们演示一种黑魔法，来使得你没有办法得到自己函数名时实现递归。简单来说就是把「函数」当成一个「参数」传输。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">loop = lambda &#123;<span class="params">|f, n|</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">if</span> n == <span class="number">0</span></div><div class="line">  puts <span class="string">"Hello World"</span></div><div class="line">  f.call(n-<span class="number">1</span>)</div><div class="line">  &#125;</div><div class="line">loop.call(loop, <span class="number">100</span>);</div></pre></td></tr></table></figure>
<p>我们把函数本身作为一个参数传了进去，达到了我们的想法。不过这里我们还不是一个完全的匿名函数，而是通过给匿名函数起了一个名字 <code>loop</code>，在外面调用了一下。不过事到如今，去掉这个 <code>loop</code> 已经很容易了。由于第一条的匿名函数定义中没有任何地方用到 <code>loop</code> 只在第二条指令中用到。我们只要将第二条指令中的所有 <code>loop</code> 都代换掉就行。我们就能得到下面的代码：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">lambda &#123;<span class="params">|f, n|</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">if</span> n == <span class="number">0</span></div><div class="line">  puts <span class="string">"Hello World"</span></div><div class="line">  f.call(n-<span class="number">1</span>)</div><div class="line">  &#125;.call(lambda&#123;<span class="params">|f, n|</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">if</span> n == <span class="number">0</span></div><div class="line">    puts <span class="string">"Hello World"</span></div><div class="line">    f.call(n-<span class="number">1</span>)</div><div class="line">    &#125;, <span class="number">100</span>)</div></pre></td></tr></table></figure>
<h2 id="柯里化，最后一步"><a href="#柯里化，最后一步" class="headerlink" title="柯里化，最后一步"></a>柯里化，最后一步</h2><p>Amazing！我们通过一个匿名函数的调用成功实现了一个 100 的循环。我们现在距离 Haskell Brooks Curry 先生当年推出 Y 组合子只差一步，那就是将我们做的事情「Currying」（柯里化）。所谓 Currying 就是使用一个高阶函数，将一个函数的多个参数精简成一个。我们看到我们现在的匿名函数还有 <code>f</code> 和 <code>n</code> 两个参数，我们打算拿掉它。虽然其实并不是真正意义上的拿掉。柯里化，只不过把一个形如 <code>f(x, y)</code> 的函数写成了 <code>f(x)(y)</code>，也就是 <code>f(x)</code> 的返回是一个匿名函数，而这个匿名函数再以 <code>y</code> 为参数执行一次。这么搞一下，我们就得到了：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">lambda &#123;<span class="params">|p|</span></div><div class="line">  <span class="keyword">return</span> lambda &#123; <span class="params">|f|</span></div><div class="line">    <span class="keyword">return</span> f.call(f);</div><div class="line">    &#125;.call(lambda &#123;<span class="params">|f|</span> </div><div class="line">      <span class="keyword">return</span> p.call(lambda &#123;<span class="params">|x|</span> </div><div class="line">        <span class="keyword">return</span> f.call(f).call(x)</div><div class="line">        &#125;)</div><div class="line">      &#125;)</div><div class="line">  &#125;.call(lambda &#123;<span class="params">|f|</span> </div><div class="line">    <span class="keyword">return</span> lambda &#123;<span class="params">|i|</span> </div><div class="line">      <span class="keyword">return</span> <span class="keyword">if</span> i == <span class="number">0</span>; </div><div class="line">      f.call(i-<span class="number">1</span>)</div><div class="line">      &#125;</div><div class="line">    &#125;).call(<span class="number">100</span>)</div></pre></td></tr></table></figure>
<p>由于柯里化后匿名函数和调用的参数都单一了，我们因此可以保证我们能将任意一个递归都表达成一个匿名函数的形式。按照 Lambda 演算的形式化表达  <code>Y := λf.(λx.(f (x x)) λx.(f (x x)))</code> 。你只要将自己要递归的函数替换掉里面 <code>f</code> 的位置，并最后执行一下这个匿名函数就成啦~</p>
<h2 id="折腾半天干什么"><a href="#折腾半天干什么" class="headerlink" title="折腾半天干什么"></a>折腾半天干什么</h2><p>你肯定想问，我们把一个循环写成这么复杂是为了什么。事实上我想展示的不是循环，而是递归。递归在图灵模型（我们通常 CPU 的计算模型）和丘奇模型（Lambda 演算）上都不是那么地原生的实现。</p>
<p>在图灵模型上地最终形式是每次递归，追加进内存中，并重新 <code>goto</code> 回函数开始，在退出时，再一步步内存推出来，并将递归的剩余部分执行完。</p>
<p>而在 Lambda 演算中，最终表达为一个逻辑系统构成的严格的数学函数模型的执行。</p>
<p>这两者便是具体化和形式化的极限，充分表现了两种模型的特点。从根本加深了对两种模型差异的认知，从而让我们在两种模型上都能通过正确的编程思想来写代码，以把代码写得更好。</p>
<p>当然也是有一些实际意义的，比如在变量作用域严格的语言中，且又必须使用匿名函数的形式来书写你所需要的东西的时候，而你正好又需要递归才能达到你的要求，那么使用 Y-Combinator 是一个可选的方法。然而通常，出现这种情况大多是你写了错误的思想的代码所导致的，实际编程中几乎遇不到这种情况，毕竟将更抽象更容易理解的函数式编程写成这么一坨一眼看不懂的代码是很失败的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在开始&quot;&gt;&lt;a href=&quot;#写在开始&quot; class=&quot;headerlink&quot; title=&quot;写在开始&quot;&gt;&lt;/a&gt;写在开始&lt;/h2&gt;&lt;p&gt;不得不说，当我开始学习函数式编程的时候，我并没有被匿名函数感到害怕，理解它的基本概念是极其容易的。但是当你试图去将你日常所书写的指令式的代码转换成函数式，特别是纯函数式的时候，你会感到这是不可能的。它和你之前的编程思想是完全脱离的。&lt;/p&gt;
&lt;p&gt;所以当我第一次见到 Y-Combinator（Y 组合子）的时候，我的感觉是懵逼的，这是什么玩意。然而当我一步一步，了解这个东西是什么，它是怎么工作的之后，我对函数式编程的认识有了很大的进步。&lt;/p&gt;
&lt;p&gt;即使是 C++ 这样的语言，也在 C++11 标准中引入了匿名函数，使得你有机会在 C++ 中使用函数式编程的特性。在编程中，如果能适当地使用函数式语法进行编程，将非常有助于你写出一些更好理解、更简单的代码。&lt;/p&gt;
&lt;p&gt;而在了解一些基本概念之后，了解一下 Y-Combinator 是一个极好的选择，这个东西证明了函数式编程对递归的语义理解，证明了其在递归上和指令式编程的等价之处。你可以通过观察等价的这两者的不同的实现方式，来加深对这两者思想的认识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Lambda" scheme="http://blog.heckpsi.com/tags/Lambda/"/>
    
      <category term="编程" scheme="http://blog.heckpsi.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Lisp" scheme="http://blog.heckpsi.com/tags/Lisp/"/>
    
  </entry>
  
  <entry>
    <title>AlphaGo 是怎么下棋的？</title>
    <link href="http://blog.heckpsi.com/2016/03/18/how-alphago-works/"/>
    <id>http://blog.heckpsi.com/2016/03/18/how-alphago-works/</id>
    <published>2016-03-18T15:09:00.000Z</published>
    <updated>2016-04-21T17:15:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本来其实不想写这个的，但是看到很多网友以及一些围棋职业选手提出了一些疑问，比如「Google 没有顶尖的棋手为什么能开发出顶尖的围棋机器人？」还有「机械为什么可以在如此直觉主导的游戏中战胜人类？」。这些问题事实上在人工智能领域已经有很多理论来做解释。而且这些理论也并不是 Google 提出的。AlphaGo 所使用的理论大多还是十余年前左右的论文的一些成果。在此之前，使用了这些理论开发出来的人工智能其实已经在 2006 年就已经在 9x9 的小棋盘上战胜周俊勋九段，之后在 2013 年 CrazyStone 程序就已经在让四子前提下战胜过石田芳夫九段，而就在去年，Facebook 的围棋机器人在不让子的前提下，胜过职业选手。至于之前「前百度深度学习研究院」的吴韧所开发的异构神机也使用的是类似的理论，也在前几天战胜过职业棋手。</p>
<p>这些方法上，AlphaGo 并无太大创新，很大程度上是 Google 团队实现得相对完善以及训练程度更好，以及人工智能算法的实现和调参存在很大的偶然因素。那么究竟是什么方法让机械拥有了和人一样直觉，而不是简单的机械化的思考。这事我们还是要从头讲起。</p>
<a id="more"></a>
<h2 id="无法计算的数据量"><a href="#无法计算的数据量" class="headerlink" title="无法计算的数据量"></a>无法计算的数据量</h2><p>早在 1996 年，IBM 的深蓝计算机就战胜了国际象棋世界名将加里·卡斯帕罗夫。但象棋有一个特点，那就是每一步下的选择是相对非常有限的，最多也就十几种可能。哪怕是通过最最暴力的搜索方法，把每种都跑一遍，搜索几十步内的最优解。虽然这个方法随着搜索深度是指数级增长的，但事实上由于底数比饺小，依靠强大的算力还是可以解决的。而深蓝计算机正是这么一台拥有强大算力的超级计算机。</p>
<p>然而在围棋上，这样就不行了，因为围棋每一步都有上百种选择，如此大的底数纯粹的暴力就显然无法满足了。至少硬件的发展并非每年成百倍成百倍地快速增长的。同样的方法，显然是不适合使用在围棋上的。</p>
<p>在 2002 年之前，人们长期研究一个可以通过计算静态地分析出每一子的价值出来。然而这个方法的发展一直很慢。直到人们试图尝试一种动态评估一个博弈的一种方法，这就是靠<strong>猜</strong>。这个方法被称为蒙特卡洛搜索树，其前身是非常著名的上世纪曼哈顿计划期间由乌拉姆和冯·诺依曼提出的<strong>蒙特卡洛方法</strong>。</p>
<p>如果我们想知道圆周率的值，我们如何利用猜的方法来猜出圆周率呢？我们只需要在一个方形中随机而均匀地扔飞镖，数一下，多少个飞镖扔在了以方形边长为直径的圆里，多少扔在了外面，根据圆的面积公式和方形的面积公式就能把 π 算出来。而蒙特卡洛搜索树就是利用蒙特卡洛方法来优化搜索树。简单来说，就是，我们认为这一步下在一个地方是最优的，而我们不知道这地方在哪里。我们先通过一系列随机的采样，从而去猜测一个值，这个值可能是最优解，也可能是一个接近最优解的解。但至少，这可以用来估算像围棋这样大的棋盘的东西了，而不需要把每个细枝末节都同等对待地来暴力搜索。</p>
<h2 id="⑨神的大局观"><a href="#⑨神的大局观" class="headerlink" title="⑨神的大局观"></a>⑨神的大局观</h2><p>解决完计算量的问题，我们还要来解决人类在围棋上最大的优势——直觉，或者说「大局观」。那么如何才能拥有大局观呢？我们想一下，人们在下围棋的时候，通常会先考虑下在哪个片区，以获得什么样的目的。而这就是所谓的大局观。</p>
<p>AlphaGo 的另一部分重要思想，得益于神经科学的发展，即人类认识人大脑神经的发展。人类愈发了解了大脑内神经元的工作模式，包括人类学习、认知的神经模型。这样的非常基础的模型，极大地方便了利用计算机来模拟人类进行学习的过程。</p>
<p>蒙特卡洛方法只是简化了计算，并不具备学习的能力。无论是单纯的蒙特卡洛搜索还是与 α-β 搜索结合的还是和置信区间结合一些版本，都与人类能越学越强的围棋技巧相比差上太多。至少，人脑是一个极其复杂的计算模型，哪怕是现在最好的计算机，其算力和整个大脑比起来还是差很多的。</p>
<p>在 2007 年，一些科学家试图提出一个新的机器学习模型，即所谓的深度学习。所谓深度学习，你可以看做模拟许多许多人脑中的神经元构成的一个网络。网络的每一层，针对一个特性进行识别。网络的每一层，都是一个单纯分类的无监督学习模型。你可以想像一下，人眼看到一个图像。经过一系列神经元，首先识别出了里面的眼睛、然后识别了里面的鼻子、嘴，再根据这些特性，发现这是一个人。这样依次发现的机制。而学习是通过一个有监督的反向传播进行。即告诉你这张图像里有一条狗，然后反向的一步步调整网络，让网络适应符合怎么样鼻子、嘴、眼睛的是一条狗。通过不断地数据的训练，即可以让模型越来越优。这个模型在图像识别领域已经达到甚至有时超越了人的识别能力。</p>
<p>而 AlphaGo 使用的就是深度学习来优化蒙特卡洛搜索树。在 AlphaGo 中有两个网络，一个是策略网络，一个是价值网络。策略网络即是一个大局观的网络，机器会先通过其经验，找出其应该做出进攻的反应还是防守的反应，表现在下在哪个片区是最为合适的，是不是应该跟棋之类的大问题。然后再通过蒙特卡洛搜索树去算出具体下在哪里是最合适的。</p>
<p>而我们说到，深度学习模型是真的和人一样可以学习的。每下一次棋，它就可以进一步调优自己的策略网络。首先 AlphaGo 导入了上千个职业选手对弈的棋谱，使得自己有了一个基础的下棋策略。这时候的 AlphaGo 就和一个受过系统训练的围棋少年一样了。然而这和职业选手的区别还是很大。这也就是所谓的「Google 没有顶尖的棋手为什么能开发出顶尖的围棋机器人？」按照一般常理，AlphaGo 应该一段一段地和人挑战，越发提高自己能力。然而 AlphaGo 不是这么做的，它选择和自己对弈。两台 AlphaGo 来对弈，将对弈的结果调优自己的网络。这个听起来很奇怪，为什么两个下得都不怎么样的棋手一起下棋，棋艺能那么快提升呢？因为它一天能和自己下上百万盘棋，它可以把自己分身成几万份跑在几万台电脑上，以及可以昼夜不停也不会过劳死，而这是任何一个人类都做不到的。AlphaGo 的开发人员说，他曾在早期能下赢 AlphaGo，而很快，AlphaGo 的水平就远超了他。所以 AlphaGo 得到了飞速的提升。仅仅五六个月，AlphaGo 就能从战胜欧洲棋王挑战到世界顶尖选手的水平了。</p>
<h2 id="人工智能的基本法"><a href="#人工智能的基本法" class="headerlink" title="人工智能的基本法"></a>人工智能的基本法</h2><p>当然搞人工智能也要有基本法。这个基本法就是算力或者说是资源。虽然做了很大的优化，计算下围棋的计算量还是很大的。比起深蓝时依靠超级计算机来解决问题。AlphaGo 选择了一条适合 Google 的路径来解决算力问题。那就是分布式计算。使用分布式计算的 AlphaGo 版本比起不使用的版本其智能程度也是有相当大的提升。即使最简单，它也可以有更多时间来做随机的尝试，以找出更优的价值解。</p>
<p>同样利用深度学习优化蒙特卡洛搜索的 Facebook 围棋团队，相比 Google 就没有那么壕力冲天了。无论是开发资源还是人员来说也是远少于 Google。Facebook 的围棋机器人之前也取得了相当好的成绩，大概可以击败职业二段选手的水平。但是比起 AlphaGo，还是差上许多。</p>
<p>所以说，做这么一个人智能，背后的投入程度、重视程度也起到了很大的作用。这也是为什么深度学习目前做得很好的公司大多是一些顶尖的 IT 企业里的研发团队。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>比起 AlphaGo 在围棋上的成就，其实大多数人很好奇人工智能未来的何去何从。从这次中，我们看到计算机已经具备了人类大局判断能力，其本质是类似于人类的学习能力，即不告诉电脑应该怎么做，而让电脑看人类是怎么做的。这项的应用其实相当广泛，尤其在非常复杂的问题上。</p>
<p>比如说，无人驾驶汽车之前发展很困难，是因为人们总是试图去把驾驶规则完全讲给电脑，而这点太过复杂，难以用纯逻辑说清。而今天 Google 的无人驾驶汽车也是使用的类似的深度学习的技术，让计算机观察人类开车并学习，从而模仿人类的判断。最终依靠计算机强大的算力和不会疲劳等特点，甚至超越人类的判断。</p>
<p>短期来看，利用深度学习的人工智能在未来数年内将会得到很大的应用。而这也是 Google 热衷于下围棋的原因。醉翁之意不在酒，在乎山水之间也。Google 只是想利用围棋来显示他们在深度学习应用上的先进水平。</p>
<p>就人工智能的最终目的来看，我们已经跨出了很大的一步。之前而言，我们很大程度局限于人类强大的抽象的思考能力，而模仿人类神经系统的模型已经很好地模拟了这种思考是怎么产生的了。进一步说，如果一个机器，拥有和人完全一样的眼睛、耳朵、鼻子、触觉等作为它的输入，以及类似于人类肌肉和关节的机械部件作为它的输出。并且模拟一个和人脑一样复杂程度的神经网络，并让它观察人类进行学习。是不是在某个未来，我们可以拥有和人类功能非常接近甚至超越人类的智能的出现。深度学习都为这样的强人工智能提出了理论上的基础。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本来其实不想写这个的，但是看到很多网友以及一些围棋职业选手提出了一些疑问，比如「Google 没有顶尖的棋手为什么能开发出顶尖的围棋机器人？」还有「机械为什么可以在如此直觉主导的游戏中战胜人类？」。这些问题事实上在人工智能领域已经有很多理论来做解释。而且这些理论也并不是 Google 提出的。AlphaGo 所使用的理论大多还是十余年前左右的论文的一些成果。在此之前，使用了这些理论开发出来的人工智能其实已经在 2006 年就已经在 9x9 的小棋盘上战胜周俊勋九段，之后在 2013 年 CrazyStone 程序就已经在让四子前提下战胜过石田芳夫九段，而就在去年，Facebook 的围棋机器人在不让子的前提下，胜过职业选手。至于之前「前百度深度学习研究院」的吴韧所开发的异构神机也使用的是类似的理论，也在前几天战胜过职业棋手。&lt;/p&gt;
&lt;p&gt;这些方法上，AlphaGo 并无太大创新，很大程度上是 Google 团队实现得相对完善以及训练程度更好，以及人工智能算法的实现和调参存在很大的偶然因素。那么究竟是什么方法让机械拥有了和人一样直觉，而不是简单的机械化的思考。这事我们还是要从头讲起。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Google" scheme="http://blog.heckpsi.com/tags/Google/"/>
    
      <category term="AlphaGo" scheme="http://blog.heckpsi.com/tags/AlphaGo/"/>
    
      <category term="AI" scheme="http://blog.heckpsi.com/tags/AI/"/>
    
      <category term="机器学习" scheme="http://blog.heckpsi.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="科普" scheme="http://blog.heckpsi.com/tags/%E7%A7%91%E6%99%AE/"/>
    
  </entry>
  
  <entry>
    <title>也谈 Android 应用的热更新</title>
    <link href="http://blog.heckpsi.com/2016/02/06/android-hot-patch/"/>
    <id>http://blog.heckpsi.com/2016/02/06/android-hot-patch/</id>
    <published>2016-02-05T16:29:00.000Z</published>
    <updated>2016-04-21T16:33:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>这几天支付宝的所谓「隐私门」的火热程度非同一般。至于支付宝有没有监控用户的隐私数据，双方至今也没有争论出一个结果出来。但我倒是被阿里官方所发的声明所惊讶到了，它们在声明中提到，他们可以在云端开关你手上支付宝的功能，这一点是违背对 Java 作为静态语言的常识的。而网友更是发现，这一点并不是用 API 来简单控制的，而是可以从云端下发代码下来来实现「热更新」，随时修改 apk 的本身。稍加研究，就发现了手机淘宝团队曾经在 QCon 上做过有关于相关主题的 <a href="http://www.infoq.com/cn/presentations/mobile-phone-taobao-hotpatch-technology-introduction" target="_blank" rel="external">演讲</a> 。</p>
<p>手机淘宝的热更新技术基于他们所开发的 Dexposed 框架，而 Dexposed 框架其实就是一个应用内的 Xposed 框架，而手机淘宝团队也大方承认了他们的许多代码也是直接从 Xposed 的开源项目里拿的。通过这个技术，框架对应用内的类都实现了 hook，可以通过云端下发的 dex 对这些类进行动态的修改，并且只损失相当较小的性能。而这个技术脱离了传统想要动态修改代码必须把整个开发框架都更换为运行于脚本语言之上的尴尬。</p>
<p>然而当我细究这个框架的时候发现了一些问题。阿里虽然对这一框架进行了 <a href="http://github.com/alibaba/dexposed" target="_blank" rel="external">开源</a> 。但已经很久没有更新过新版本了。当前的版本只支持到了 Android 4.4。由于 5.0 起新的 ART 虚拟机、更严格的 SELinux 策略以及对 64 位的支持之类的事，使得 Xposed 都在开发上做了很多调整。我不知道 Dexposed 现在是否支持，但至少阿里没有开源。</p>
<p>考虑到这些情况，我正在考虑我们是不是有一个其它的更加通用的路径在 Java 上来实现动态的修改方法从而进行热更新。</p>
<a id="more"></a>
<h2 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h2><p><strong>在本地动态执行远端下发的代码是极度危险的行为。利用此方法执行非法代码等或用于绕过 Google Play 等市场的审查是违反相关协议的，也是对用户极度不负责任的行为。</strong></p>
<h2 id="ART-虚拟机带来的挑战"><a href="#ART-虚拟机带来的挑战" class="headerlink" title="ART 虚拟机带来的挑战"></a>ART 虚拟机带来的挑战</h2><p>Xposed 面对 ART 虚拟机的时候究竟是遇到了什么样的问题呢？这要从 ART 虚拟机的原理说起。Java 是一门编译成 ByteCode，并由本地的虚拟机进一步动态地解释成机器码的语言。在旧版本的 Android 上所使用的 Dalvik 虚拟机其运行原理与 Oracle 的官方虚拟机是非常接近的。这样的解释对性能的消耗，虽然有 JIT 对其运行的优化，比起像 Objective-C 这样的纯编译语言来说还是差上一些性能的。</p>
<p>为了解决性能上的颓势，Android 在 4.4 版本上首次引入了默认不开启的测试版本的 ART 虚拟机，并在 Android 5.0 上成为了默认的虚拟机。其重要的变化是在 apk 的安装过程中，进行所谓 AOT(Ahead-of-Time) 的优化。即在安装过程中尽可能地将 ByteCode 静态编译了，并进行代码优化。这使得运行时注入的难度更高了。</p>
<p>Xposed 框架通过修改了 libart.so 等相关虚拟机文件关闭了一系列的优化，才使得框架终在 Android 5.0 上运行。而相对的，Dexposed 并不能修改系统虚拟机文件，毕竟这只是应用内的框架，这就使得难度变得很高。代码一旦被静态编译甚至被优化后再做 Java 层面上的 hook 确实难度很高。那么我们能不能在 Java 本身上找到一种被语言本身所支持的 hook 方式以使得更好的兼容呢？</p>
<h2 id="Java-的馈赠"><a href="#Java-的馈赠" class="headerlink" title="Java 的馈赠"></a>Java 的馈赠</h2><p>显然，Java 是没有 eval() 函数的，也就是没有语言本身所支持的可以动态运行 Java 代码的方法。但当我在 Java 的文档里搜索 eval 的时候，我还真发现了一些什么。自 JDK 1.6 起，Java 内置了一个执行脚本的包 javax.script。目前支持的语言只有 JavaScript。也就是说 Java 内置了一个「动态语言」 JavaScript 的解释器！</p>
<p>等一下，我并不是希望你用 JavaScript 来写 Android 应用，因为这毕竟不那么快，我们之所以写原生应用，性能是我们考虑的一大原因。但是如果我们仅在热更新时「临时地」插入一段 JavaScript 代码也并不是一件坏事。但这样的话就存在一个问题，那就是 Java 的变量和 JavaScript 变量如何绑定的问题了。没关系，ScriptEngine 早已实现了这一功能。你可以通过 ScriptEngine.put(String, Object) 的方法在运行前写入 JavaScript 的变量，在运行后通过 ScriptEngine.get(String) 的方法来获得变量。</p>
<p>示例的 Java 代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  ScriptEngine engine = <span class="keyword">new</span> ScriptEngineManager().getEngineByName(<span class="string">"javascript"</span>);</div><div class="line">  engine.put(<span class="string">"a"</span>, <span class="number">1</span>);</div><div class="line">  engine.put(<span class="string">"b"</span>, <span class="number">2</span>);</div><div class="line">  engine.eval(<span class="string">"var ans_1 = a + b; var ans_2 = a - b;"</span>);</div><div class="line">  System.out.println(engine.get(<span class="string">"ans_1"</span>));</div><div class="line">  System.out.println(engine.get(<span class="string">"ans_2"</span>));</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e)&#123;</div><div class="line">  e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>打印如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">3.0</div><div class="line">-1.0</div></pre></td></tr></table></figure>
<h2 id="利弊"><a href="#利弊" class="headerlink" title="利弊"></a>利弊</h2><p>这样做的好处是很显然的，这是 Java 语言层的支持，兼容性好得惊人。而且，这不会影响到 ART 虚拟机的 AOT 优化，你的代码依然可以在 Android 5.0+ 上和原来一样快。</p>
<p>但弊端也是很明显的。插入的代码由于是脚本语言，初始化脚本语言引擎和变量传递都是一个比较消耗性能的东西。但是你大可只在热更新的地方才初始化脚本语言引擎，在没有被更新到的地方依然正常地运行下去。不过在一些访问非常密集的地方使用热更新可能会对效率产生相对比较大的影响，应该避免使用。</p>
<h2 id="示例封装"><a href="#示例封装" class="headerlink" title="示例封装"></a>示例封装</h2><p>说完这些，我们可以对 Java 的 ScriptEngine 进行一些封装成为一个 HotPatch 类使得它更适合做热更新的工作。</p>
<p>Hot Patch 需要注入的地方分为三个类型</p>
<ol>
<li>入口 Activity</li>
<li>类方法</li>
</ol>
<h3 id="入口-Activity"><a href="#入口-Activity" class="headerlink" title="入口 Activity"></a>入口 Activity</h3><p>对于入口 Activity，我们希望它能发送一个异步的网络请求检测是否有新的热补丁，如果有，那么下载。下载后将对应的需要 hook 的地方的名称和对应的代码以 key-value 的形式保存下来就行。出于方便，我们可以直接使用 Android 内置的 <code>SharedPreferences</code> 来存储。这样我们只需要在 Activity 的 <code>onCreate</code> 中通过一个 Annotation 来插入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">  <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">  <span class="meta">@HotPatchUpdate</span>(<span class="string">"https://www.hotpatch.com/getUpdate"</span>, <span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>需要注意的是，这个 Update 的实现需要有几个注意点。这个管道一定要建立在 https 上，因为下发代码是极其危险的，如果被劫持，后果是无法想象的。其次请求时最好自动带上 Android 版本、手机型号、地区、版本号等信息，以方便更精确地下发，千万不能下发错。然后每次执行到这里时应先检查是否有已经下载好的补丁。如果有，请校验其是否合法，以避免用户升级后，相关的补丁已经过期却仍然被运行导致更大的问题。</p>
<h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><p>类方法里主要有两处做 hook 是最为有效的，一个是方法的一开始，而另一处是 return 处。只要将方法的 i/o hook 了，就能解决所有问题。</p>
<p>所以我们分别在这两处插入两个 Annotation 的方法，在尽可能不影响优雅度地情况下插入代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</div><div class="line">  <span class="keyword">public</span> android.content.Context context;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Test</span> <span class="params">(android.content.Context context)</span></span>&#123;<span class="keyword">this</span>.context = context;&#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</div><div class="line">    <span class="meta">@HotPatchHook</span>(<span class="string">"addStart"</span>, context, a, b)</div><div class="line">    <span class="keyword">int</span> c = a + b;</div><div class="line">    <span class="meta">@HotPatchHook</span>(<span class="string">"addEnd"</span>, context, c)</div><div class="line">    <span class="keyword">return</span> c;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 <code>&quot;addStart&quot;</code> 和 <code>&quot;addEnd&quot;</code> 分别是两个索引，分别对应去寻找热补丁中对应的代码。而 context 必须传入是因为要找 <code>SharedPreferences</code>，如果你通过其它方式来实现存储的话，则不需要。<code>a</code> 和 <code>b</code> 还有 <code>c</code> 是被 Hook 的变量。有一点特别注意，当参数被 JavaScript 引擎传回时请校验其是否是 null。至于如果一个类型在 JavaScript 中找不到的话，Java 中的 ScriptEngine 所支持的 JavaScript 是可以插入 Java 的 import 包的，所以可以避开这样的问题。形如  <code>String jsCode = &quot;importPackage(java.util);var list2 = Arrays.asList([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]); &quot;;</code>  的代码是可以被解释的。当然你也可以只传入 <code>int</code>、<code>double</code>、<code>boolean</code> 类型，然后手动写 <code>set</code> 和 <code>get</code> 方法。这取决于你自己想要什么样的代码风格。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，我们通过实现两个简单的 Annotation 的方法，实现在 Android 上 Java 语言层面所支持的热更新的方法。当然，这样的实现并不是太过完善，还需要做很多细节上的调整。但是对于简单的热更新来说已经是足够好用了，实现一遍的话所需要的代码数也很少。同时，稍作修改，我们可以将这样的代码运行在任何 Java 程序上，实现 Java 客户端的热更新，而不只局限于 Android。</p>
<p>这样的热更新虽然会带来少许的性能问题，但比起将整个程序都跑在脚本上，这样的解决方案已经好上很多，更重要的是，当你没有热更新时，并不会对性能造成影响。同时，其 Java 语言层面的支持，也使得其兼容性非常良好，可以作为对于作为线上、线下调试的比较好的工具。</p>
<p>相比 Dexposed，这样的方法还显得比较低级，也无法 hook 系统类，没有办法做更多更底层的操作，也无法支持 ndk。但一般意义上来说，这已经足够好用了。</p>
<p>但是，最后还是要提醒一句：</p>
<p><strong>在本地动态执行远端下发的代码是极度危险的行为。利用此方法执行非法代码等或用于绕过 Google Play 等市场的审查是违反相关协议的，也是对用户极度不负责任的行为。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;这几天支付宝的所谓「隐私门」的火热程度非同一般。至于支付宝有没有监控用户的隐私数据，双方至今也没有争论出一个结果出来。但我倒是被阿里官方所发的声明所惊讶到了，它们在声明中提到，他们可以在云端开关你手上支付宝的功能，这一点是违背对 Java 作为静态语言的常识的。而网友更是发现，这一点并不是用 API 来简单控制的，而是可以从云端下发代码下来来实现「热更新」，随时修改 apk 的本身。稍加研究，就发现了手机淘宝团队曾经在 QCon 上做过有关于相关主题的 &lt;a href=&quot;http://www.infoq.com/cn/presentations/mobile-phone-taobao-hotpatch-technology-introduction&quot;&gt;演讲&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;手机淘宝的热更新技术基于他们所开发的 Dexposed 框架，而 Dexposed 框架其实就是一个应用内的 Xposed 框架，而手机淘宝团队也大方承认了他们的许多代码也是直接从 Xposed 的开源项目里拿的。通过这个技术，框架对应用内的类都实现了 hook，可以通过云端下发的 dex 对这些类进行动态的修改，并且只损失相当较小的性能。而这个技术脱离了传统想要动态修改代码必须把整个开发框架都更换为运行于脚本语言之上的尴尬。&lt;/p&gt;
&lt;p&gt;然而当我细究这个框架的时候发现了一些问题。阿里虽然对这一框架进行了 &lt;a href=&quot;http://github.com/alibaba/dexposed&quot;&gt;开源&lt;/a&gt; 。但已经很久没有更新过新版本了。当前的版本只支持到了 Android 4.4。由于 5.0 起新的 ART 虚拟机、更严格的 SELinux 策略以及对 64 位的支持之类的事，使得 Xposed 都在开发上做了很多调整。我不知道 Dexposed 现在是否支持，但至少阿里没有开源。&lt;/p&gt;
&lt;p&gt;考虑到这些情况，我正在考虑我们是不是有一个其它的更加通用的路径在 Java 上来实现动态的修改方法从而进行热更新。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://blog.heckpsi.com/tags/Android/"/>
    
      <category term="JavaScript" scheme="http://blog.heckpsi.com/tags/JavaScript/"/>
    
      <category term="架构" scheme="http://blog.heckpsi.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>SA 屏究竟是一套什么样的技术？（上）</title>
    <link href="http://blog.heckpsi.com/2015/11/01/super-amoled-introduction-part-1/"/>
    <id>http://blog.heckpsi.com/2015/11/01/super-amoled-introduction-part-1/</id>
    <published>2015-11-01T07:15:00.000Z</published>
    <updated>2016-04-21T16:33:53.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>从 LED 聊到 Super AMOLED</strong></p>
<a id="more"></a>
<h3 id="万物基于-MIUI-LED"><a href="#万物基于-MIUI-LED" class="headerlink" title="万物基于 MIUI LED"></a>万物基于 <del>MIUI</del> LED</h3><p>LED 是一项非常古老的技术，如果我们追溯其起源，可以到达五十多年前的 1961 年。今天已经是世界第三大半导体制造商德州仪器（Texas Instruments）的两位研究员 Robert Biard 和 Gary Pittman 首次发现了基于砷化镓的半导体材料能够放射出红外线。次年，通用电气公司的（General Electiric Company）的 Nick Holonyak 制造出了首个可以发出可见光的 LED。</p>
<p>LED，Light-Emitting Diode 即「发光二极管」究其本质当然是一种能发光的半导体。二极管的基本特性简单来理解是说当电流从一个方向流过时，能够很正常的导通。但从反方向流过时，会受到较大的电阻，只能产生微弱的电流。然而这样的特性对于发光特性并没有什么直接的联系。那 LED 为什么会成为一项主流的发光技术呢？那我们应该和另一项我们常见的发光技术来比较发光原理，那就是钨丝灯泡或卤素灯泡（钨卤灯泡）。</p>
<p>电灯泡的基本原理是根据了黑体辐射理论（非常有意思的是黑体辐射理论作为量子力学的一部分提出在灯泡发明后的一百余年），物体在不同温度下能发出不同频率的光，当温度小的时候通常是肉眼不可见的红外线，而温度高了之后就能发出可见光了（比如我们看到打铁的时候铁块会发出红光）。这样的灯泡首先首先体积不小，其次温度很高，更糟糕的是，白炽灯只有少于 10% 的能量会成为光，发光效率非常低下。</p>
<p>而 LED 由半导体材料组成，当电流从阳极（p极）流向阴极（n极）的时候，电子会跌落到较低能阶的轨道上，多出的能量会以电磁波（光子）的形式被释出。这样从理论上是发光效率极高的，因为少掉的能量几乎都变成了放出的电磁波。而我们只需要让放出的电磁波是可见光波段我们即可实现发光的作用了。体积、工作温度、发光效率都能远超电灯泡。</p>
<p>对于 LED 的发展事实上只有一个问题需要考虑，那就是半导体的材料。材料决定了发出了光的频率即颜色。如今人们发现的 LED 无机材料已经超过了 20 多种。</p>
<h3 id="把不要显示的东西遮住，液晶显示器（LCD）的基本原理"><a href="#把不要显示的东西遮住，液晶显示器（LCD）的基本原理" class="headerlink" title="把不要显示的东西遮住，液晶显示器（LCD）的基本原理"></a>把不要显示的东西遮住，液晶显示器（LCD）的基本原理</h3><p>LED 的最经典的应用当然不是各种信号灯之类，而是是现在普遍使用的液晶显示器（LCD）了。LED 技术的出现意味着我们可以做出比起 CRT（阴极射线管）那样要远距离开枪发光的屏幕更薄更小的屏幕了。然而要利用 LED 做屏幕我们有几个非常关键的问题要解决。首先，LED 的成本并不低，如果我们为每个像素都配上红绿蓝三个 LED 这将变得非常昂贵。但如果我们不这么做的话是无法发出任何合成光的，至少，LED 发的光都是单色光，而像白色这样的光都是合成光，是无法实现的。</p>
<p>读到这里的有些同学可能就要产生疑问了，既然如此，那我们平时看到商场里卖的白色 LED 灯泡又是怎么做的呢？事实上，现在我们看到的白光 LED 是蓝色或者紫外 LED，然后在灯泡内壁上涂上能吸收蓝光或紫外线发出红光绿光蓝光的荧光剂，从而发出红绿蓝的混合光，即白光。这时候我们就有个很大的消耗，就是荧光剂转换光的颜色的过程中会浪费一部分能量，所以我们看到白色 LED 的发热相比其他颜色还是要高一点的。</p>
<p>除了利用荧光发出白光的 LED 的技术的发明，另一项重要的技术也是 LCD 发明的重要步骤，那就是液晶（Liquid Crystal）。液晶存在一个特殊的性质就是它的液晶相能改变偏光性。</p>
<p>简单的你可以认为，一束光含有非常多的小的光子，每个光子在向前运动过程中，自身还会沿着某个随机的方向发生小的振动。而透过一片液晶后，横向振动的正常通过了；垂直振动的撞在了液晶上，能量被液晶吸收放出了热能，无法通过；斜着振动的，垂直部分的能量被吸收，而横向的能量保持，继续通过了液晶。从宏观的角度来看，亮度减少了一半。而如果连续通过两个液晶，而他们能通过的方向是正好垂直的，那么 100% 的光都可以被吸收，完全不发光。</p>
<p>而液晶本身对电信号敏感，意味着我们能通过通电来改变液晶的方向，从而很容易地控制哪些光应该被遮住哪些应该被通过。屏幕上其实是有两块液晶构成的，第一块就是单纯只让一个方向的光通过，而第二层由电信号控制，来决定透过多少光，显示一个多亮的东西。</p>
<p>LCD 显示器是由一块白色的 LED 背光，一片液晶和一片被电信号控制的液晶组成的。彩色的 LCD 显示器就是在背光上再贴上红色绿色蓝色的贴纸，来精确控制每个颜色的亮度而已。然而事实上，这种能量损耗是惊人的。首先 LED 由蓝色变成白色需要损失一部分能量，再贴上三色的贴纸又要损失 66% 的能量，通过一片液晶又会损失 50% 的能量。所以最下面的 LED 背光需要非常亮才行。</p>
<p>尽管如此，这项技术随着时间的发展已经变得非常成熟，显示效果非常地好。直到智能手机发明后的好一段时间大家发现，手机的主要耗电都放在了屏幕上，而手机的电池又不那么够用。我们急需一项新技术来改进我们显示的功耗。</p>
<h3 id="OLED-——-更低的成本，更大的应用可能"><a href="#OLED-——-更低的成本，更大的应用可能" class="headerlink" title="OLED —— 更低的成本，更大的应用可能"></a>OLED —— 更低的成本，更大的应用可能</h3><p>我们之前说到 LED 决定颜色的主要关键在于材料，但我之前也说我们发现了超过 20 种无机材料，无机材料简单来说就是一些合金，组合的数量其实很少，可供选择的改进很少，已有的选项生产成本都不低。然而这时候我们需要谈到一个人，他叫做邓青云，他出生于英属香港，后在英属哥伦比亚大学得到化学理学士学位，后进入康奈尔大学获得物理化学博士学位，之后于 1975 年进入柯达公司 Rochester 实验室工作。在实验中意外发现了一些有机材料也可以成为这样的材料。OLED 使用了有机化合物作为半导体材料，工艺简单、成本低廉甚至还能用印刷方式制造。这意味着我们可以用 OLED 印刷出一个大面积的发光面。</p>
<p>这些特性都是传统 LED 没有的。我们用红色、绿色、蓝色的 OLED 通过印刷方法就能得到一个很大的屏幕，通过电信号单独控制每个灯，我们就能精确发出光的亮度。在显示黑色的时候耗能几乎是 0，发光不透过彩色贴纸、不透过液晶、没有荧光粉，简直就是我们继续要找的这么一款用来做手机显示器的卓越材料。</p>
<h3 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h3><ul>
<li>AMOLED 与 PMOLED 的区别在于有没有 TFT（我并没有在开玩笑）</li>
<li>Super AMOLED 与 OGS、InCell、OnCell</li>
<li>拜耳阵列与 Pentile 排列的发展</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;从 LED 聊到 Super AMOLED&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="科普" scheme="http://blog.heckpsi.com/tags/%E7%A7%91%E6%99%AE/"/>
    
      <category term="Samsung" scheme="http://blog.heckpsi.com/tags/Samsung/"/>
    
      <category term="SuperAmoled" scheme="http://blog.heckpsi.com/tags/SuperAmoled/"/>
    
  </entry>
  
  <entry>
    <title>支持平权支持的是什么？</title>
    <link href="http://blog.heckpsi.com/2015/06/27/what-is-equal-rights/"/>
    <id>http://blog.heckpsi.com/2015/06/27/what-is-equal-rights/</id>
    <published>2015-06-27T12:15:12.000Z</published>
    <updated>2016-04-23T13:16:41.000Z</updated>
    
    <content type="html"><![CDATA[<div class="tip"><br><br>平权运动，无论是女权运动也好、黑人解放运动也好，还是同性婚姻合法化也好，其实归根究底平的是两件事 —— 人权（民权）。<br><br></div>

<p>说到人权，我们很容易想到 1776 年美国的《美国独立宣言》、1789 年法国的《人权与公民权宣言》和 1948年联合国大会批准的《世界人权宣言》。其实追溯起来，最早的有关人权的法案可以追溯到公元前六世纪的《居鲁士文书》，即居鲁士大帝宣布释放所有奴隶回乡。当我们谈到人权的时候，我们想到的通常是这些法案和文书。但是实际上人权本身和任何法案和文书都没有关系，也就是说人权本身具有普世性，每个人都应该享有人权，法律只不过是约束的一种形式而已。</p>
<a id="more"></a>
<h4 id="平权"><a href="#平权" class="headerlink" title="平权"></a>平权</h4><p>《美国独立宣言》中的一句话很好的概括了人权的内容：All men are created equal. 人人生而平等。人权指的是个人或群体作为人类本身即享有的权利，每个人都应该享受相等的权利。不过需要注意的是，无论是《美国独立宣言》还是《人权与共民权宣言》当时都是将人权限定在男性公民上，即把女性和奴隶排除在外。然而正如我们之前所说，法律不过是约束的形式，这并不影响女性和奴隶理应享受和其他人一样的权利。人权的一般定义中包括了：生命权、自由权、财产权、尊严权、获助权、公证权和受教育权利。展开的话其实内容更加丰富。而民权则是人权更进一步的内容，即 “公民” 的法定权利。通常我们通常将它和人权放在一起谈。因为他们之间在实际情况下的界限并不是非常分明。</p>
<p>支持平权的基础是承认人本身的差异性。人类存在男性、女性、跨性别人。你不能只认准男性作为人类的代表，从而歧视女性和跨性别人。就好像世界上存在单眼皮的人和双眼皮的人，他们都是人类组成的一部分，你不能认准某一种眼皮的人是 “正确” 的，而去歧视另一部分人。这就是所谓平权的意义，使得地球上人人享有的人权相等。</p>
<p>举个例子来说，在美国女权主义运动的过程中，一些女权组织禁止男性在他们的组织内工作。然而，这并不是平权的一部分，因为在平权过程中，男性应该和女性享有同等的工作权利，而不是以女性可以工作来替代男性可以工作。</p>
<p>同样地，在近年来非常受到关注的同性婚姻合法化运动中，人们希望同性恋能够和异性恋一样享受相同的婚姻家庭权利。正因为婚姻家庭权利是人权，是每个人都应该享受的权利，无关于家庭的结合是同性还是异性。（在此事件上的许多美国反对者的观点通常打的是对于家庭的定义、对于婚姻的定义，因为在这两者的定义上，人通常认为异性结合的才是婚姻或者家庭，而且这上面也没有明确的定义，这确实是一个值得斟酌的点，也是争论的焦点。这也是为什么美国最高法院在昨天以 5：4 这样微弱的差距通过了同性婚姻法案。）</p>
<h4 id="那为什么还会要区分-XX权-呢？"><a href="#那为什么还会要区分-XX权-呢？" class="headerlink" title="那为什么还会要区分 XX权 呢？"></a>那为什么还会要区分 XX权 呢？</h4><p>于是问题来了，既然追求的核心是平权，那为什么我还要区分对待。比如将女权、同性婚姻权分离出来来看呢？</p>
<p>这个问题事实上问的相当有水平。因为当我们把这些权利分开来争取的时候，往往容易 “犯错误”。比如上面说过的追求女权的过程中并没有以平权的要求在争取，而是甚至以女权高于男权这样错误的争取方式。这种争取方式其实在现在国内外很多单独的人权组织中都有出现。就好像你不能批评黑人，不能批评女人，不能批评同性恋，不能批评华人，一旦你批评了，明天人权组织就出来说你是歧视他们。</p>
<p>但事实上平权并不是这样一回事。承认人本身的差异性是平权的根本原因。人和人之间就是存在差异的，就好像黑人从基因上更容易使他们合成白肌，所以黑人就是在运动天赋上有优势，这是不可否认的事实。你不能说追求平等，所以就必须承认各个人种在体力上是完全相等的，这是不正确的，我们只争取权利上的平等，而不是一切的平等，追求的是存在差异的各个不同的人之间平等的权利。所以每个群体肯定也有自己的弱点，我们自然可以批评。这无关于人权。</p>
<p>类似上面的问题还有 为什么女性可以放产假？</p>
<p>因为我们承认女性和男性生理上的差异，认识到她们作为女性本身需要这种权利。女权指的是这个，而不是男女平权之后，女性应该和担任相同的工作、享受相同的假期，这本身才是对女性权利的歧视。</p>
<p>那么我们认清了这个问题，我们来回答为什么还要区分各种人群追求的权利。因为各个人群受到歧视的地方是不同的，所以要进行区分。举例来说，对于女性，她们的生育权、堕胎权、家庭暴力问题、享受产假的权利、性暴力问题等上面更为关注，而这些问题是其他群体不会或者不容易遇到的，所以需要分开来具体看，具体争取。</p>
<p>另一点则是出于具体的原因。比如比尔盖茨梅琳达基金会近年来长期呼吁同性恋平权的一大原因是男同性性行为是目前许多地区（包括中国）传播艾滋病的一大途径。出于人生命权的考虑，我们可以优先呼吁男同性恋平权。男同性恋不会因为社会的不承认而不存在，相反，社会的不承认会使得他们的关系从地上走到地下，缺乏基本的安全措施。如果男同性恋能更好被社会承认，男同性恋的性行为可以更好地被规范，可以大大降低国内艾滋病的发病率。</p>
<h4 id="既然我们支持的是平权，那么为什么我们还要支持说类似于-我是XX我自豪-这样的言论呢？"><a href="#既然我们支持的是平权，那么为什么我们还要支持说类似于-我是XX我自豪-这样的言论呢？" class="headerlink" title="既然我们支持的是平权，那么为什么我们还要支持说类似于 我是XX我自豪 这样的言论呢？"></a>既然我们支持的是平权，那么为什么我们还要支持说类似于 我是XX我自豪 这样的言论呢？</h4><p>我是 XX 我自豪（XX Proud）。这个问题也是平权中经常被问到的问题。比如，你可以说：我是黑人我自豪，或者我是同性恋我自豪。这通常被认为是政治正确的。但如果你说我是白人我自豪，或者我是异性恋我自豪则会被认为是歧视。</p>
<p>这其实是因为上述例子中黑人或者同性恋在当前社会下是弱势群体。鼓励说我是 XX 我自豪并不是认为 XX 比其他人群拥有更高的等级，而是其在弱势的情况下，社会的舆论下依然愿意公开承认自己，承认自己的不同，承认自己与别人的差异，这一点非常勇敢和理性，所以才值得被鼓励。这句话其实更应该理解成 我不因为我是 XX 而自卑。</p>
<p>承认人和人本身的不同，愿意公开承认人和人本身的不同。这一点才是被鼓励的。</p>
<h4 id="然而现实是极其残酷的"><a href="#然而现实是极其残酷的" class="headerlink" title="然而现实是极其残酷的"></a>然而现实是极其残酷的</h4><p>现实永远是很残酷的，各种平权运动的进展通常都不顺利。我们在一开始说过，人权是具有普世性的，法律不过是约束其的手段。即使《同性婚姻法案》在美国被通过，并不代表美国人民就完全接受了同性恋。这就好像当年林肯 1862 年签署了《奴隶解放宣言》之后，黑人依然长期被歧视。一直到 20 世纪中叶美国一系列民权运动者的努力下，黑人才逐渐获得越发平等的权利。私以为中国的女权也处于一个法律保护但文化思想上接受程度非常糟糕的程度。</p>
<p>社会的接受比法律的接受更加重要，也更加难争取。这就好像很多孩子看了两部 BL 的作品就天天把基挂在嘴边，好像非常支持同性恋一样，但等他们看到俩大叔抱在一起的时候却做出恶心的表情。你可以问自己这样的问题：如果你有一个哥哥或者弟弟而他是一名同性恋，你是否能接受。如果单纯在法律上被接受然而在心理上没有接受的话，平权并不是真正的成功。刚刷人人的时候看到有人举例说可能孩子以后会要挟说 “不给我买肾6，我就找个同性结婚去。” 而这正是这个问题的实质。无论是孩子还是父母都不从心理上接受同性恋是正常的，所以才可以进行要挟。</p>
<p>心理上的接受是很多人难以逾越的一道坎，这加剧了平权运动推进的难度。加上人们长期以来的经验认识更是容易加剧这种印象。就好像有人会说出 “女人天生就不应该外出工作。” 这样子的话，这句话缺乏基本的逻辑支持，但是却是这个人的固有印象。人们曾经也把物体掉落和重量相关当作固有印象，但是通过实验可以很好的证明他们的错误。但权利这个问题非常的抽象，矫正一个人的观念非常难。甚至 “少数者” 在许多情况下会被理解成病态，就像同性恋在长期都被认为是一种疾病，性别认知障碍也长时间被认为是一种疾病。这对于他们的平权难度更加高。</p>
<h4 id="相信，现实也许是非常美好的"><a href="#相信，现实也许是非常美好的" class="headerlink" title="相信，现实也许是非常美好的"></a>相信，现实也许是非常美好的</h4><p>每个人有各自的不同，有各自的差异。人类在过去只有繁重体力劳动，女性在当时很难争取到工作权是客观原因。而到现在，我们的工作愈发多样，人的生活本身也愈发多样。你的性别、你的肤色、你的性取向似乎都不会影响你找一份适合的工作。有了工作，人有基本的生存的能力，我始终相信坚持下去什么都会有的。</p>
<p><strong>平权一定是会有的吧。</strong></p>
<p>HeckPsi 长期支持 LGBT 平权、女性平权及其它人权平等。</p>
]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;tip&quot;&gt;&lt;br&gt;&lt;br&gt;平权运动，无论是女权运动也好、黑人解放运动也好，还是同性婚姻合法化也好，其实归根究底平的是两件事 —— 人权（民权）。&lt;br&gt;&lt;br&gt;&lt;/div&gt;

&lt;p&gt;说到人权，我们很容易想到 1776 年美国的《美国独立宣言》、1789 年法国的《人权与公民权宣言》和 1948年联合国大会批准的《世界人权宣言》。其实追溯起来，最早的有关人权的法案可以追溯到公元前六世纪的《居鲁士文书》，即居鲁士大帝宣布释放所有奴隶回乡。当我们谈到人权的时候，我们想到的通常是这些法案和文书。但是实际上人权本身和任何法案和文书都没有关系，也就是说人权本身具有普世性，每个人都应该享有人权，法律只不过是约束的一种形式而已。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LGBT" scheme="http://blog.heckpsi.com/tags/LGBT/"/>
    
      <category term="女权" scheme="http://blog.heckpsi.com/tags/%E5%A5%B3%E6%9D%83/"/>
    
      <category term="权利" scheme="http://blog.heckpsi.com/tags/%E6%9D%83%E5%88%A9/"/>
    
  </entry>
  
  <entry>
    <title>流量 “降价” 真假背后的疑团</title>
    <link href="http://blog.heckpsi.com/2015/05/15/things-behind-price-down-of-data/"/>
    <id>http://blog.heckpsi.com/2015/05/15/things-behind-price-down-of-data/</id>
    <published>2015-05-15T14:46:09.000Z</published>
    <updated>2016-04-23T13:11:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>在李克强几次三番的督促下，中国三大电信运营商制定出了他们的流量降价策略。在网民一片叫好的背后，事情真的是那么简单吗？李克强的几句话是真的促成了运营商的降价惠及了广大消费者？还是把朝三暮四和朝四暮三这样偷梁换柱的把戏呢？</p>
<p>要回答这个问题，我们要从一个非常重要的问题出发，流量“降价”究竟谁获利了？</p>
<a id="more"></a>
<p>说到流量降价，我们第一个能想到的当然是消费者获利了。要么是同样多的流量现在更便宜了，或者是同样多的钱可以买到更多的流量了。但实际上真的是这样吗？我们以中国移动的流量改革为例，推出了 10 元 1GB 的夜间流量包、假日流量包，以及 50 元 2GB 的全国流量包。以最后一个全国流量包为例，0.025 元/MB 的资费和之前移动的 4G 资费基本持平，甚至还并不是最便宜的价钱。而前两个套餐基本属于摆设。晚上在家睡觉 Wi-Fi 用的好好的，4G 流量我还嫌 LTE 网络费电呢！从这个角度来看，消费者并没有实际获取到利益，流量什么价钱基本没有变化，日常在流量上的花费不会减少。</p>
<p>终端用户没有获取到实际的利益，那么运营商获利了？可能。如果消费者和朝三暮四故事里那 “众狙皆伏而喜” 的猕猴一样愚蠢那么运营商倒是确实可以多赚钱。因为消费者以为已经便宜了，可能会购买新的根本没有什么用的套餐。但我相信，消费者也不至于那么愚蠢。毕竟这每个月网费可是实实足足的数目，多了少了自己心里最清楚。</p>
<p>那么最终获利的是谁呢？排除掉消费者和运营商，最终获利的很容易判断出来，那就是政府。这点听起来似乎不太对，政府督促运营商网费下降怎么最后获利的是政府了呢？我们来思考一下。李克强督促运营商降价，你觉得李克强是不是在为消费者着想，你是否感觉到了政府的 “作为”，加强了对政府的信赖？但相反，运营商最后没有达到实际的降价你责怪的是李克强吗？不，你责怪的是运营商。你觉得运营商应付国家、忽悠用户，运营商背下了沉重的黑锅而政府却收获了信任，看起来是多么地和谐啊~</p>
<p>但我们仔细分析一下这件事情的来龙去脉究竟是谁才应该背下这口锅？这个问题的核心在于，运营商为什么嘴上答应着降价，实际却没有什么作为呢？翻开中国移动 2014 年的 <a href="http://www.chinamobileltd.com/sc/ir/reports/ar2014.pdf" target="_blank" rel="external">年报</a> ，我们似乎可以寻找一点答案。首先，中国移动作为国企，但并不是完全的国有资本，它是股份制的上市公司，采取资本的运作方式，作为公司，它也是要自负盈亏的。</p>
<p>2014 年全年中国移动运营支出 5241 亿人民币，收入 6414 亿人民币。有媒体报道中国移动每天净赚 3 亿这件事确实不假，但看看这个基数，其实也很正常。但问题是，这里面的钱具体是怎么回事呢？收入的最大大头是语音通讯和短信这样的基础通讯业务，收入 3089 亿人民币。而数据业务，也就是我们平时的流量业务，收入 2530 亿人民币。听起来是不是很大，但是我们同时来看一下，支撑流量业务的 4G 基站、传输网等的建设投入了多少？资本支出 2135 亿元。这部分并没有计入运营支出中，如果算上的话，其实 2014 年中国移动是严重亏损的，但不过这些建设都属于资产，除了折旧部分计入成本确实也不该计入进去。流量业务收入 2530 亿，然而建设网络就花去了 2135 亿，丝毫没有见到这是暴利。很多人说，4G 网络建设是一次性投入，但事实上每年还需要维护、耗电，而且近几年 4G 网络基础建设还会继续推进，花钱根本停不下来。</p>
<p>那么第一个问题来了？成本为什么压不下来？</p>
<p>这个问题的答案得问工信部。2008年，工信部以 “平衡三家运营商实力” 为由，将最不受国际接受的 3G 标准 TD-SCDMA 颁发给中国移动，导致大量用户有网无机，根本换不上支持这种制式的手机。同时把最受国际接受的 WCDMA 标准颁发给了当时最弱的中国联通。但 WCDMA 是国外的标准，整个标准框架下包含了大量海外专利，建造成本比较高。所以当时，移动 3G 看似资费便宜，实际没法用，联通 3G 资费较贵，用户不敢用，这导致中国 3G 产业发展实际上非常慢。</p>
<p>然而当工信部颁发了 4G 牌照之后，移动立马停止了这个光会花钱而赚不到钱的 TD-SCDMA 基站的建设，全面推进 4G 网络建设，因为输了 3G 的移动，已经不能再输 4G 了。同样，其它运营商则绞尽脑汁从别的方面着手，比如联通和电信大量试点 FDD-LTE 标准来支持更多海外手机以占据市场。在这种高密集的基站建设下，流量成本只会提升不会下降。但是相反的，4G 流量不但不比 3G 流量贵，反而更便宜。事实上，4G 流量的价格和海外比起来并不昂贵，而是和海外是基本持平的，考虑到之前 3G 事件引发各运营商疯狂地建基站计划，成本比海外更高，盈利空间非常小，很难挤压出降价的区间，并不能以国内消费水平低就一概而论 4G 就是有降价空间的。</p>
<p>那么也就是说，政府在运营商无力降价的情况下要求降价，这点又是做给谁看的呢？</p>
<p>做给猴看的。虽然运营商已经花了很大的努力使得价格降到和海外差不多，但无法更 “接地气”，这问题是谁造成的？是国家政府的决策部门，是颁发牌照负责监管的 “工信部”，做出了错误的决定，导致了严重的后果。但是国家并不承认，而是把责任推脱给运营商，称 “为什么不能更便宜？” 如果我们是自由的市场经济，当然可以便宜。但在一个被看似暴利垄断的通讯行业，在一次次的放权后，每个运营商早已褪去了过去的光环，已经沦落为只不过是给政府打工的的打工仔，究竟是谁不想降价呢？谁降价谁就有更多用户占得更大的市场，谁不想呢？</p>
<p>而消费者确实觉得价格不够接地气，那么他们会责怪谁？再联系到今年整体疲软的中国经济、并不很成功的自贸区试验、试图搞虚拟运营商实际上却没有给他们足够权限、产业转型开展也并不顺利。不作为、无能的政府？很可能。那么在此之前，先做出总理多次批示降价，而运营商不作为这样一出戏出来，煽动舆论压力，转移消费者的怒火，把这种不满发泄在运营商上。这可真是一场好戏啊。</p>
<p>从这种角度上面来看，只有放开真正的市场自由才能从根本上解决问题。否则就算今天 4G 资费是真降，明天 5G 照样给你涨回来。放开运营商的牌照限制？放开基础设施建设的限制？自贸区放开了文化部跟着一起放开？从技术资金上去扶植产业转型而不是靠处罚和税收？只有这些才能从根本上解决问题。</p>
<p>否则的话，那只能是一个个美好的卫星，和一张张美好的空头支票。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在李克强几次三番的督促下，中国三大电信运营商制定出了他们的流量降价策略。在网民一片叫好的背后，事情真的是那么简单吗？李克强的几句话是真的促成了运营商的降价惠及了广大消费者？还是把朝三暮四和朝四暮三这样偷梁换柱的把戏呢？&lt;/p&gt;
&lt;p&gt;要回答这个问题，我们要从一个非常重要的问题出发，流量“降价”究竟谁获利了？&lt;/p&gt;
    
    </summary>
    
    
      <category term="通讯" scheme="http://blog.heckpsi.com/tags/%E9%80%9A%E8%AE%AF/"/>
    
  </entry>
  
  <entry>
    <title>杀毒软件的免费化与流氓化</title>
    <link href="http://blog.heckpsi.com/2015/05/03/anti-virus-softwares-in-china/"/>
    <id>http://blog.heckpsi.com/2015/05/03/anti-virus-softwares-in-china/</id>
    <published>2015-05-03T08:41:48.000Z</published>
    <updated>2016-04-23T13:03:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>我至今还记得在 12 年前，当我第一次在一台赛扬3的机器上安装上金山毒霸 2003 之后的情形。这个杀毒软件也不过几个按钮，杀毒的时候我的电脑也不卡，半个小时可以扫描完一个 20G 的硬盘，没有弹窗也没有广告，不过倒是需要付费买下 CD-Key。</p>
<p>我也记得 12 年前，当我第一次在这台机器上莫名其妙安装上了 3721 上网助手的情形。打开 IE 浏览器的速度明显变慢了，还多了奇奇怪怪的启动项。不过我并不很讨厌这个插件，它看起来很酷，也挺有意思，虽然不怎么用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">这是最好的时代，也是最坏的时代。</div><div class="line">—— 查尔斯·狄更斯《双城记》</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>2008 年的时候，我第一次认识了那个还在测试版本的 360 杀毒。这是中国杀毒软件中第一个敢于做免费的。测试版本的 360 杀毒非常轻，软件一共只有寥寥几个界面，使用的是 BitDefender 的查杀引擎，查杀的效果其实还挺不错。在 1.0 版本发布之后，360 也加大了宣传力度，一度以“免费”的概念打入市场，并且获得了非常大的市场占有。</p>
<p>为了与之竞争，瑞星、金山等大量杀毒软件厂商也将自身产品免费化了。但是，问题来了，杀毒软件凭什么可以免费？</p>
<p>当然，各大厂商会用一个非常通用的理由来给你解释：这个叫“互联网思维”。互联网本身就应该是产品免费的，通过基于免费产品的拓展服务来盈利，最大的例子就是 Google，搜索功能本身是免费的，而通过基于搜索的广告服务来实现盈利。这个理由听起来非常有道理，但是仔细想想其实漏洞百出。搜索引擎可以通过学习用户的搜索习惯来了解用户的需求，发现潜在的消费目标，推出合适的广告。那杀毒软件学习什么呢？学习用户中过的病毒可以用来推送广告？广告又推送在哪里呢？要知道搜索引擎通常实在浏览器前端运行的，而杀毒软件总是在系统后台默默运行的啊，没有展示的地方啊。</p>
<p>拥有庞大装机量之后的 360 给我们展示了，什么是杀毒软件的“互联网思维”。360 最嚣张的时候莫过于 2011 年上市先后。通过给用户弹出弹窗，提示用户使用的 QQ 存在风险，要求用户下载安装 360 扣扣保镖，然后通过所谓“扫描”后提示 QQ 监控用户隐私文件，然后提示用户启用保护，阻止 QQ 对硬盘进行读取操作，同时屏蔽 QQ 的广告、迷你新闻等功能，还用户一个安全的“QQ”。</p>
<p>这件事便是 3Q 大战的开始。一个长期静默在后台的“杀毒”软件，可以对用户病毒以外的程序进行直接的干涉，影响其他产品的正常运行。通过推送服务，使得自身其他产品快速获得高市场占有率，通过别的产品和服务来实现盈利。没错，杀毒软件的运行方式非常底层于系统，事实上他们可以干涉你系统里的任何东西，成为了你操作系统里的“老大哥”。</p>
<p>之后的很多东西我们也能看到这种方式的影子，比如通过弹窗推送安装 360 浏览器、360 手机助手，使得在前端业务的市场占有极快提升。装一个 360，莫名其妙就把 360 全家给装上了。再通过广告等方式实现盈利。同样地，从收费走向免费的金山杀毒也开始弹出广告、弹出金山手机卫士、猎豹浏览器等服务来实现其业务的快速扩张。</p>
<p>所以，以 2011 年可以做一个很明确的分界线。2011 年以前，上网中病毒、中流氓插件，2011年以后，上网中杀毒软件、中安全卫士。毕竟原来写病毒的都嫌弃病毒来钱慢都去搞流氓安全软件去了。</p>
<p>但不得不说，这种模式虽然非常恶心，但却是非常精明的“生意人”，2011 年 360 在美国上市，2014 年猎豹在美国上市，这一个个发展飞快。但是这些软件在弹窗和推送中夹杂的“忽悠”用户下载其他软件的内容也并不完全没风险。2012 年 360 所有 iOS 手机端应用因被苹果查出刷票行为，被全面下架处理。2013 年 360 手机端产品再次因为涉及用户隐私等原因再遭苹果市场下架，并导致国家工信部介入调查。同样的，猎豹清理大师因为恶意推送广告，也遭到了 Google Play 市场下架。这些也都是流氓行为背后的问题。</p>
<p>这时候我们看看中国的杀毒软件市场，注重技术研发的比如微点一个个入不敷出面临倒闭，一个个流氓运营的却如风顺水。反观国外市场，通常有面向个人用户的免费提供基本杀毒功能的产品比如微软MSE、小红伞免费版、Avast免费版，有面向更复杂需求的付费版本。至少没见到过一天到晚弹窗的。并且做杀毒软件的，也更倾向于提高杀毒软件的技术水平而不是横向扩展。</p>
<p>所以杀毒软件在中国并不是走向了免费化，只不过是走向了流氓化，所谓，免费的才是最贵的。</p>
<p>但今年最让人不可思议的是 360 被三大杀毒软件评测机构宣布在测试中存在舞弊行为，被撤销了认证。可能很多同学并不清楚这些测试机构是什么。他们每年会收集最新的病毒样本，然后测试杀毒软件的两个参数：是否能够查杀出全部的病毒？是否会将正常文件误判成病毒？360 被称舞弊是因为，在送去测试版本的 360 杀毒中默认打开了 BitDefender 引擎，查杀率 100%，误杀率 0%，被颁发了认证。但是，在 360 官网上下载的版本默认是关闭 BitDefender 引擎的，查杀率明显降低，误杀率明显提高，所以被称为舞弊。当然，360 之所以要关闭原因是显然的，BitDefender 引擎对资源消耗非常大，而 360 面向的用户中许多人电脑配置糟糕，根本没法打开这引擎。但是为了取得好的测试成绩，在送测时把这引擎打开了。这样的测试结果根本不真实，代表不了 360 杀毒在用户机器上运行的实际情况。</p>
<p>这样的事情其实原先我是理解的，这毕竟和 360 面对的市场有关系。但是不可思议的是，360 随后发表了声明 <a href="http://weibo.com/p/1001603838152715428532" target="_blank" rel="external">《传统杀毒评测标准落后云时代，我们宣布退出AV-C》</a>。这就变得非常让人震惊了。如果你说考试制度不合理，你拒绝参加考试，我觉得也是可以理解的。但实际问题是你被抓出了考试作弊，然后你说考试要抓作弊这事不合理你要拒绝考试，这简直是滑天下之大稽！</p>
<p>我们再反观这里面的逻辑，传统杀毒评测标准落后云时代。传统病毒评测标准就是两点：查杀率和误杀率。难道云时代的杀毒软件是可以在这两件事上放水的吗？而且这份声明也十分可笑。比如里面说 360 在送测版本中没有任何作弊行为，问题是作弊都被抓了现行竟还说没有作弊也是非常不可思议。再比如里面举例说病毒可以恶意操作 TeamViewer，所以理应把 TeamViewer 当病毒处理，这更是可笑。TeamViewer 本身又没有安全性问题，你要当病毒处理的是捆绑在 TeamViewer 上的病毒程序啊，你把整个 TeamViewer 当病毒了竟然还有理了，那你为什么不把同样拥有远程操作功能的 QQ 给当病毒处理了？全篇偷换概念玩得非常溜，也是要为 360 公关部门的水平要给出满分。</p>
<p>那么所谓云时代的标准又是什么呢？是对未知病毒行为进行预测还是基于 P2P 的病毒库？我想恐怕还没有定论，反正无论哪个 360 都没做好。360 口中的云时代反大概是不停运用“云服务”给你推送其它软件的云流氓标准吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我至今还记得在 12 年前，当我第一次在一台赛扬3的机器上安装上金山毒霸 2003 之后的情形。这个杀毒软件也不过几个按钮，杀毒的时候我的电脑也不卡，半个小时可以扫描完一个 20G 的硬盘，没有弹窗也没有广告，不过倒是需要付费买下 CD-Key。&lt;/p&gt;
&lt;p&gt;我也记得 12 年前，当我第一次在这台机器上莫名其妙安装上了 3721 上网助手的情形。打开 IE 浏览器的速度明显变慢了，还多了奇奇怪怪的启动项。不过我并不很讨厌这个插件，它看起来很酷，也挺有意思，虽然不怎么用。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;这是最好的时代，也是最坏的时代。&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;—— 查尔斯·狄更斯《双城记》&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="杀毒软件" scheme="http://blog.heckpsi.com/tags/%E6%9D%80%E6%AF%92%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="安全" scheme="http://blog.heckpsi.com/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>从 “没有响应” 说到哥德尔不完备定理</title>
    <link href="http://blog.heckpsi.com/2015/04/27/from-no-response-to-godels-incompleteness/"/>
    <id>http://blog.heckpsi.com/2015/04/27/from-no-response-to-godels-incompleteness/</id>
    <published>2015-04-27T12:15:54.000Z</published>
    <updated>2016-04-23T12:57:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>当你看到窗口的标题栏上出现了 “没有响应” (No Responding) 四个字，电脑陷入了莫名的卡顿的时候，你一拍脑袋，大喝一声 “又死机了！” ，点下结束进程的你是否想过，这玩意，真的死机了吗？有时莫名卡顿了几分钟后，程序又莫名其妙恢复正常了。这又是什么情况呢？</p>
<a id="more"></a>
<p>首先，我们先来理解一下，什么是 “没有响应”，<a href="http://windows.microsoft.com/zh-cn/windows-vista/what-does-it-mean-when-a-program-is-not-responding" target="_blank" rel="external">微软</a> 的官方帮助告诉我们：表示该程序与 Windows 的连接速度比平常慢，一般原因是程序中出现问题。如果我们深入理解一下的话，我们可以先考虑一下带窗口界面的程序通常的运行形式。</p>
<p>一个程序通常可以拥有很多线程，意味着它可以同时干很多事。然而通常只有主线程是可以用来更新窗口上显示的内容的，别的线程只能在背后默默进行计算、网络通讯等其它工作。对于同一个线程，一次只能干一件事。主线程虽然更新界面，但大多数情况下，它也会进行一些运算。但如果这个线程长达数秒都迟迟无法更新界面，也就是说这个线程在运行某些内容时阻塞了，系统就会认为这是程序 “没有响应” 了。没有响应通常有两种可能性，第一种是程序运行出现了死循环，怎么也跑不出来了，这就是我们常说的死机。为了帮助大家理解这种 “死循环”，大家可以思考一下下面这个程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">第一步：运行 1+x</div><div class="line">第二步：如果上一步运行结果是2，那么重新运行第一步</div><div class="line">第三步：显示结果</div></pre></td></tr></table></figure>
<p>非常显然，当 x=1 时，这个程序将无限在一二步中循环，这就是传说中的死循环。死循环会导致主线程阻塞（如果这个运算在主线程执行的话）。这就会出现 “没有响应” 的情况。</p>
<p>当然造成 “没有响应” 并不止这一种可能，另一种可能那就是主线程真的在执行某个计算很费时的运算。比如运算小于 10000000000000 的所有素数，这由于算的时间太长也会阻塞主线程，导致 “没有响应”。不过这种阻塞是暂时的，并不是真正的死循环，稍等片刻也是可以解出来的。</p>
<p>然而，为什么系统不能区分出这两种阻塞哪一种是真正的死循环而哪一种只是运算太慢了呢？因为。。。真的不能。。。区分。。。</p>
<p>这种 “不能”，是数学意义上证明的，它就是不能。</p>
<p>给出这个证明的是年仅24岁的计算机科学之父——艾伦·图灵，证明这个问题，这篇论文有近40页（<a href="http://www.cs.virginia.edu/~robins/Turing_Paper_1936.pdf" target="_blank" rel="external">原文</a>），不过实际上的证明过程，只需要一张纸就能说明了。</p>
<p>还是以刚刚演示的会死循环的程序为例，显然这个程序在 x=1 时发生死循环，我们记这个程序为 F(x)，当 x=1 时死循环。我们假设存在一个程序能判定程序是不是会死循环，我发这个程序叫 G(f,x)，指该程序可以判定程序f是否在输入x时会死循环。如果判定为死循环就返回1，正常运行就返回0。所以显然 G(F,1) = 1，G(F,2)=0。</p>
<p>我们现在再构造一个更恶心的函数，它叫 T(f,x)，它内部会先运行 G(f,x)，如果发现 G(f,x) = 1 就正常退出，而如果  G(f,x)=0 时就让自己死循环。</p>
<p>那么问题来了，T(T,x) 会不会死机呢？</p>
<p>我们可以假设 T(T,x) 是不死机的，那么意味着 G(T,x) 返回的是1，而 G(T,x) 返回1的前提是 T(T,x) 是死机的，相矛盾，反之同样矛盾。由此证明，一个判断程序是否可能死机的函数  G(f,x) 不存在。</p>
<p>这就是著名的图灵停机问题，在80年前还没有计算机的时候，图灵就证明了这个问题。</p>
<p>不过图灵的这个证明恰好证明了另一个问题，那就是希尔伯特的23个问题。这是德国数学家大卫·希尔伯特（David Hilbert）于1900年在巴黎举行的第二届国际数学家大会上所提出23道最重要的数学问题中的第2个问题 —— 算术公理之相容性。这个问题其本质是希望找到一个方法证明任意公理系统的内部是不矛盾的。</p>
<p>但实际上是事与愿违的，许多公理系统都是自相矛盾的。图灵的停机问题就是这样一种自相矛盾的一个证明。当然，一些更熟悉更易理解的问题其实也可以证明这样的问题。</p>
<p>比如最常见的是 罗素悖论 的一个通俗描述，那就是 理发师悖论。一个理发师给所有不给自己理发的人理发，那么他给不给自己理发？这时候无论理还是不理，都是相矛盾的。</p>
<p>罗素悖论的相对深入的通俗描述可以这么理解：比如一个集合：世界上所有描述它字数少于100字的集合都是这个集合的子集。这个描述本身是完备的，但显然这个集合本身也是自己的子集，并且这个集合包含的还不止有自己集合本身，意味着这个集合本身是自己的真子集，这就是非常荒谬而矛盾的了。</p>
<p>无论图灵还是罗素提出的悖论都证明了我们的计算系统存在不完备的漏洞，然而 1931 年数学家库尔特·哥德尔给出了更为完整的证明，这个证明直接把这种不完备提升到了一个巨大的前提下：任何相容的形式系统，只要蕴涵皮亚诺算术公理，就可以在其中构造在体系中不能被证明的真命题，因此通过推演不能得到所有真命题（即体系是不完备的）。</p>
<p>也就是说，任何形式的数学系统，只要包含关于自然数最最基础的公理：皮亚诺公理，那么它就是不完备的，如此残念。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">我看到了它，却不敢相信它。 —— 康托尔</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你看到窗口的标题栏上出现了 “没有响应” (No Responding) 四个字，电脑陷入了莫名的卡顿的时候，你一拍脑袋，大喝一声 “又死机了！” ，点下结束进程的你是否想过，这玩意，真的死机了吗？有时莫名卡顿了几分钟后，程序又莫名其妙恢复正常了。这又是什么情况呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="数学" scheme="http://blog.heckpsi.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="算法" scheme="http://blog.heckpsi.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS 是如何保证安全的？</title>
    <link href="http://blog.heckpsi.com/2015/04/16/how-https-makes-communication-secured/"/>
    <id>http://blog.heckpsi.com/2015/04/16/how-https-makes-communication-secured/</id>
    <published>2015-04-15T20:21:48.000Z</published>
    <updated>2016-04-21T18:32:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>每当我们讨论到信息安全的时候，我们最长接触到的信息加密传输的方式莫过于 HTTPS 了，当我们浏览器地址栏闪现出绿色时，就代表着这个网站支持 HTTPS 的加密信息传输方式，并且你与它的连接确实被加密了。但是 HTTPS 并不是一个单一的东西，它知识我们常见的 HTTP 协议和某个加密协议的一个混合，这个加密协议通常会是 TLS。那么 HTTPS 为什么安全呢？其实我们需要先考虑 HTTP 为什么不安全。</p>
<a id="more"></a>
<p>假设你坐在一个教室里，你现在非常想把某个信息传递给教室里的另一个人，一般来说，会选择，传纸条。传纸条这个比喻其实非常正确，这就是互联网的一个基础协议 TCP/IP 协议基本的工作模式。而通常，HTTP 协议的数据是使用 TCP/IP 协议进行发送的。HTTP 指的是你在纸条上写明你要传送的目的地是哪个同学的坐位，然后再是要传递的内容。途径的同学拿到纸条后根据纸条上显示的地址依次传过去就好了。这样要面临的第一个问题就是：途径的同学可以完全知道你写了什么。</p>
<p>这就是 HTTP 面临的第一个问题，这个问题通常被叫做 “窃听” 或者 “嗅探” ，指的是和你在同一个网络下或者是途径的路由上的攻击者可以偷窥到你传输的内容。这是 HTTPS 要解决的第一个问题。这种问题通常是通过“加密”来解决的。从非常原始的角度来考虑，其实就是双方约定一个暗号。用什么字母去替代什么字母之类的。不过考虑到互联网每天有无数信息需要加密，这种原始的加密方法似乎不太适合。不过实际上方法也差不多，一般是采用一种叫做 AES 的算法来解决的。这种算法需要一个 密钥 key 来加密整个信息，加密和解密所需要使用的 key 是一样的，所以这种加密一般也被称为“对称加密”。AES 在数学上保证了，只要你使用的 key 足够足够足够足够的长，破解是几乎不可能的。</p>
<p>我们先假设这种破解确实是不可能的，而且目前也确实没有对 AES 本身能发动起有效的攻击的案例出现。</p>
<p>我们再回到这个教室，你接着要传小纸条，你把地址写上后，把要传输的内容用 AES 蹭蹭蹭加密了起来。刚准备传，问题来了。AES 不是有一个 key 吗？key 怎么给目的地啊？如果我把密钥直接写在纸条上，那么中间的人不依然可以解密吗？在现实中你可以通过一些其它方法来把密钥安全传输给目的地而不被其他人看见，但是在互联网上，要想这么做难度就很大了，毕竟传输终究要经过这些路由，所以要做加密，还得找一个更复杂的数学方法。</p>
<p>于是聪明的人们发明了一种更复杂的加密算法——非对称加密。这种加密或许理解起来比较困难，这种加密指的是可以生成一对密钥 (k1, k2)。凡是 k1 加密的数据，k1 自身不能解密，而需要 k2 才能解密；凡是 k2 加密的数据，k2 不能解密，需要 k1 才能解密。这种算法事实上有很多，常用的是 RSA，其基于的数学原理是两个大素数的乘积很容易算，而拿到这个乘积去算出是哪两个素数相乘就很复杂了。好在以目前的技术，分解大数的素因数确实比较困难，尤其是当这个大数足够大的时候（通常使用2的10次方个二进制位这么大），就算是超级计算机解密也需要非常长的时间。</p>
<p>现在利用这种非对称加密的方法，我们来设想一个场景。你继续想要传纸条，但是传纸条之前你先准备把接下来通讯的对称加密密钥给传输过去。于是你用 RSA 技术生成了一对 k1、k2，你把 k1 用明文发送了出去，路经有人或许会截取，但是没有用，k1 加密的数据需要用 k2 才能解密。而此时，k2 在你自己的手里。k1 送达目的地后，目的地的人会去准备一个接下来用于对称加密传输的密钥 key，然后用收到的 k1 把 key 加密了，把加密好的数据传回来。路上的人就算截取到了，也解密不出 key。等到了你自己手上，你用手上的 k2 把用 k1 加密的 key 解出来，现在全教室就只有你和你的目的地拥有 key，你们就可以用 AES 算法进行对称加密的传输啦！这时候你和目的地的通讯将无法再被任何人窃听！</p>
<p>当然，这时候你可能会问两个问题。</p>
<p>既然 非对称加密 可以那么安全，为什么我们不直接用它来加密信息，而是去加密 对称加密 的密钥呢？</p>
<p>这是因为 非对称加密 的密码对生成和加密的消耗时间比较长，为了节省双方的计算时间，通常只用它来交换密钥，而非直接用来传输数据。</p>
<p>使用 非对称加密 是完全安全的吗？</p>
<p>听起来确实是挺安全的，但实际上，还有一种更恶劣的攻击是这种方法无法防范的，这就是传说中的“中间人攻击”。我们继续让你坐在教室里传小纸条。现在你和目的地上途径一个中间人，他有意想要知道你们的消息。由于这个描述比较复杂，我们将你称为 A，你的目的地称为 B，而中间人称为 M。当你要和 B 完成第一次密钥交换的时候，途径了 M。M 知道你要进行密钥交换了，它把小纸条扣了下来，假装自己是 B，伪造了一个 key ，然后用你发来的 k1 加密了 key 发还给你，你以为你和 B 完成了密钥交换，实际上你是和 M 完成了密钥交换。同时 M 和 B 完成一次密钥交换，让 B 误以为和你完成了密钥交换。现在，由 A -&gt; B完整的加密，变成了 A（加密连接1） -&gt; M（明文）-&gt;B（加密连接2）的情况了。这时候 M 依然可以知道 A 和 B 传输中的全部信息。</p>
<p>对于这种事，我们似乎很难找到一个解决方法来解决这个问题，除非我们能从源头保证，你密钥交换的对象是安全的。这时候我们就要认识互联网 HTTPS 和你传纸条的微妙区别了。你传纸条时，你和你的目的地的关系几乎是对等的。而你访问网站时，你访问的对象通常是一个比较大的服务供应商，他们有充沛的资源，也许可以证明他们的合法性。</p>
<p>这时候我们会引入一个第三方叫做 CA。CA 是一些非常权威的专门用于认证一个网站合法性的组织。服务商可以向他们申请一个证书，使得他们建立安全连接时可以带上 CA 的签名。而 CA 的安全性由操作系统或浏览器来认证。你的 Windows、Mac、Linux、Chrome、Safari 等会在安装时带上一个他们认为安全的 CA 证书列表。如果和你建立安全连接的人带着这些人的签名，那么认为这个安全连接是安全的，没有遭到中间人攻击。</p>
<p>CA 证书通常情况下是安全的。因为一旦某个 CA 颁发出的某个证书被用于了非法用途，浏览器和操作系统一般会通过更新将整个 CA 颁发过的全部证书全部视为不安全。这使得 CA 通常在颁发证书时是比较小心的。</p>
<p>所以通过 对称加密 + 非对称加密 + CA认证 这三个技术混合在一起，才使得 HTTP 的后面加上了一个 S —— Security。实际上 HTTPS 的协议比我这里描述的更复杂一些，我这里说的主要是基本的实现原理。因为其中任何一环稍有闪失，就会使得整个加密都将变得不安全。这也是为什么 HTTPS 的加密协议从SSL 1.0 升级到 SSL 3.0 再被 TLS 1.0 现在被 TLS 1.2 取代，其背后都是一环环细节上的修改，以防任何地方的闪失。</p>
<p>但即使如此，你的 HTTPS 尽可能的保证了你传输的安全，但这种安全也不是绝对的。比如 CA 证书出了问题被用于了中间人攻击，在短期内，你的安全将会陷入直接的麻烦直到浏览器或操作系统重新更新了你的 CA 列表或者你手动调整了这个列表。但大多情况下不必杞人忧天，它基本上是安全的。</p>
<p>当然了，路由也可以选择直接丢包，它看不到的，也不让你看到。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每当我们讨论到信息安全的时候，我们最长接触到的信息加密传输的方式莫过于 HTTPS 了，当我们浏览器地址栏闪现出绿色时，就代表着这个网站支持 HTTPS 的加密信息传输方式，并且你与它的连接确实被加密了。但是 HTTPS 并不是一个单一的东西，它知识我们常见的 HTTP 协议和某个加密协议的一个混合，这个加密协议通常会是 TLS。那么 HTTPS 为什么安全呢？其实我们需要先考虑 HTTP 为什么不安全。&lt;/p&gt;
    
    </summary>
    
    
      <category term="安全" scheme="http://blog.heckpsi.com/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="HTTPS" scheme="http://blog.heckpsi.com/tags/HTTPS/"/>
    
      <category term="通讯" scheme="http://blog.heckpsi.com/tags/%E9%80%9A%E8%AE%AF/"/>
    
  </entry>
  
</feed>

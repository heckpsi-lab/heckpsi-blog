<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HeckPsi Lab</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.heckpsi.com/"/>
  <updated>2016-04-21T15:36:12.000Z</updated>
  <id>http://blog.heckpsi.com/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HeckPsi 2016 全新博客系统</title>
    <link href="http://blog.heckpsi.com/2016/04/21/heckpsi-blog-2016/"/>
    <id>http://blog.heckpsi.com/2016/04/21/heckpsi-blog-2016/</id>
    <published>2016-04-21T14:56:14.000Z</published>
    <updated>2016-04-21T15:36:12.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;HeckPsi 博客 2016 迎来了巨大的改版！&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;这是个啥？&quot;&gt;&lt;a href=&quot;#这是个啥？&quot; class=&quot;headerlink&quot; title=&quot;这是个啥？&quot;&gt;&lt;/a&gt;这是个啥？&lt;/h3&gt;&lt;p&gt;正如你所见，HeckPsi 的全新博客系统变得非常地 &lt;em&gt;清新&lt;/em&gt; 。在深思熟虑之后，我们发现，以前的主页，看似非常炫酷，实则净是废话。于是借由 HeckPsi 主页改版的机会，HeckPsi 博客系统也迎来了巨大的更新！&lt;/p&gt;
&lt;h4 id=&quot;这个博客用来干什么？&quot;&gt;&lt;a href=&quot;#这个博客用来干什么？&quot; class=&quot;headerlink&quot; title=&quot;这个博客用来干什么？&quot;&gt;&lt;/a&gt;这个博客用来干什么？&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;发布对于业内见闻的评论&lt;/li&gt;
&lt;li&gt;发布对科技相关的科普&lt;/li&gt;
&lt;li&gt;发布我们所坚持的价值观&lt;/li&gt;
&lt;li&gt;&lt;del&gt;瞎搞&lt;/del&gt; 实验性内容&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;所以，我们的博客需要什么&quot;&gt;&lt;a href=&quot;#所以，我们的博客需要什么&quot; class=&quot;headerlink&quot; title=&quot;所以，我们的博客需要什么&quot;&gt;&lt;/a&gt;所以，我们的博客需要什么&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;清晰高效的排版&lt;/li&gt;
&lt;li&gt;便于快速编辑（Markdown 什么的最好，可视化编辑器太累）&lt;/li&gt;
&lt;li&gt;静态化的页面&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;于是就有了现在你所看到的博客系统。它使用了 &lt;a href=&quot;https://github.com/hexojs/hexo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;hexo&lt;/a&gt; 项目生成静态页面，以及使用了 &lt;a href=&quot;https://github.com/pinggod/hexo-theme-apollo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;hexo-theme-apolo&lt;/a&gt; 项目的主题，并进行了一定地定制开发。&lt;/p&gt;
&lt;p&gt;相比之下，我们拥有了更加强大地对网站的控制权利，可以做更多地功能模块的定制，以进一步满足我们未来的要求。至于为什么没有使用 &lt;a href=&quot;https://jekyllrb.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Jekyll&lt;/a&gt; ，单纯是因为 hexo 更适合做博客，而 Jekyll 什么都适合做，有些无从下手。&lt;/p&gt;
&lt;h3 id=&quot;停更的几个月发生了啥？&quot;&gt;&lt;a href=&quot;#停更的几个月发生了啥？&quot; class=&quot;headerlink&quot; title=&quot;停更的几个月发生了啥？&quot;&gt;&lt;/a&gt;停更的几个月发生了啥？&lt;/h3&gt;&lt;p&gt;首先，HeckPsi 成立了在国内注册的公司，并以此申请了备案。所以我们的服务器现在可以运行在中华人民共和国境内，以提供更快的服务。&lt;/p&gt;
&lt;p&gt;其次，我们深刻考虑了我们未来的业务形态。最近也将会有比较大的动向，开出某个全新的板块，以及某些神秘的产品，尽请期待。&lt;/p&gt;
&lt;p&gt;最后就是旧博客的数据之前放在 AWS Japan 上，出了一些小问题，差点丢失。幸好已经通过完备的日志系统还原了大部分数据，并且将于近期还原。未来我们的博客数据都会实现多点异地备份，保证其安全性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;承蒙各位厚爱，HeckPsi 会坚持做下去。&lt;/strong&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;HeckPsi 博客 2016 迎来了巨大的改版！&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="站务" scheme="http://blog.heckpsi.com/tags/%E7%AB%99%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>认识 Y-Combinator</title>
    <link href="http://blog.heckpsi.com/2016/03/19/learn-y-combinator/"/>
    <id>http://blog.heckpsi.com/2016/03/19/learn-y-combinator/</id>
    <published>2016-03-19T00:50:00.000Z</published>
    <updated>2016-04-21T16:04:54.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;写在开始&quot;&gt;&lt;a href=&quot;#写在开始&quot; class=&quot;headerlink&quot; title=&quot;写在开始&quot;&gt;&lt;/a&gt;写在开始&lt;/h2&gt;&lt;p&gt;不得不说，当我开始学习函数式编程的时候，我并没有被匿名函数感到害怕，理解它的基本概念是极其容易的。但是当你试图去将你日常所书写的指令式的代码转换成函数式，特别是纯函数式的时候，你会感到这是不可能的。它和你之前的编程思想是完全脱离的。&lt;/p&gt;
&lt;p&gt;所以当我第一次见到 Y-Combinator（Y 组合子）的时候，我的感觉是懵逼的，这是什么玩意。然而当我一步一步，了解这个东西是什么，它是怎么工作的之后，我对函数式编程的认识有了很大的进步。&lt;/p&gt;
&lt;p&gt;即使是 C++ 这样的语言，也在 C++11 标准中引入了匿名函数，使得你有机会在 C++ 中使用函数式编程的特性。在编程中，如果能适当地使用函数式语法进行编程，将非常有助于你写出一些更好理解、更简单的代码。&lt;/p&gt;
&lt;p&gt;而在了解一些基本概念之后，了解一下 Y-Combinator 是一个极好的选择，这个东西证明了函数式编程对递归的语义理解，证明了其在递归上和指令式编程的等价之处。你可以通过观察等价的这两者的不同的实现方式，来加深对这两者思想的认识。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;与指令式编程的根本区别&quot;&gt;&lt;a href=&quot;#与指令式编程的根本区别&quot; class=&quot;headerlink&quot; title=&quot;与指令式编程的根本区别&quot;&gt;&lt;/a&gt;与指令式编程的根本区别&lt;/h2&gt;&lt;p&gt;大家看下面一段 C 代码&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;; i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;显然这是一个非常常见的循环。然而这样的循环显然已经被抽象过了，我们也许可以用一个更原始的方法来实现。且让我引入一个 C 开发中应尽量避免的语句 &lt;code&gt;goto&lt;/code&gt; 来解释。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;loop:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (i &amp;gt;= &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;goto&lt;/span&gt; next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;i++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;goto&lt;/span&gt; loop;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;next:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这两段代码除了变量 &lt;code&gt;i&lt;/code&gt; 的作用域有所区别以外几乎是等价的。相对的，第二段代码非常接近于编译到汇编时的指令，几乎是一一映射的。然而你可以发现，我们的循环都是依赖于跳转代码行数的，不得不说这种写法非常不函数式。&lt;/p&gt;
&lt;h2 id=&quot;第一个函数&quot;&gt;&lt;a href=&quot;#第一个函数&quot; class=&quot;headerlink&quot; title=&quot;第一个函数&quot;&gt;&lt;/a&gt;第一个函数&lt;/h2&gt;&lt;p&gt;我们可以用一个递归来把这个循环实现地更像一个函数：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (n == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) return &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  return loop(n - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;loop(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;虽然这个函数是倒过来循环的，但我们大可忽略这些细节，毕竟要做修改也是相对容易的。我们通过一个函数递归的方式来实现了一个循环。需要特别注意的是，如果根据递归的定义，那么这个循环一旦大起来在今天我们的计算机的计算模型（而不是 Lisp Machine）上是会爆栈的，但好在由于是个尾递归，通常是会直接被编译器优化成一个循环的。这确保了即使你写的是函数式代码，也可以最终编译成适合 CPU 运算的形式而不太影响性能。&lt;/p&gt;
&lt;p&gt;不过递归有一个问题，我们必须知道函数的名称才能这么做，在真正的 Lambda 运算模型上，函数是匿名的，也就是没有名字，这样你最后根本就无处调用你函数自己。因为你无法写出下面的代码（Ruby）：&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;lambda &amp;#123; &lt;span class=&quot;params&quot;&gt;|n|&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; n == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  puts &lt;span class=&quot;string&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  what_the_f**k_my_function_name_is(n-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;魔法少女-Lambda-酱&quot;&gt;&lt;a href=&quot;#魔法少女-Lambda-酱&quot; class=&quot;headerlink&quot; title=&quot;魔法少女 Lambda 酱&quot;&gt;&lt;/a&gt;魔法少女 Lambda 酱&lt;/h2&gt;&lt;p&gt;下面我们演示一种黑魔法，来使得你没有办法得到自己函数名时实现递归。简单来说就是把「函数」当成一个「参数」传输。&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;loop = lambda &amp;#123;&lt;span class=&quot;params&quot;&gt;|f, n|&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; n == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  puts &lt;span class=&quot;string&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  f.call(n-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;loop.call(loop, &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们把函数本身作为一个参数传了进去，达到了我们的想法。不过这里我们还不是一个完全的匿名函数，而是通过给匿名函数起了一个名字 &lt;code&gt;loop&lt;/code&gt;，在外面调用了一下。不过事到如今，去掉这个 &lt;code&gt;loop&lt;/code&gt; 已经很容易了。由于第一条的匿名函数定义中没有任何地方用到 &lt;code&gt;loop&lt;/code&gt; 只在第二条指令中用到。我们只要将第二条指令中的所有 &lt;code&gt;loop&lt;/code&gt; 都代换掉就行。我们就能得到下面的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;lambda &amp;#123;&lt;span class=&quot;params&quot;&gt;|f, n|&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; n == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  puts &lt;span class=&quot;string&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  f.call(n-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;.call(lambda&amp;#123;&lt;span class=&quot;params&quot;&gt;|f, n|&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; n == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    puts &lt;span class=&quot;string&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    f.call(n-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;, &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;柯里化，最后一步&quot;&gt;&lt;a href=&quot;#柯里化，最后一步&quot; class=&quot;headerlink&quot; title=&quot;柯里化，最后一步&quot;&gt;&lt;/a&gt;柯里化，最后一步&lt;/h2&gt;&lt;p&gt;Amazing！我们通过一个匿名函数的调用成功实现了一个 100 的循环。我们现在距离 Haskell Brooks Curry 先生当年推出 Y 组合子只差一步，那就是将我们做的事情「Currying」（柯里化）。所谓 Currying 就是使用一个高阶函数，将一个函数的多个参数精简成一个。我们看到我们现在的匿名函数还有 &lt;code&gt;f&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt; 两个参数，我们打算拿掉它。虽然其实并不是真正意义上的拿掉。柯里化，只不过把一个形如 &lt;code&gt;f(x, y)&lt;/code&gt; 的函数写成了 &lt;code&gt;f(x)(y)&lt;/code&gt;，也就是 &lt;code&gt;f(x)&lt;/code&gt; 的返回是一个匿名函数，而这个匿名函数再以 &lt;code&gt;y&lt;/code&gt; 为参数执行一次。这么搞一下，我们就得到了：&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;lambda &amp;#123;&lt;span class=&quot;params&quot;&gt;|p|&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; lambda &amp;#123; &lt;span class=&quot;params&quot;&gt;|f|&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; f.call(f);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;.call(lambda &amp;#123;&lt;span class=&quot;params&quot;&gt;|f|&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; p.call(lambda &amp;#123;&lt;span class=&quot;params&quot;&gt;|x|&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; f.call(f).call(x)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;.call(lambda &amp;#123;&lt;span class=&quot;params&quot;&gt;|f|&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; lambda &amp;#123;&lt;span class=&quot;params&quot;&gt;|i|&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; i == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      f.call(i-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;).call(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;由于柯里化后匿名函数和调用的参数都单一了，我们因此可以保证我们能将任意一个递归都表达成一个匿名函数的形式。按照 Lambda 演算的形式化表达  &lt;code&gt;Y := λf.(λx.(f (x x)) λx.(f (x x)))&lt;/code&gt; 。你只要将自己要递归的函数替换掉里面 &lt;code&gt;f&lt;/code&gt; 的位置，并最后执行一下这个匿名函数就成啦~&lt;/p&gt;
&lt;h2 id=&quot;折腾半天干什么&quot;&gt;&lt;a href=&quot;#折腾半天干什么&quot; class=&quot;headerlink&quot; title=&quot;折腾半天干什么&quot;&gt;&lt;/a&gt;折腾半天干什么&lt;/h2&gt;&lt;p&gt;你肯定想问，我们把一个循环写成这么复杂是为了什么。事实上我想展示的不是循环，而是递归。递归在图灵模型（我们通常 CPU 的计算模型）和丘奇模型（Lambda 演算）上都不是那么地原生的实现。&lt;/p&gt;
&lt;p&gt;在图灵模型上地最终形式是每次递归，追加进内存中，并重新 &lt;code&gt;goto&lt;/code&gt; 回函数开始，在退出时，再一步步内存推出来，并将递归的剩余部分执行完。&lt;/p&gt;
&lt;p&gt;而在 Lambda 演算中，最终表达为一个逻辑系统构成的严格的数学函数模型的执行。&lt;/p&gt;
&lt;p&gt;这两者便是具体化和形式化的极限，充分表现了两种模型的特点。从根本加深了对两种模型差异的认知，从而让我们在两种模型上都能通过正确的编程思想来写代码，以把代码写得更好。&lt;/p&gt;
&lt;p&gt;当然也是有一些实际意义的，比如在变量作用域严格的语言中，且又必须使用匿名函数的形式来书写你所需要的东西的时候，而你正好又需要递归才能达到你的要求，那么使用 Y-Combinator 是一个可选的方法。然而通常，出现这种情况大多是你写了错误的思想的代码所导致的，实际编程中几乎遇不到这种情况，毕竟将更抽象更容易理解的函数式编程写成这么一坨一眼看不懂的代码是很失败的。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在开始&quot;&gt;&lt;a href=&quot;#写在开始&quot; class=&quot;headerlink&quot; title=&quot;写在开始&quot;&gt;&lt;/a&gt;写在开始&lt;/h2&gt;&lt;p&gt;不得不说，当我开始学习函数式编程的时候，我并没有被匿名函数感到害怕，理解它的基本概念是极其容易的。但是当你试图去将你日常所书写的指令式的代码转换成函数式，特别是纯函数式的时候，你会感到这是不可能的。它和你之前的编程思想是完全脱离的。&lt;/p&gt;
&lt;p&gt;所以当我第一次见到 Y-Combinator（Y 组合子）的时候，我的感觉是懵逼的，这是什么玩意。然而当我一步一步，了解这个东西是什么，它是怎么工作的之后，我对函数式编程的认识有了很大的进步。&lt;/p&gt;
&lt;p&gt;即使是 C++ 这样的语言，也在 C++11 标准中引入了匿名函数，使得你有机会在 C++ 中使用函数式编程的特性。在编程中，如果能适当地使用函数式语法进行编程，将非常有助于你写出一些更好理解、更简单的代码。&lt;/p&gt;
&lt;p&gt;而在了解一些基本概念之后，了解一下 Y-Combinator 是一个极好的选择，这个东西证明了函数式编程对递归的语义理解，证明了其在递归上和指令式编程的等价之处。你可以通过观察等价的这两者的不同的实现方式，来加深对这两者思想的认识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Lambda 编程 Lisp" scheme="http://blog.heckpsi.com/tags/Lambda-%E7%BC%96%E7%A8%8B-Lisp/"/>
    
  </entry>
  
  <entry>
    <title>AlphaGo 是怎么下棋的？</title>
    <link href="http://blog.heckpsi.com/2016/03/18/how-alphago-works/"/>
    <id>http://blog.heckpsi.com/2016/03/18/how-alphago-works/</id>
    <published>2016-03-18T15:09:00.000Z</published>
    <updated>2016-04-21T16:11:11.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本来其实不想写这个的，但是看到很多网友以及一些围棋职业选手提出了一些疑问，比如「Google 没有顶尖的棋手为什么能开发出顶尖的围棋机器人？」还有「机械为什么可以在如此直觉主导的游戏中战胜人类？」。这些问题事实上在人工智能领域已经有很多理论来做解释。而且这些理论也并不是 Google 提出的。AlphaGo 所使用的理论大多还是十余年前左右的论文的一些成果。在此之前，使用了这些理论开发出来的人工智能其实已经在 2006 年就已经在 9x9 的小棋盘上战胜周俊勋九段，之后在 2013 年 CrazyStone 程序就已经在让四子前提下战胜过石田芳夫九段，而就在去年，Facebook 的围棋机器人在不让子的前提下，胜过职业选手。至于之前「前百度深度学习研究院」的吴韧所开发的异构神机也使用的是类似的理论，也在前几天战胜过职业棋手。&lt;/p&gt;
&lt;p&gt;这些方法上，AlphaGo 并无太大创新，很大程度上是 Google 团队实现得相对完善以及训练程度更好，以及人工智能算法的实现和调参存在很大的偶然因素。那么究竟是什么方法让机械拥有了和人一样直觉，而不是简单的机械化的思考。这事我们还是要从头讲起。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;无法计算的数据量&quot;&gt;&lt;a href=&quot;#无法计算的数据量&quot; class=&quot;headerlink&quot; title=&quot;无法计算的数据量&quot;&gt;&lt;/a&gt;无法计算的数据量&lt;/h2&gt;&lt;p&gt;早在 1996 年，IBM 的深蓝计算机就战胜了国际象棋世界名将加里·卡斯帕罗夫。但象棋有一个特点，那就是每一步下的选择是相对非常有限的，最多也就十几种可能。哪怕是通过最最暴力的搜索方法，把每种都跑一遍，搜索几十步内的最优解。虽然这个方法随着搜索深度是指数级增长的，但事实上由于底数比饺小，依靠强大的算力还是可以解决的。而深蓝计算机正是这么一台拥有强大算力的超级计算机。&lt;/p&gt;
&lt;p&gt;然而在围棋上，这样就不行了，因为围棋每一步都有上百种选择，如此大的底数纯粹的暴力就显然无法满足了。至少硬件的发展并非每年成百倍成百倍地快速增长的。同样的方法，显然是不适合使用在围棋上的。&lt;/p&gt;
&lt;p&gt;在 2002 年之前，人们长期研究一个可以通过计算静态地分析出每一子的价值出来。然而这个方法的发展一直很慢。直到人们试图尝试一种动态评估一个博弈的一种方法，这就是靠&lt;strong&gt;猜&lt;/strong&gt;。这个方法被称为蒙特卡洛搜索树，其前身是非常著名的上世纪曼哈顿计划期间由乌拉姆和冯·诺依曼提出的&lt;strong&gt;蒙特卡洛方法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果我们想知道圆周率的值，我们如何利用猜的方法来猜出圆周率呢？我们只需要在一个方形中随机而均匀地扔飞镖，数一下，多少个飞镖扔在了以方形边长为直径的圆里，多少扔在了外面，根据圆的面积公式和方形的面积公式就能把 π 算出来。而蒙特卡洛搜索树就是利用蒙特卡洛方法来优化搜索树。简单来说，就是，我们认为这一步下在一个地方是最优的，而我们不知道这地方在哪里。我们先通过一系列随机的采样，从而去猜测一个值，这个值可能是最优解，也可能是一个接近最优解的解。但至少，这可以用来估算像围棋这样大的棋盘的东西了，而不需要把每个细枝末节都同等对待地来暴力搜索。&lt;/p&gt;
&lt;h2 id=&quot;⑨神的大局观&quot;&gt;&lt;a href=&quot;#⑨神的大局观&quot; class=&quot;headerlink&quot; title=&quot;⑨神的大局观&quot;&gt;&lt;/a&gt;⑨神的大局观&lt;/h2&gt;&lt;p&gt;解决完计算量的问题，我们还要来解决人类在围棋上最大的优势——直觉，或者说「大局观」。那么如何才能拥有大局观呢？我们想一下，人们在下围棋的时候，通常会先考虑下在哪个片区，以获得什么样的目的。而这就是所谓的大局观。&lt;/p&gt;
&lt;p&gt;AlphaGo 的另一部分重要思想，得益于神经科学的发展，即人类认识人大脑神经的发展。人类愈发了解了大脑内神经元的工作模式，包括人类学习、认知的神经模型。这样的非常基础的模型，极大地方便了利用计算机来模拟人类进行学习的过程。&lt;/p&gt;
&lt;p&gt;蒙特卡洛方法只是简化了计算，并不具备学习的能力。无论是单纯的蒙特卡洛搜索还是与 α-β 搜索结合的还是和置信区间结合一些版本，都与人类能越学越强的围棋技巧相比差上太多。至少，人脑是一个极其复杂的计算模型，哪怕是现在最好的计算机，其算力和整个大脑比起来还是差很多的。&lt;/p&gt;
&lt;p&gt;在 2007 年，一些科学家试图提出一个新的机器学习模型，即所谓的深度学习。所谓深度学习，你可以看做模拟许多许多人脑中的神经元构成的一个网络。网络的每一层，针对一个特性进行识别。网络的每一层，都是一个单纯分类的无监督学习模型。你可以想像一下，人眼看到一个图像。经过一系列神经元，首先识别出了里面的眼睛、然后识别了里面的鼻子、嘴，再根据这些特性，发现这是一个人。这样依次发现的机制。而学习是通过一个有监督的反向传播进行。即告诉你这张图像里有一条狗，然后反向的一步步调整网络，让网络适应符合怎么样鼻子、嘴、眼睛的是一条狗。通过不断地数据的训练，即可以让模型越来越优。这个模型在图像识别领域已经达到甚至有时超越了人的识别能力。&lt;/p&gt;
&lt;p&gt;而 AlphaGo 使用的就是深度学习来优化蒙特卡洛搜索树。在 AlphaGo 中有两个网络，一个是策略网络，一个是价值网络。策略网络即是一个大局观的网络，机器会先通过其经验，找出其应该做出进攻的反应还是防守的反应，表现在下在哪个片区是最为合适的，是不是应该跟棋之类的大问题。然后再通过蒙特卡洛搜索树去算出具体下在哪里是最合适的。&lt;/p&gt;
&lt;p&gt;而我们说到，深度学习模型是真的和人一样可以学习的。每下一次棋，它就可以进一步调优自己的策略网络。首先 AlphaGo 导入了上千个职业选手对弈的棋谱，使得自己有了一个基础的下棋策略。这时候的 AlphaGo 就和一个受过系统训练的围棋少年一样了。然而这和职业选手的区别还是很大。这也就是所谓的「Google 没有顶尖的棋手为什么能开发出顶尖的围棋机器人？」按照一般常理，AlphaGo 应该一段一段地和人挑战，越发提高自己能力。然而 AlphaGo 不是这么做的，它选择和自己对弈。两台 AlphaGo 来对弈，将对弈的结果调优自己的网络。这个听起来很奇怪，为什么两个下得都不怎么样的棋手一起下棋，棋艺能那么快提升呢？因为它一天能和自己下上百万盘棋，它可以把自己分身成几万份跑在几万台电脑上，以及可以昼夜不停也不会过劳死，而这是任何一个人类都做不到的。AlphaGo 的开发人员说，他曾在早期能下赢 AlphaGo，而很快，AlphaGo 的水平就远超了他。所以 AlphaGo 得到了飞速的提升。仅仅五六个月，AlphaGo 就能从战胜欧洲棋王挑战到世界顶尖选手的水平了。&lt;/p&gt;
&lt;h2 id=&quot;人工智能的基本法&quot;&gt;&lt;a href=&quot;#人工智能的基本法&quot; class=&quot;headerlink&quot; title=&quot;人工智能的基本法&quot;&gt;&lt;/a&gt;人工智能的基本法&lt;/h2&gt;&lt;p&gt;当然搞人工智能也要有基本法。这个基本法就是算力或者说是资源。虽然做了很大的优化，计算下围棋的计算量还是很大的。比起深蓝时依靠超级计算机来解决问题。AlphaGo 选择了一条适合 Google 的路径来解决算力问题。那就是分布式计算。使用分布式计算的 AlphaGo 版本比起不使用的版本其智能程度也是有相当大的提升。即使最简单，它也可以有更多时间来做随机的尝试，以找出更优的价值解。&lt;/p&gt;
&lt;p&gt;同样利用深度学习优化蒙特卡洛搜索的 Facebook 围棋团队，相比 Google 就没有那么壕力冲天了。无论是开发资源还是人员来说也是远少于 Google。Facebook 的围棋机器人之前也取得了相当好的成绩，大概可以击败职业二段选手的水平。但是比起 AlphaGo，还是差上许多。&lt;/p&gt;
&lt;p&gt;所以说，做这么一个人智能，背后的投入程度、重视程度也起到了很大的作用。这也是为什么深度学习目前做得很好的公司大多是一些顶尖的 IT 企业里的研发团队。&lt;/p&gt;
&lt;h2 id=&quot;后记&quot;&gt;&lt;a href=&quot;#后记&quot; class=&quot;headerlink&quot; title=&quot;后记&quot;&gt;&lt;/a&gt;后记&lt;/h2&gt;&lt;p&gt;比起 AlphaGo 在围棋上的成就，其实大多数人很好奇人工智能未来的何去何从。从这次中，我们看到计算机已经具备了人类大局判断能力，其本质是类似于人类的学习能力，即不告诉电脑应该怎么做，而让电脑看人类是怎么做的。这项的应用其实相当广泛，尤其在非常复杂的问题上。&lt;/p&gt;
&lt;p&gt;比如说，无人驾驶汽车之前发展很困难，是因为人们总是试图去把驾驶规则完全讲给电脑，而这点太过复杂，难以用纯逻辑说清。而今天 Google 的无人驾驶汽车也是使用的类似的深度学习的技术，让计算机观察人类开车并学习，从而模仿人类的判断。最终依靠计算机强大的算力和不会疲劳等特点，甚至超越人类的判断。&lt;/p&gt;
&lt;p&gt;短期来看，利用深度学习的人工智能在未来数年内将会得到很大的应用。而这也是 Google 热衷于下围棋的原因。醉翁之意不在酒，在乎山水之间也。Google 只是想利用围棋来显示他们在深度学习应用上的先进水平。&lt;/p&gt;
&lt;p&gt;就人工智能的最终目的来看，我们已经跨出了很大的一步。之前而言，我们很大程度局限于人类强大的抽象的思考能力，而模仿人类神经系统的模型已经很好地模拟了这种思考是怎么产生的了。进一步说，如果一个机器，拥有和人完全一样的眼睛、耳朵、鼻子、触觉等作为它的输入，以及类似于人类肌肉和关节的机械部件作为它的输出。并且模拟一个和人脑一样复杂程度的神经网络，并让它观察人类进行学习。是不是在某个未来，我们可以拥有和人类功能非常接近甚至超越人类的智能的出现。深度学习都为这样的强人工智能提出了理论上的基础。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本来其实不想写这个的，但是看到很多网友以及一些围棋职业选手提出了一些疑问，比如「Google 没有顶尖的棋手为什么能开发出顶尖的围棋机器人？」还有「机械为什么可以在如此直觉主导的游戏中战胜人类？」。这些问题事实上在人工智能领域已经有很多理论来做解释。而且这些理论也并不是 Google 提出的。AlphaGo 所使用的理论大多还是十余年前左右的论文的一些成果。在此之前，使用了这些理论开发出来的人工智能其实已经在 2006 年就已经在 9x9 的小棋盘上战胜周俊勋九段，之后在 2013 年 CrazyStone 程序就已经在让四子前提下战胜过石田芳夫九段，而就在去年，Facebook 的围棋机器人在不让子的前提下，胜过职业选手。至于之前「前百度深度学习研究院」的吴韧所开发的异构神机也使用的是类似的理论，也在前几天战胜过职业棋手。&lt;/p&gt;
&lt;p&gt;这些方法上，AlphaGo 并无太大创新，很大程度上是 Google 团队实现得相对完善以及训练程度更好，以及人工智能算法的实现和调参存在很大的偶然因素。那么究竟是什么方法让机械拥有了和人一样直觉，而不是简单的机械化的思考。这事我们还是要从头讲起。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AlphaGo AI Google 机器学习 科普" scheme="http://blog.heckpsi.com/tags/AlphaGo-AI-Google-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%A7%91%E6%99%AE/"/>
    
  </entry>
  
</feed>

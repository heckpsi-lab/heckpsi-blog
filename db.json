{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/apollo/source/favicon.png","path":"favicon.png","modified":1,"renderable":1},{"_id":"themes/apollo/source/logo.png","path":"logo.png","modified":1,"renderable":1},{"_id":"themes/apollo/source/css/apollo.css","path":"css/apollo.css","modified":1,"renderable":1},{"_id":"themes/apollo/source/scss/apollo.scss","path":"scss/apollo.scss","modified":1,"renderable":1}],"Cache":[{"_id":"themes/apollo/.gitignore","hash":"a006beea0877a0aa3610ee00e73f62cb1d45125b","modified":1461248075000},{"_id":"themes/apollo/LICENSE","hash":"6e31ac9076bfc8f09ae47977419eee4edfb63e5b","modified":1461248075000},{"_id":"themes/apollo/README.md","hash":"24578c41ed4c22aed948bdd975e7ce25479cb4a9","modified":1462839598000},{"_id":"themes/apollo/_config.yml","hash":"bb6421b03692b7c1181d8921213b7b1d998cd138","modified":1462840004000},{"_id":"themes/apollo/gulpfile.js","hash":"857a026b6643a2cd52c65d4ae0dc7fe9618206ee","modified":1461248075000},{"_id":"themes/apollo/package.json","hash":"9426138c09ebb95969021d951590c0c54b187a43","modified":1461248075000},{"_id":"source/_posts/ads-on-videos-in-china.md","hash":"fa0743b22a72286910383918da27487eb3393939","modified":1461307703000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1461305335000},{"_id":"source/_posts/android-hot-patch.md","hash":"d1eaac7d855a552948d5b9701690524bf27d55dc","modified":1461256413000},{"_id":"source/_posts/anti-virus-softwares-in-china.md","hash":"76607ebfe397a9cdb3667a7467d305661c4496a9","modified":1461416602000},{"_id":"source/_posts/apology-to-visitors.md","hash":"7b18b13b6d56ec2c2c0b3fe8b122342f9602fc2d","modified":1461307834000},{"_id":"source/_posts/application-of-bayes-theorem.md","hash":"74cfffc4a91c64ef5619ff6e2772979ca1ad48ee","modified":1463282412000},{"_id":"source/_posts/can-a-program-runs-faster-when-data-goes-larger.md","hash":"575289de076e124dc2a2d2f6f61f911c73511b4a","modified":1461415938000},{"_id":"source/_posts/customized-machanical-keyboard.md","hash":"2ea1b262302955e579657d13ae8ef19f3dd7f142","modified":1463282412000},{"_id":"source/_posts/danger-of-hybrid-apps.md","hash":"ef09d40072de846a3b78231970dcb186e8be4f67","modified":1463282412000},{"_id":"source/_posts/fix-nexus-5-lens.md","hash":"ad205c1a301b8db96846ca581e585024ab2f616b","modified":1463282412000},{"_id":"source/_posts/from-no-response-to-godels-incompleteness.md","hash":"dec5029207cbbf6caa8b43ca7f3f6b30fe33fb90","modified":1461416253000},{"_id":"source/_posts/google-io-2014.md","hash":"a91c842eecf4895a985ac70a9d1fa01402df9a0d","modified":1461308445000},{"_id":"source/_posts/google-io-2016-review.md","hash":"fd8de7241b02dd7af295d3798662ff8770d02a5a","modified":1463664652000},{"_id":"source/_posts/gossip-of-spartan.md","hash":"e78c8c02d25afac087608fb319e0bf706e50b218","modified":1461259875000},{"_id":"source/_posts/heckpsi-blog-2016.md","hash":"90d21a2245207e1df690e51417ae9a0cbfd41e1d","modified":1461252972000},{"_id":"source/_posts/how-alphago-works.md","hash":"02163978c1493922641c22cd914b0ae28aae78db","modified":1461258940000},{"_id":"source/_posts/how-cmos-works.md","hash":"55837298da6c93595a72deefacd93e4036cefbd2","modified":1463282412000},{"_id":"source/_posts/how-to-test-a-font.md","hash":"6524e6293ebfb1c14d72519173665b4aeb00f7b6","modified":1463282412000},{"_id":"source/_posts/how-https-makes-communication-secured.md","hash":"bd5488fce9a9eb6a498de2c5429644d8d5e10c5f","modified":1461263531000},{"_id":"source/_posts/learn-y-combinator.md","hash":"bca714282f2c69fa13f10a7ecc903bd249937919","modified":1461256452000},{"_id":"source/_posts/problems-of-it-textbooks-now.md","hash":"0e1bf79272ff6703a35f689ab14f805fb678065c","modified":1461433983000},{"_id":"source/_posts/project-genji.md","hash":"16f3c1f3c25e1316914be2d69c0f37f63fa32cae","modified":1471340880000},{"_id":"source/_posts/ruby-on-php-abc.md","hash":"d6cb7b56a6132dfa2ad38ef51bd0bba09898ab65","modified":1465600091000},{"_id":"source/_posts/things-about-android-touchkeys.md","hash":"dd0f22f80ae81283a5a8321f453dca1aae38acc9","modified":1463282412000},{"_id":"source/_posts/super-amoled-introduction-part-1.md","hash":"f6f6d9a65c1a51ff830e1de5ba9c7a03d75fe5ab","modified":1461256433000},{"_id":"source/_posts/synesthesia.md","hash":"a6e7ea67b0bb28644947718b8baa16768478287a","modified":1461307960000},{"_id":"source/_posts/things-about-dpi.md","hash":"795962c4d167b0feb4ee078e54a9fc781125dfd5","modified":1463282412000},{"_id":"source/_posts/things-behind-price-down-of-data.md","hash":"52aeab18ab185048d9c854da412426fff2e869ea","modified":1461417096000},{"_id":"source/_posts/what-is-ddos.md","hash":"c91779e70b0378c4606009f7c2d044a53cad6441","modified":1461293789000},{"_id":"source/_posts/what-is-equal-rights.md","hash":"7716a90a902d51e86bd699b7316b0318f8801b8c","modified":1461417401000},{"_id":"source/_posts/what-is-hit-library.md","hash":"6cbc49a2376cef06e88823c341352f715062221e","modified":1461415587000},{"_id":"source/_posts/why-material-design-pushes-difficult-in-china.md","hash":"7fd8c271b5437e40d7a149d9981f212e3f0313c5","modified":1463282412000},{"_id":"source/_posts/why-retina-isnt-enough.md","hash":"6180fa59d2784733ed8a9250ff66eead41843f16","modified":1463282412000},{"_id":"source/_posts/workstation-setup-guide.md","hash":"c425c1007483083f7b9a025a7d7247ecead72d84","modified":1466513748000},{"_id":"themes/apollo/.git/COMMIT_EDITMSG","hash":"83177b45c5f099bf45c34615bd7feb2128e8c78a","modified":1462839577000},{"_id":"themes/apollo/.git/ORIG_HEAD","hash":"bcc5571f275112b0d1f203c321fe80795462d8b5","modified":1462839778000},{"_id":"themes/apollo/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1461248075000},{"_id":"themes/apollo/.git/FETCH_HEAD","hash":"5bd3107d3ee154b442cd923f312d6f6362a1f5b0","modified":1472214246000},{"_id":"themes/apollo/.git/config","hash":"e8486e77527181934f2dda23e50b879ab7641244","modified":1461248075000},{"_id":"themes/apollo/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1461248070000},{"_id":"themes/apollo/.git/index","hash":"daad80e8a786e033f2fdca7e323a0a7e1869b986","modified":1472214217000},{"_id":"themes/apollo/.git/packed-refs","hash":"13b0ac0db6e07d28d82ad1a3890d4c1f45c0153a","modified":1461248075000},{"_id":"themes/apollo/.git/sourcetreeconfig","hash":"7152bc7cd5254052ee771df5ae3fbe8f1973e7d6","modified":1464591618000},{"_id":"themes/apollo/languages/en.yml","hash":"40292f2a48e4e6361132033a47c516cb33127b6c","modified":1461248075000},{"_id":"themes/apollo/doc/doc-en.md","hash":"d6d9756b2085cdd8ee51eb5594427e2abf170e94","modified":1461248075000},{"_id":"themes/apollo/doc/doc-zh.md","hash":"d43c1f6bff66426744a2c6f031d19ff09cdeb2d1","modified":1461248075000},{"_id":"themes/apollo/layout/archive.jade","hash":"62797414355bf4474092bc3a32726c8340820ffb","modified":1461248075000},{"_id":"themes/apollo/languages/zh-cn.yml","hash":"9e4b03e14c094000257ea254fd660dde4c7af63c","modified":1461248075000},{"_id":"themes/apollo/layout/index.jade","hash":"55f2f1b4b5364a0e09cb18e1112664c6415fb881","modified":1461248075000},{"_id":"themes/apollo/layout/post.jade","hash":"245c26244c075c3632d1545c3b228ee9d112f15d","modified":1462839598000},{"_id":"themes/apollo/source/favicon.png","hash":"af4ad42a0f9c56a6fd0e8a4ac183586e9619ecce","modified":1461424055000},{"_id":"themes/apollo/source/logo.png","hash":"09089694846c9792c54e71a3b678a90823929b14","modified":1461250268000},{"_id":"themes/apollo/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1461248070000},{"_id":"themes/apollo/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1461248070000},{"_id":"themes/apollo/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1461248070000},{"_id":"themes/apollo/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1461248070000},{"_id":"themes/apollo/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1461248070000},{"_id":"themes/apollo/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1461248070000},{"_id":"themes/apollo/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1461248070000},{"_id":"themes/apollo/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1461248070000},{"_id":"themes/apollo/.git/hooks/update.sample","hash":"39355a075977d05708ef74e1b66d09a36e486df1","modified":1461248070000},{"_id":"themes/apollo/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1461248070000},{"_id":"themes/apollo/.git/logs/HEAD","hash":"caa17050086437f437c796a58625de1313174844","modified":1462839598000},{"_id":"themes/apollo/layout/mixins/paginator.jade","hash":"f4ee2fb61a32e199b48cf93771749edc8a007391","modified":1461248075000},{"_id":"themes/apollo/layout/mixins/post.jade","hash":"cd9447e9b0ad22213e6a17d9a9b948f9f998f921","modified":1462839598000},{"_id":"themes/apollo/layout/partial/copyright.jade","hash":"75dd347e08babdcc75bc90b36c4d29923464b4a1","modified":1461598781000},{"_id":"themes/apollo/layout/partial/comment.jade","hash":"ff0a2c269c2434da2ac5529872f1d6184a71f96d","modified":1461248075000},{"_id":"themes/apollo/layout/partial/head.jade","hash":"6315f364ddefbddf42e9ee4a128e9e54778f066c","modified":1462204319000},{"_id":"themes/apollo/layout/partial/layout.jade","hash":"eb15573ff66bdbb110ac77cf360b740170cee738","modified":1461414488000},{"_id":"themes/apollo/layout/partial/scripts.jade","hash":"aec16d074567d0e408b864a42fd11d107c10f10b","modified":1462839598000},{"_id":"themes/apollo/layout/partial/nav.jade","hash":"c35d3061da4b053b73150d9741c542d660798270","modified":1461248075000},{"_id":"themes/apollo/source/css/apollo.css","hash":"9a5ff2fbb383beb4451b98d2c516f10590e30ca0","modified":1462839598000},{"_id":"themes/apollo/source/scss/apollo.scss","hash":"a3153dfedbaff08c20930b2bde95f2db49f6d518","modified":1461248075000},{"_id":"themes/apollo/.git/refs/heads/master","hash":"bcc5571f275112b0d1f203c321fe80795462d8b5","modified":1462839598000},{"_id":"themes/apollo/.git/objects/03/00f980722372128ba522604bf12b7397158335","hash":"e7afc399fc52ba529ff49c3e37e943f57fd4bbb5","modified":1462637727000},{"_id":"themes/apollo/.git/objects/01/d71d6c85af21411581713daf6f032e165e0354","hash":"004b829038d16e99a4f2eab6e174bc0b47f28078","modified":1461413577000},{"_id":"themes/apollo/.git/objects/00/079579b3d36f55118295809969356ce6b9c995","hash":"fdc2378b9e3d7cad2f29e3807ba341591fc10710","modified":1462637728000},{"_id":"themes/apollo/.git/objects/01/7626343dd57fe9597799510895b6ff04844b74","hash":"05a9eb1365e9faa35df83b7d8d2c88dca3f53766","modified":1462637727000},{"_id":"themes/apollo/.git/objects/03/b7446dd55b965cdc117bc18973a3ad3b05704a","hash":"fb99640d8e21f4fc5f8e76b2d853c972a38a93dc","modified":1472214221000},{"_id":"themes/apollo/.git/objects/05/8535f43cde1b5a573b37a26701e3753ab8c349","hash":"dcb45d2b8093ec9af7c1f8e4f211d0b4a195d11f","modified":1462637727000},{"_id":"themes/apollo/.git/objects/05/99c9fa233f6ce4a61b754bd0f6d2bb5256ed75","hash":"0a3f46eb6fedf2d30033b40d54ba3fd0fd74029a","modified":1472214222000},{"_id":"themes/apollo/.git/objects/12/adbbf2b1bd7229dc79568e4820cb33741c6b9c","hash":"5d7eb00302556f231dd6bf695bd3f0d1b6d1b74f","modified":1462637728000},{"_id":"themes/apollo/.git/objects/11/3299a8e9d2d19c39b645118da2053bdae69577","hash":"9f5d4825c5643a8bd030e902cd18b1910dd61a0c","modified":1472214221000},{"_id":"themes/apollo/.git/objects/15/b938d2412bb97d9d1b2c8b9473e72761b57c1e","hash":"57f0d5d0cdc4b06a4f9c7a56c75bac234d466156","modified":1472214222000},{"_id":"themes/apollo/.git/objects/0c/50b504ef81dacc4e83595d604b932806ca4bf7","hash":"578093bfc6ce72406f4c81b6a118b42badb772be","modified":1472214221000},{"_id":"themes/apollo/.git/objects/1c/63cea0e404f4a520d6276dc7549d99745fd422","hash":"a0e18af8a4737f4ead175a3d8d29a5de5a5db6d5","modified":1462637728000},{"_id":"themes/apollo/.git/objects/1b/053fbaf331660c5e7795d094c8f902f8f6fc2d","hash":"8bb923646c2db35f5b991c2dad2889dbabdb3cb4","modified":1461413577000},{"_id":"themes/apollo/.git/objects/17/bae594549393e600663d9628a14a9a50dcffc7","hash":"411aee7c49010487517db9354628f178c374b5e8","modified":1472214221000},{"_id":"themes/apollo/.git/objects/1c/0d58c72f557e554fdc9625c6fee9b0f1b50900","hash":"e4923dce47fa91c8e2c59fb6644cf0fce0fa8f7a","modified":1462637728000},{"_id":"themes/apollo/.git/objects/18/94831f8ea0da9ec29f53b2f2311a96d6bffcba","hash":"bf175a04a040d40f95e897a9854f8b2f1cacb4c4","modified":1462637728000},{"_id":"themes/apollo/.git/objects/20/fee17d8e9f36e4ca837fa299250d6046359f43","hash":"65d8f545509dcac5da1c018af39b6ffd0a057056","modified":1462637728000},{"_id":"themes/apollo/.git/objects/21/68662a330633c81407c4a596e7f6da53df582e","hash":"8ff000c15200730e734273eb212ac2dbeb595e49","modified":1472214221000},{"_id":"themes/apollo/.git/objects/28/13338f5f035868fb3985e2951bd582471f78f6","hash":"ff176f777f773a0ec6f9ec7403cfe51ffd498b24","modified":1462637728000},{"_id":"themes/apollo/.git/objects/28/267f5e6f2266326d09768f3245f073540bc428","hash":"44f706325ad8ee1c0880c46db744bf35dc5171de","modified":1462839577000},{"_id":"themes/apollo/.git/objects/24/a53aa22568b2f9b707a73e845396a92299becb","hash":"40ffcf3b18f96d1bd204341f4e09017e2a66cb70","modified":1462637728000},{"_id":"themes/apollo/.git/objects/1f/bb5d0096e3d111c84f3892e16e3f08b5102e69","hash":"63ec8f48b82105205b0a12e9a6b3b8dac9317ca6","modified":1462839577000},{"_id":"themes/apollo/.git/objects/2a/d55496cb86c097a7d495c6810a94c7e8490400","hash":"3e6e7ad9e4aa89a77463a4b3579e431def41c64c","modified":1472214222000},{"_id":"themes/apollo/.git/objects/2f/a65aad9bf9b16a7be22abae4904eb6c864a7ca","hash":"5fe61b4e3543c26ce757e483d1100154367dc30b","modified":1462637727000},{"_id":"themes/apollo/.git/objects/2f/38af1ac8a7e96bc871318182a1a0db3261dfc6","hash":"3202fa8304b2d8d695430ff8cc5f83763da5c03f","modified":1462637727000},{"_id":"themes/apollo/.git/objects/33/a79bd1ad6cb4dd5b9784c35bea3c23e643bbec","hash":"7e34557cd1df100f8f66964146d50d41e308913a","modified":1462839577000},{"_id":"themes/apollo/.git/objects/36/89fd733c4e4cae2d18742641ff5441835e2bb9","hash":"a0a78e63b58a94a19f0aac7488b1d9c1ca5faed5","modified":1462637728000},{"_id":"themes/apollo/.git/objects/33/f958e8026309ec6c295ed08dd50bc9f1304fb4","hash":"ffdd2d1ee4c595c1db403a401e3f4252bd534a4a","modified":1472214221000},{"_id":"themes/apollo/.git/objects/39/795b4483d9a6b2ff6a38f4ffcbeb2ce4ca2867","hash":"99204d1f133191cffc7fe572f5b0f7099e365399","modified":1472214222000},{"_id":"themes/apollo/.git/objects/37/549466d4620c608d45052e75383c7d4aff5863","hash":"8e2191b3baa819d347ed2870b5620aa49209e0d3","modified":1462637728000},{"_id":"themes/apollo/.git/objects/38/7bb8bfd52482226bd97b542051b3a1695057aa","hash":"c5f00863062a2decb32601b49e594d270788f943","modified":1472214221000},{"_id":"themes/apollo/.git/objects/38/a0147cac1ae0fc3a2f63b01fe794a18e28cb3c","hash":"2aae2f786bee2e44dac48c7f0952d9a600124c31","modified":1472214221000},{"_id":"themes/apollo/.git/objects/3a/2af4c2e8c1da5c734521916090b28d829caca5","hash":"c6b3f11aae009432c30bebca8855783a3b6ddcde","modified":1462637727000},{"_id":"themes/apollo/.git/objects/3c/eb577fed1d04609e3f5415df5767b0ae9eb50d","hash":"accdfb6841f1804d1a11eea9779eab6a4080b7b3","modified":1462637728000},{"_id":"themes/apollo/.git/objects/3b/8ad3e029ac9e14b32279caae2dc2f8d067572f","hash":"a3381e11f9833ab40dbe6ad040f9b197ce0b8ad9","modified":1462637727000},{"_id":"themes/apollo/.git/objects/3d/49e6f39e43d015cd80bffb4b2fb24c5c1f431a","hash":"c6cd42bc96b1d64e2d9b248af0201c727871a032","modified":1472214222000},{"_id":"themes/apollo/.git/objects/3f/69281f41ef22afd544b33f24a4855f3683a31a","hash":"b0a8131ef16aaa51dfe5b44fc9a208ce5d76add3","modified":1472214221000},{"_id":"themes/apollo/.git/objects/43/2b69b1c2f45f492e3a30bf13abce211fc16000","hash":"5e358a055fa9f63575fc44428aecc597ec96f9ae","modified":1472214221000},{"_id":"themes/apollo/.git/objects/42/e3d7818137d97693b4dc3cfd0ea25f16098f09","hash":"e9ec8f386a1cc43fdc051e7dedd530482960471b","modified":1461413577000},{"_id":"themes/apollo/.git/objects/40/45696ec72dac41731945cbb7c32a78105d161c","hash":"0d2dac5a6d4480a952017583e644ae2bceb69852","modified":1472214222000},{"_id":"themes/apollo/.git/objects/41/57f4901c702fac80210823241e9cbd2feb9ed4","hash":"262b1c3a62142808057dcf6148e79bcd2eb0da6e","modified":1461413577000},{"_id":"themes/apollo/.git/objects/40/26f6b11b0d7e7800d915fa92d809ac99bcb699","hash":"d18ed646e292c8f1bd968d170de5a3434805802d","modified":1472214222000},{"_id":"themes/apollo/.git/objects/41/664d6b55b9e51b59d325f85b2ea31366ebc185","hash":"7934ee11a3e0950336c7ab557aeb20f8482a31d3","modified":1462637728000},{"_id":"themes/apollo/.git/objects/41/ca64d512ea5db96864f330b1c0f36c66f0a3de","hash":"21f4eed14fc2c0fce15bdff470df9c553b6961dc","modified":1461413577000},{"_id":"themes/apollo/.git/objects/44/40bc485f72efb4670ff0e9dbca58c213829bb9","hash":"af44f31ad83394aea3be6388b74ce4fce0c6bebb","modified":1461413577000},{"_id":"themes/apollo/.git/objects/44/555bc9786247591d2096030461c2e8f582fcd5","hash":"07226b477a7b6e24a103628f55bd24f2529f98cf","modified":1462637728000},{"_id":"themes/apollo/.git/objects/45/364f50049fd730cbe00ea6ebe49b5ef6c0254d","hash":"1207c7d7314699f18b4add91652219d5ad1f881e","modified":1472214222000},{"_id":"themes/apollo/.git/objects/44/7210753f058d8966a826244573bcd5894e62bc","hash":"4cc026cd28f304f7f7743943f54fa511be4a36d6","modified":1462637728000},{"_id":"themes/apollo/.git/objects/4e/42327e2fc28aefd90259793fde261dd8bbce4d","hash":"49d6092541a84a38bbf6060099bf4e21b18a7c30","modified":1472214221000},{"_id":"themes/apollo/.git/objects/4b/03e8350592968a0310bbda1d1a3a88d64902d7","hash":"eb372f613be89d21deb11694dc391beda5db74c1","modified":1462637728000},{"_id":"themes/apollo/.git/objects/4e/b1b0b84966e7b48b288e5cfe248766a8b504ff","hash":"97fd0b6268507310635aac8f4e50502c1787de2e","modified":1472214222000},{"_id":"themes/apollo/.git/objects/52/04efb5dc95121d3b9af475771dfda67a89e4b7","hash":"ac861051f41d74955c4cf38bc97bca4b87a543d1","modified":1462637727000},{"_id":"themes/apollo/.git/objects/54/8e870fd6be1954fbdd600bef96e25b527616ee","hash":"7a2e93e00004ffd8b9277bd8475737d2a0614d4b","modified":1462637728000},{"_id":"themes/apollo/.git/objects/50/17748c9bc83a03a3978290eb40035d89696e33","hash":"3fb843ef31036827b4a39a94d5fe6674fea5943b","modified":1472214222000},{"_id":"themes/apollo/.git/objects/51/653f67336c70d7a563df181862f8f779deb91a","hash":"79e7e8517d3ba91601c0deaee5cb752e83ca1397","modified":1472214221000},{"_id":"themes/apollo/.git/objects/56/6c70471be1cd79d2dc2b8bba4b2b6cb6384108","hash":"c3824b350b74dd98348b54ea1de05465afb7e744","modified":1472214221000},{"_id":"themes/apollo/.git/objects/53/862ff0ad08594e6671a4afac38063b9f16518a","hash":"e0055949deeec8c2f766d3f92a0b6780de4a88ae","modified":1472214222000},{"_id":"themes/apollo/.git/objects/64/686c22dcfa59edbdef571213826fb86a4d2e4f","hash":"a0a3a4f72cd9580bb5a0c11a4aa803daae051546","modified":1472214221000},{"_id":"themes/apollo/.git/objects/64/727beb142a2f071ccbaa492c6178a31665c6bf","hash":"72a29a32aaeacd0f4de7548f8c5ce3974d450bb3","modified":1461413577000},{"_id":"themes/apollo/.git/objects/56/7f47150460bd18f89b13b1eae530bd050f6619","hash":"2449751009384fb7f7c02653ed17e4fe4a444752","modified":1462637727000},{"_id":"themes/apollo/.git/objects/56/a58d2c5c8884096658f4a0c470892990849171","hash":"535d513ad3a744f0648d374b76984217678e8b2d","modified":1472214221000},{"_id":"themes/apollo/.git/objects/5a/c60bc7fe9c37aae581e14c72e123e156809d4a","hash":"e1a9f390b0a5a40c9ff9f4642d4eb1a49812b7a1","modified":1462637728000},{"_id":"themes/apollo/.git/objects/60/b90f3506b698a822b9e9b88afee3b07aa66907","hash":"6b4e9f13766ee75bce203b2e606d6521e6bf8814","modified":1472214221000},{"_id":"themes/apollo/.git/objects/5a/c42007d5924d418887484c9fe7c7cb869ade74","hash":"2cfa64f09624b67d30f986e5167fa0ab7339ea21","modified":1472214222000},{"_id":"themes/apollo/.git/objects/5d/a74f7c8a042f8e3c6aea05ca2c9b2f0e3c1975","hash":"5b29fae236352999250be79a63acd6675fc8232c","modified":1462637728000},{"_id":"themes/apollo/.git/objects/68/3acc7d1a3ca1d3d12d074ea1e339175a825a1c","hash":"91aea91bedd02cbf173eba5d5f5a485bd7982033","modified":1461413577000},{"_id":"themes/apollo/.git/objects/5d/ce5bb837e8b371b56b43e7c76d3c24c45ace98","hash":"1f7c575b5a864dcead0519d404ad9da2c122a6f7","modified":1472214222000},{"_id":"themes/apollo/.git/objects/68/6f5f8bb730f8188a55303e333fb3ce28f9edf7","hash":"f649b48d8dfe89824d8ef38326c51feea1a9aff2","modified":1472214222000},{"_id":"themes/apollo/.git/objects/6d/16315f244525d9b449db2aaaf94a4383b84a88","hash":"259610c4cc130c81673d209de0cfeb17a0868859","modified":1472214221000},{"_id":"themes/apollo/.git/objects/70/a72f07184f8f5cd10b8f7ded2cc584767fddfb","hash":"e3a4e4efec71a177f265b2a53a14b7967e985e44","modified":1462839577000},{"_id":"themes/apollo/.git/objects/69/d9732112287ac9f7b2f2ec69ef834515ab0711","hash":"a21e801086b6667817b953a497e6b001adfa5e1a","modified":1472214221000},{"_id":"themes/apollo/.git/objects/74/64d77911aaba2c961ee2840ba8a8ad39b2cf73","hash":"4a28c810d330cf9a91043057676f26f23a95e037","modified":1472214222000},{"_id":"themes/apollo/.git/objects/74/6777c5471dc204b2fe1d15a0f5b265ecb4e353","hash":"db071434510ea905f97e66d7a87540fe9cb01bc8","modified":1472214221000},{"_id":"themes/apollo/.git/objects/65/5670f7a6eef3f536ebea26fce0c9c105f801a8","hash":"91fcecda0af2ef9a7c87ec528c2061cc9a1ad2d6","modified":1472214222000},{"_id":"themes/apollo/.git/objects/82/63e60ad68b891c9da225d2bea88888cb0cd8ab","hash":"547621d237cf685a8637d28d6c1c5182d1377c29","modified":1462637727000},{"_id":"themes/apollo/.git/objects/82/cd64a70df9fb92c75dafefd0cbd95076003502","hash":"ca147b0927cb1aadfd6ea371dfc3c8521d182811","modified":1462637728000},{"_id":"themes/apollo/.git/objects/82/bb5309b9e657c1dc354d791b9aa53a6b69007f","hash":"bd0ea13888fa29cfa5c8ae415f7b7d25101a7d03","modified":1472214221000},{"_id":"themes/apollo/.git/objects/82/e37b650f649023ca7183208dba5680b80bfd3c","hash":"7a1102c67292f188951710e92a4a2555f24daac4","modified":1472214222000},{"_id":"themes/apollo/.git/objects/77/216aa28ce6189ff96fd628a5939fe9ca4bb720","hash":"3d6bf026f8d3c8c47aab0c60441f3c169cc8cef5","modified":1472214221000},{"_id":"themes/apollo/.git/objects/76/569a03649d17b35e333b9c78e2e0576809cc98","hash":"705ca260cc0847dbe3107784085150eaa6621125","modified":1472214222000},{"_id":"themes/apollo/.git/objects/85/d0db00da4fdd6ddcae337dcdd556016e66e63a","hash":"c7421edf86db0b5f6acc5e6f6eab49a7316802e9","modified":1462637727000},{"_id":"themes/apollo/.git/objects/83/b472a9c149dd2059bc831e98ca275bc68815aa","hash":"8c9bbccd13cbb767a0601374148d4a9eb67a8570","modified":1472214222000},{"_id":"themes/apollo/.git/objects/98/ac873983bbb6b9fa4801f5fa0d662454ec5d08","hash":"be8ddea569835416e8af3f5e721a5d483362d53c","modified":1462637728000},{"_id":"themes/apollo/.git/objects/8b/97c96f379800a9fea684ae80fae1db894e617d","hash":"76579ff3d8cadaf58259e2635437def392cfb9cc","modified":1462637727000},{"_id":"themes/apollo/.git/objects/80/e4d4369850d8f9031cda1c49a8837223da451b","hash":"9b2804fc4c78daa72275d43061373ffd3227a574","modified":1462839577000},{"_id":"themes/apollo/.git/objects/92/f180f071ba87f1889c619d481edda0a9d48a04","hash":"e03b60a3894ab238546e416152f3400969cc2201","modified":1462637728000},{"_id":"themes/apollo/.git/objects/9b/3729a5d5ff307af9194d12f3d5acd4f5401e50","hash":"23f6e8bba3c6abe4ceea9c58829ff7c5413c6ae4","modified":1462839577000},{"_id":"themes/apollo/.git/objects/92/f9a341ae1757f0650f1af9c9a328bea04a1691","hash":"8b858a36a5ed8e39e2aabb3f79a812c894c2be8f","modified":1472214222000},{"_id":"themes/apollo/.git/objects/9c/39485faa274f63b45b9545a762c60ccebd84f9","hash":"b40cc49e95901ed5d426542a1577221ffd5134cb","modified":1461413577000},{"_id":"themes/apollo/.git/objects/9f/5446dab877d904a2358cd40c73ff2d0468c0d2","hash":"6897f15dc1212f23f54955be6057f418d66f657d","modified":1472214222000},{"_id":"themes/apollo/.git/objects/9c/9840ec0467d72d1bba825215fcb7633d52ac2c","hash":"7162a0e6eb8a6535d8138ea27da1c0008baf33cf","modified":1462637728000},{"_id":"themes/apollo/.git/objects/91/9dc3c8c82c66397e2735d53df1663308c07a72","hash":"2f0b06497f354a122967eb2ccd5b2d11174a2197","modified":1462637728000},{"_id":"themes/apollo/.git/objects/91/b5a079e6f5b2bdf970161591c268a67a1d9ac7","hash":"524b76d76cfb1a0dc49270879209d55949a7b4ec","modified":1472214222000},{"_id":"themes/apollo/.git/objects/99/47a50a11617923e8b3e552b73b0bbd6f80cfdd","hash":"55ebd44c9803f0b9b6b5e201018a4ad20f5d4059","modified":1462637728000},{"_id":"themes/apollo/.git/objects/a4/8fdf50332c1b763ab2ca427ae356dbc0bb22f4","hash":"b1a89873504ea86f95b457e600bbc891349ee85a","modified":1472214222000},{"_id":"themes/apollo/.git/objects/b2/168c7d73685548e7b62dc08643565e5aa1c849","hash":"baf726883d4725e550403c0f6e01dff465c5def7","modified":1462637728000},{"_id":"themes/apollo/.git/objects/a4/5aa7b4ba9f89800f2124fdc9c5699c61c4b8e3","hash":"78207190abf61973b672ccc62fdf90c1dc80bf6d","modified":1472214221000},{"_id":"themes/apollo/.git/objects/aa/661175300857b8ec712856bc6169161f86f8ba","hash":"fb698805f9b5f6ce247a5e76890ab69ba65e98bb","modified":1462637727000},{"_id":"themes/apollo/.git/objects/b0/2389b0a8ce1a211c3c4957c5070d821efa9adf","hash":"0dd40883efc6aeb237a7eddc69a70fdcd5e778ab","modified":1462839577000},{"_id":"themes/apollo/.git/objects/ac/880f01ef4c8d7303b2394249ff9c6f90456544","hash":"2045cbc45028ee09498573f6118211bc0e016c03","modified":1462637728000},{"_id":"themes/apollo/.git/objects/ad/075d667825111416129d361519da7e55f8b3d9","hash":"00a3bfe7a8b8a770c654138cb6d4aa1a1f3f89e5","modified":1472214221000},{"_id":"themes/apollo/.git/objects/b1/d04154fb27cdfb851635b5582c35823c86dd25","hash":"1b29c3bec1521784344b824a6c4b54f7d8d03deb","modified":1461413577000},{"_id":"themes/apollo/.git/objects/b4/d86e5ba72dea2967f34243b4634678c220d8c4","hash":"f039d45ff5a4e06274f8ef1522efb06142d1e89d","modified":1472214222000},{"_id":"themes/apollo/.git/objects/b6/66ed0b4f61184e19246319e876d9d30a58b3a2","hash":"28741c136b3ee6ca292f393f823930e6906ca688","modified":1472214222000},{"_id":"themes/apollo/.git/objects/b7/671981bf623242c04d8e58741195c9b30da3a3","hash":"01f6e4578919b466bbd805d85f23bcae7f7b9f07","modified":1462637728000},{"_id":"themes/apollo/.git/objects/c2/69fa6a618d1cb989c30919e3d87d375de10498","hash":"8aa85580303526a91c4c285147e057b97582ce14","modified":1472214221000},{"_id":"themes/apollo/.git/objects/ba/5926cdd65fd6d265e09ba4c9d252b8d04690f2","hash":"97747396ed37296fde24e3edb9d1379fe3466148","modified":1461413577000},{"_id":"themes/apollo/.git/objects/bf/4e7601388364bb4b515cfb3dc307799371a625","hash":"8beaa6b138b15e73c9d757fd2d01ee191318bde3","modified":1462637728000},{"_id":"themes/apollo/.git/objects/c6/2686469959af92afa27da57ef2554e851c28a1","hash":"122dd23f2f6b979246386fa9a79a00da149e512e","modified":1461413577000},{"_id":"themes/apollo/.git/objects/bf/dec4f1588f48049884c1205135fb86b959da9b","hash":"8b451f808f30f9aa236a3387163377b47fce4584","modified":1461413577000},{"_id":"themes/apollo/.git/objects/bb/ab2fe966cdf329c632572949402d2e62008186","hash":"939da2969752e8a9bf4f69f2b457715d9f06076f","modified":1462637727000},{"_id":"themes/apollo/.git/objects/c6/b1a427afbd7626ae4da778b18536acc101d7a7","hash":"065f093058f1c306852b9fdcf0321c3bb29d571a","modified":1472214222000},{"_id":"themes/apollo/.git/objects/c9/af882bef8c3b19d59368a1f9b497908a66d8c6","hash":"8c09b5987f99d04f85b990d9d8d48e74113e8667","modified":1472214221000},{"_id":"themes/apollo/.git/objects/c3/4f5c8e4dc811b1fe8b7d92be9bcae0b12466cb","hash":"da136d634fd1409d4e62998ca1e6ea273e431a93","modified":1472214221000},{"_id":"themes/apollo/.git/objects/c9/c8283957b27ae8f2d617c9f364ae6ee2d28fbe","hash":"374649c5761c1e1a7328ab08591e2a38760f535f","modified":1462637728000},{"_id":"themes/apollo/.git/objects/c7/2a410b804c25813455d06620b62d3e587d8e90","hash":"f4f2e45ade06e8a12ec95b7a402693224d44c303","modified":1462637728000},{"_id":"themes/apollo/.git/objects/d4/4cc6b2f91d4736ea59d65203b2385e27b2297f","hash":"947c1a0f6b0e5ffef63b5a260836eab9604a871e","modified":1472214222000},{"_id":"themes/apollo/.git/objects/ce/1035e018fc00555df63cf6c491c0ee4ce80bd6","hash":"0ec456711ebbecbfe230909774cef54fb7ed973d","modified":1462839577000},{"_id":"themes/apollo/.git/objects/d1/cc09cf69d9ca7a24164c097f7c24ef46a5d182","hash":"16aa95325a17df7f0360c69df7c7e5f298d3e7b3","modified":1462637727000},{"_id":"themes/apollo/.git/objects/ee/a16f6216615f220199f407b250b22696c8d3ee","hash":"016504d5162d6e869c2ce7643120d8d9665686c9","modified":1462637728000},{"_id":"themes/apollo/.git/objects/dd/680a819307c6250f9d4e25d5c1a69761090b45","hash":"efdfe6da7acdf416698aff0d626d0c4eff083190","modified":1472214221000},{"_id":"themes/apollo/.git/objects/eb/e03a24d77f98a435e5f5bf9763574ed34538e7","hash":"e7fa756b676e1b1e6ccd782b82235fd254ec9432","modified":1462637727000},{"_id":"themes/apollo/.git/objects/db/0937ff41203b9108287035474c7ce1e1d63303","hash":"be0f1dd349f3afd28099a42c2ece15b2e4a14b4e","modified":1472214222000},{"_id":"themes/apollo/.git/objects/e7/6b6a71e143a654c88aee6a14be9d804536ef25","hash":"5e106f8d792bb8792caabea9b17429c93d5aa21c","modified":1462637728000},{"_id":"themes/apollo/.git/objects/ed/8757d13413fbda5c3b02044c47ac5c3d58a167","hash":"4d782b37e6aa81376084ab469b0c0ac1a24b9b11","modified":1462637728000},{"_id":"themes/apollo/.git/objects/d6/e81ae357fecd58575f6399f9c4a311769fe5db","hash":"dda04c0fd04132c8f1f51b24a1a1c6311595b4d1","modified":1472214221000},{"_id":"themes/apollo/.git/objects/df/f8db186348d56033c3219b00c29f830a19f225","hash":"7133201477007b5740912375615a4ce72f5831a2","modified":1472214222000},{"_id":"themes/apollo/.git/objects/f7/fd206e4121e5bd88a20467ef3993bfa516e240","hash":"80acfd9bb170c52410de3ed3a25614f88c829be6","modified":1462637727000},{"_id":"themes/apollo/.git/objects/f9/69186b1ddb4cbec7579a151728efa00b2e36c3","hash":"27155e216494fbc1438e95d9d009771bbf6327e3","modified":1462637728000},{"_id":"themes/apollo/.git/objects/f9/55f3ba366df2fc89379edab9f71c39715ba9e5","hash":"903ab7006c083f485dd0b4fa7ea698505a64f3c0","modified":1472214222000},{"_id":"themes/apollo/.git/objects/f9/b894ca3f5df2041d9227eccf19a56a8dd1fe9d","hash":"caed31370b06a8f5de6f33e54e2666f66186fc6b","modified":1472214221000},{"_id":"themes/apollo/.git/objects/f2/eda57c1c629e24d9ef7c5c5c7abc4451d8bb94","hash":"812c73f803834131d568421c29fe659f1dc6e10d","modified":1462637728000},{"_id":"themes/apollo/.git/objects/e1/daba6f77f6252ae81d1e6fbf1952ec388abf01","hash":"1f532c6566552567261962d39f518a512c0ab387","modified":1472214222000},{"_id":"themes/apollo/.git/objects/pack/pack-eb3ccb0fbe30709f6cfad0e929e25b460d7a9e61.idx","hash":"eb09e5a21ec365ebf7902e88e7bea919d0148ad7","modified":1461248074000},{"_id":"themes/apollo/source/scss/_partial/archive-post-list.scss","hash":"d2f740a7d48349b7536777c795f82ab740836d0f","modified":1462839598000},{"_id":"themes/apollo/source/scss/_partial/base.scss","hash":"187315928040112ac5b9b2c0c6b2f406cf45813b","modified":1461248075000},{"_id":"themes/apollo/source/scss/_partial/copyright.scss","hash":"1309667e3000037170cfbb5b8c9c65f4ffcf6814","modified":1462839598000},{"_id":"themes/apollo/source/scss/_partial/footer.scss","hash":"094aca6e52f11b139ac7980ca03fa7b9d8fc7b2f","modified":1461248075000},{"_id":"themes/apollo/source/scss/_partial/home-post-list.scss","hash":"6b5c59f3d2295944f934aee2c1156012a3306d5d","modified":1462839598000},{"_id":"themes/apollo/source/scss/_partial/header.scss","hash":"153bde88bf8ffeae4ffd813d8cc694dd83d33d94","modified":1461248075000},{"_id":"themes/apollo/source/scss/_partial/normalize.scss","hash":"fd0b27bed6f103ea95b08f698ea663ff576dbcf1","modified":1461248075000},{"_id":"themes/apollo/source/scss/_partial/mq.scss","hash":"b5eb0fb35fb275cbb6452b5d98702d461af3e6d5","modified":1461248075000},{"_id":"themes/apollo/source/scss/_partial/post.scss","hash":"aec29b69af865249617624e1ee849792fd524cf9","modified":1462839598000},{"_id":"themes/apollo/.git/logs/refs/heads/master","hash":"caa17050086437f437c796a58625de1313174844","modified":1462839598000},{"_id":"themes/apollo/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1461248075000},{"_id":"themes/apollo/.git/refs/remotes/origin/master","hash":"2c2d30ff3adbeb6ff8fbc27b526c1de71c6c05a7","modified":1472214222000},{"_id":"themes/apollo/.git/refs/remotes/origin/flux","hash":"bcc5571f275112b0d1f203c321fe80795462d8b5","modified":1472214222000},{"_id":"themes/apollo/.git/objects/pack/pack-eb3ccb0fbe30709f6cfad0e929e25b460d7a9e61.pack","hash":"79709f47d6b6fc12d0e741b995aebd6b1db69d52","modified":1462839577000},{"_id":"themes/apollo/.git/logs/refs/remotes/origin/flux","hash":"ec358205effd1f11694c4de5c15fed46283e5bd6","modified":1472214222000},{"_id":"themes/apollo/.git/logs/refs/remotes/origin/HEAD","hash":"e4fc86831137c1b13e255c466ae3ddcd5d3680f3","modified":1461248075000},{"_id":"themes/apollo/.git/logs/refs/remotes/origin/master","hash":"63fbb4242fda9741025463c5225281dab77ce246","modified":1472214222000},{"_id":"public/atom.xml","hash":"f9d340eb4793b8c33138bbdffe84b9ed68881875","modified":1472287561423},{"_id":"public/sitemap.xml","hash":"9424c3cf9ca98dfce4421236ad4a822a44c83779","modified":1472287561429},{"_id":"public/2016/06/21/workstation-setup-guide/index.html","hash":"dd0243692534b63d1770b3891f6edf3d1ce85764","modified":1472287561515},{"_id":"public/2016/06/11/ruby-on-php-abc/index.html","hash":"9e0d63987f93657070a2854a7352b84645620add","modified":1472287561522},{"_id":"public/2016/05/19/google-io-2016-review/index.html","hash":"a583054ca46e67f75254860b71339afc88561961","modified":1472287561522},{"_id":"public/2016/04/24/problems-of-it-textbooks-now/index.html","hash":"0f2a643b8d4a172ea2330217b71ca5ff7aa59921","modified":1472287561522},{"_id":"public/2016/05/14/customized-machanical-keyboard/index.html","hash":"89ea094415299e5a610af54921e6185dced108a0","modified":1472287561522},{"_id":"public/2016/04/21/heckpsi-blog-2016/index.html","hash":"b47329e0234aa180968b6b7f8380e74eb2e25c1e","modified":1472287561522},{"_id":"public/2015/11/01/super-amoled-introduction-part-1/index.html","hash":"e875abc1da193138d549b822436e28ed84f5f0a4","modified":1472287561522},{"_id":"public/2016/03/18/how-alphago-works/index.html","hash":"19fae8f7e710ffed8bdd15cabe0a8d902d73dcf6","modified":1472287561522},{"_id":"public/2015/06/27/what-is-equal-rights/index.html","hash":"a0166a47fb9e41bdc38fedc017b2b3f483cd577b","modified":1472287561522},{"_id":"public/2015/05/15/things-behind-price-down-of-data/index.html","hash":"f0132a3794d731140276f850d6c6a63f8228e58a","modified":1472287561523},{"_id":"public/2015/05/03/anti-virus-softwares-in-china/index.html","hash":"43533be8b635318c0f279ae81f62f5e7e710c660","modified":1472287561523},{"_id":"public/2015/04/16/how-https-makes-communication-secured/index.html","hash":"923ae473c3dd345e9848bf95a057dd0131fd7c6b","modified":1472287561523},{"_id":"public/2015/04/02/danger-of-hybrid-apps/index.html","hash":"2ca264241426eaa1adb93b47441fb1320aa72b9e","modified":1472287561523},{"_id":"public/2015/03/29/why-material-design-pushes-difficult-in-china/index.html","hash":"fe1e76532e6bdc05b1b62eb88fe3380134df7405","modified":1472287561523},{"_id":"public/2015/03/28/synesthesia/index.html","hash":"fb6088561a133f6c7c32f973d6937295c28da0e9","modified":1472287561523},{"_id":"public/2015/03/27/apology-to-visitors/index.html","hash":"a95d7c157c373f25ade91ad7f5396a15e9339c9f","modified":1472287561523},{"_id":"public/2015/02/25/fix-nexus-5-lens/index.html","hash":"541bc0d82b3130ebc22099b68df4506550dad09c","modified":1472287561523},{"_id":"public/2015/02/21/how-to-test-a-font/index.html","hash":"010f20df25cef7778d5cf4c0be416399d3207b72","modified":1472287561523},{"_id":"public/2016/02/06/android-hot-patch/index.html","hash":"cebd967d6d5930424605f8df1b7a9c78c1c85a17","modified":1472287561523},{"_id":"public/2016/03/19/learn-y-combinator/index.html","hash":"24744ee3ef51e1b831727c017d8210d5893064ae","modified":1472287561523},{"_id":"public/2016/08/15/project-genji/index.html","hash":"dc11d1e4685eeea360eec1a320fee1a166ee5071","modified":1472287561532},{"_id":"public/2015/01/20/how-cmos-works/index.html","hash":"523493a389f69233570617535e8ea1fa0c8d12cf","modified":1472287561532},{"_id":"public/2015/01/23/gossip-of-spartan/index.html","hash":"6954c7598b74036b08de72138c82415cc8a83fcc","modified":1472287561532},{"_id":"public/2015/01/28/things-about-dpi/index.html","hash":"a7473029f1a1fc54046e10bc2071c84f70e6e2f4","modified":1472287561532},{"_id":"public/2015/04/27/from-no-response-to-godels-incompleteness/index.html","hash":"d373417769afee78276aeb72f1fce496b883aa5f","modified":1472287561532},{"_id":"public/2015/01/17/what-is-ddos/index.html","hash":"0264b1062871a382f2990892e34d65916aaff208","modified":1472287561532},{"_id":"public/2015/01/19/application-of-bayes-theorem/index.html","hash":"041e81978eabd207093f0eb914ef9c92335e7ed6","modified":1472287561532},{"_id":"public/2014/10/19/can-a-program-runs-faster-when-data-goes-larger/index.html","hash":"e8495696bb8e601d5ed5378a70a20f0a1b229975","modified":1472287561532},{"_id":"public/2014/12/26/what-is-hit-library/index.html","hash":"906c2102dca627323b1757a6d01e951e3458b19c","modified":1472287561532},{"_id":"public/2014/05/01/ads-on-videos-in-china/index.html","hash":"608259e2bde5c2ec7387137aa5bb9882afd1f561","modified":1472287561532},{"_id":"public/2014/06/25/google-io-2014/index.html","hash":"f261899df4eae8ac605d1ca0c93ca73f0ed9c9be","modified":1472287561532},{"_id":"public/2013/08/24/why-retina-isnt-enough/index.html","hash":"2feeb870fb8db9e2468cbb73e3004d883fbf07c2","modified":1472287561532},{"_id":"public/2013/06/30/things-about-android-touchkeys/index.html","hash":"e5c44ab799ebbf4a111852682df8096e8a647de6","modified":1472287561532},{"_id":"public/archives/index.html","hash":"50a504e3eb1cd595a9cd240e801d32db2adbdf22","modified":1472287561532},{"_id":"public/archives/page/3/index.html","hash":"5294ec0f38e1ac489b8faa218b9b7422e81a85b0","modified":1472287561532},{"_id":"public/archives/page/4/index.html","hash":"f3c91baa01fa4bb11c9c93744b22d70e7440ad17","modified":1472287561532},{"_id":"public/archives/page/2/index.html","hash":"9371b01d6c1c736baa8235c06fbd560af58fb740","modified":1472287561532},{"_id":"public/archives/2013/index.html","hash":"d4ae10bab9e9fb55189b689b668ed06ed40504c7","modified":1472287561533},{"_id":"public/archives/2014/index.html","hash":"dec3453434f595a181e488893119c00e5b668d4d","modified":1472287561533},{"_id":"public/archives/2013/06/index.html","hash":"008f36c507915e2d21db5ea1e5edd465b3a8a809","modified":1472287561533},{"_id":"public/archives/2013/08/index.html","hash":"22066e3d77e251b7d0d9194cd76ce0c708a81440","modified":1472287561533},{"_id":"public/archives/2014/05/index.html","hash":"471fe0fab4240ac9c5ef5b4d4c75bc53bd6973d3","modified":1472287561533},{"_id":"public/archives/2014/06/index.html","hash":"291973b4f5899f07c84000330d339cb7b813ce29","modified":1472287561533},{"_id":"public/archives/2015/index.html","hash":"b21900604c6eaf6dee456a6549ef17d8c1f490e7","modified":1472287561533},{"_id":"public/archives/2014/10/index.html","hash":"f4eb9ac4894376ea19203f19cecf244810e1e023","modified":1472287561533},{"_id":"public/archives/2014/12/index.html","hash":"1f1c7e8c3d5d002140428ea9c977c78e0bf65ea4","modified":1472287561533},{"_id":"public/archives/2015/page/2/index.html","hash":"ddf61381fe3c51ad4dbe950375f73d433c914b82","modified":1472287561533},{"_id":"public/archives/2015/01/index.html","hash":"16511474d1117954ccc6f02f79dd744dc0abd524","modified":1472287561533},{"_id":"public/archives/2015/02/index.html","hash":"c11aa0e5a2dc3f9da287516c419a7516915aee6f","modified":1472287561533},{"_id":"public/archives/2015/04/index.html","hash":"d7cc84b5358dc8e35a3fce75a8f8e852e116ce64","modified":1472287561533},{"_id":"public/archives/2015/03/index.html","hash":"a8d93b04df6078a7fd69665682a63358c4679a5c","modified":1472287561533},{"_id":"public/archives/2016/index.html","hash":"38d3316a592598adc7b0dcc1a8387e3f4f492253","modified":1472287561533},{"_id":"public/archives/2015/06/index.html","hash":"2b8999b7ba3f314ec994ae5fb8dbc026b0b363e5","modified":1472287561533},{"_id":"public/archives/2015/05/index.html","hash":"54a2abf89abeda0ed5af8b6a0386996922b64506","modified":1472287561533},{"_id":"public/archives/2015/11/index.html","hash":"4cb4cb943e9f819da10bc1ceb48128440353102e","modified":1472287561533},{"_id":"public/archives/2016/02/index.html","hash":"f0ea864e7d950c9d93c8852359e587d3801030a4","modified":1472287561533},{"_id":"public/archives/2016/03/index.html","hash":"33cd66664805ab3f91bf804e31aee4dd3c3d3abc","modified":1472287561533},{"_id":"public/archives/2016/05/index.html","hash":"a681aef1223d812cdaeed3e22af6de158061f134","modified":1472287561533},{"_id":"public/archives/2016/04/index.html","hash":"917629efdc28e3516a3cf4c8466973aee33def9c","modified":1472287561533},{"_id":"public/archives/2016/06/index.html","hash":"d2eee64dffdef932cb88218ecc39cb46b55c87dd","modified":1472287561534},{"_id":"public/index.html","hash":"094f15c520e58081c97a80f21c2d017310c1498e","modified":1472287561534},{"_id":"public/page/4/index.html","hash":"0e5916334f9736ce012665670258ce4b54193109","modified":1472287561534},{"_id":"public/page/3/index.html","hash":"e5015186175120ddc5416413a409ca1b844359c8","modified":1472287561534},{"_id":"public/page/2/index.html","hash":"b1cee1e3c7943669615d8172ffc70f396adfa8c5","modified":1472287561534},{"_id":"public/tags/互联网/index.html","hash":"471fe0fab4240ac9c5ef5b4d4c75bc53bd6973d3","modified":1472287561534},{"_id":"public/tags/广告/index.html","hash":"471fe0fab4240ac9c5ef5b4d4c75bc53bd6973d3","modified":1472287561534},{"_id":"public/tags/安全/index.html","hash":"76e8944f7c18a1a9bfee8afa3148add47f7e903c","modified":1472287561534},{"_id":"public/tags/杀毒软件/index.html","hash":"dbea62d457676a8eaa91ca5b9d464e5925e0df7e","modified":1472287561534},{"_id":"public/tags/JavaScript/index.html","hash":"f0ea864e7d950c9d93c8852359e587d3801030a4","modified":1472287561534},{"_id":"public/tags/Android/index.html","hash":"a319be6254b0536c555a0fcca83e05036c1b4524","modified":1472287561534},{"_id":"public/tags/架构/index.html","hash":"f0ea864e7d950c9d93c8852359e587d3801030a4","modified":1472287561534},{"_id":"public/tags/站务/index.html","hash":"7b9f260e8be6d8b13f0d080be7e417e66564df50","modified":1472287561534},{"_id":"public/tags/百度/index.html","hash":"39dd4b0bd33c1bac9e47769bc83bc75866244adb","modified":1472287561534},{"_id":"public/tags/数学/index.html","hash":"f30dec443511de4a51af36fe2917b4f1e8827df3","modified":1472287561534},{"_id":"public/tags/概率/index.html","hash":"b63bd7b48707362cf209bdf0d8dda1474b7e7b68","modified":1472287561534},{"_id":"public/tags/统计/index.html","hash":"b63bd7b48707362cf209bdf0d8dda1474b7e7b68","modified":1472287561534},{"_id":"public/tags/算法/index.html","hash":"a04c39e2a7784649a6c86d7a9fc5a3c6e4853a7c","modified":1472287561534},{"_id":"public/tags/App/index.html","hash":"20d34203f4e0e0e7c748b78a5ea7529dd90c9061","modified":1472287561534},{"_id":"public/tags/Hybrid/index.html","hash":"20d34203f4e0e0e7c748b78a5ea7529dd90c9061","modified":1472287561534},{"_id":"public/tags/键盘/index.html","hash":"6d6794df1cae27de99b3c87606827fd3c2734199","modified":1472287561534},{"_id":"public/tags/Nexus/index.html","hash":"16a18b107e9e84d86f59de727744a0ed9b77358d","modified":1472287561534},{"_id":"public/tags/硬件/index.html","hash":"16a18b107e9e84d86f59de727744a0ed9b77358d","modified":1472287561535},{"_id":"public/tags/Google/index.html","hash":"ef55c3208acd60cda98a6d7e15e90fbb65a508c0","modified":1472287561535},{"_id":"public/tags/维修/index.html","hash":"16a18b107e9e84d86f59de727744a0ed9b77358d","modified":1472287561535},{"_id":"public/tags/Google-I-O/index.html","hash":"985ae297089cdaa87c823cdabbe8bd2ce66b491a","modified":1472287561535},{"_id":"public/tags/Microsoft/index.html","hash":"41a5bbcb87104e15c500bcfe0a6d6f6ac0c929ec","modified":1472287561535},{"_id":"public/tags/Spartan/index.html","hash":"41a5bbcb87104e15c500bcfe0a6d6f6ac0c929ec","modified":1472287561535},{"_id":"public/tags/浏览器/index.html","hash":"41a5bbcb87104e15c500bcfe0a6d6f6ac0c929ec","modified":1472287561535},{"_id":"public/tags/Edge/index.html","hash":"41a5bbcb87104e15c500bcfe0a6d6f6ac0c929ec","modified":1472287561535},{"_id":"public/tags/AlphaGo/index.html","hash":"3a8ab36f7d60cff88dd3fcefa5a022f1e19397cc","modified":1472287561535},{"_id":"public/tags/AI/index.html","hash":"3a8ab36f7d60cff88dd3fcefa5a022f1e19397cc","modified":1472287561535},{"_id":"public/tags/科普/index.html","hash":"bd10a7910aa8b3ddc2d037d767c318644c0175a3","modified":1472287561535},{"_id":"public/tags/机器学习/index.html","hash":"3a8ab36f7d60cff88dd3fcefa5a022f1e19397cc","modified":1472287561535},{"_id":"public/tags/影像/index.html","hash":"34fb85ec05026716e531b4a672ecb41fccabd3f7","modified":1472287561535},{"_id":"public/tags/字体/index.html","hash":"624f8acf3959441c63e14dd4ff358cd7a2a48aad","modified":1472287561535},{"_id":"public/tags/通讯/index.html","hash":"74c86f9206429b829ded59509b7160d9c2197271","modified":1472287561535},{"_id":"public/tags/HTTPS/index.html","hash":"68cc0f9ffabc55a7de11c0a548d4281709ee3c70","modified":1472287561535},{"_id":"public/tags/Lambda/index.html","hash":"6d85aef9121373940d3b2670cddda668259e4364","modified":1472287561535},{"_id":"public/tags/编程/index.html","hash":"6d85aef9121373940d3b2670cddda668259e4364","modified":1472287561535},{"_id":"public/tags/Ruby/index.html","hash":"106b2921763cbcff285d6d0a03ef954d07e9baca","modified":1472287561535},{"_id":"public/tags/Lisp/index.html","hash":"6d85aef9121373940d3b2670cddda668259e4364","modified":1472287561535},{"_id":"public/tags/PHP/index.html","hash":"106b2921763cbcff285d6d0a03ef954d07e9baca","modified":1472287561535},{"_id":"public/tags/Apple/index.html","hash":"d4ae10bab9e9fb55189b689b668ed06ed40504c7","modified":1472287561535},{"_id":"public/tags/操作系统/index.html","hash":"b74ae9765d050774966929b0ce0fe3b28c9fc3f0","modified":1472287561535},{"_id":"public/tags/iOS/index.html","hash":"008f36c507915e2d21db5ea1e5edd465b3a8a809","modified":1472287561535},{"_id":"public/tags/Samsung/index.html","hash":"4cb4cb943e9f819da10bc1ceb48128440353102e","modified":1472287561535},{"_id":"public/tags/SuperAmoled/index.html","hash":"4cb4cb943e9f819da10bc1ceb48128440353102e","modified":1472287561535},{"_id":"public/tags/魅族/index.html","hash":"c5b1afc6db05f728f5d3c593f51228949b869457","modified":1472287561535},{"_id":"public/tags/DPI/index.html","hash":"0ea842f3ecc8bf2d3954da7e55164660eee32d4c","modified":1472287561535},{"_id":"public/tags/DDoS/index.html","hash":"a2be00584fd3514850cd34e640d2fac2acf0107f","modified":1472287561535},{"_id":"public/tags/网络/index.html","hash":"a2be00584fd3514850cd34e640d2fac2acf0107f","modified":1472287561535},{"_id":"public/tags/女权/index.html","hash":"2b8999b7ba3f314ec994ae5fb8dbc026b0b363e5","modified":1472287561535},{"_id":"public/tags/LGBT/index.html","hash":"2b8999b7ba3f314ec994ae5fb8dbc026b0b363e5","modified":1472287561536},{"_id":"public/tags/权利/index.html","hash":"2b8999b7ba3f314ec994ae5fb8dbc026b0b363e5","modified":1472287561536},{"_id":"public/tags/日志/index.html","hash":"9f2527bd09bcfe39ac04393e3e06d9d673fb1003","modified":1472287561536},{"_id":"public/tags/12306/index.html","hash":"1f1c7e8c3d5d002140428ea9c977c78e0bf65ea4","modified":1472287561536},{"_id":"public/tags/屏幕/index.html","hash":"22066e3d77e251b7d0d9194cd76ce0c708a81440","modified":1472287561536},{"_id":"public/tags/设计/index.html","hash":"e04c756aaa4a98c6a02dae86a596466843c5b17b","modified":1472287561536},{"_id":"public/archives/2016/08/index.html","hash":"62fdd3130a10851557421dbc2fd63ef0a04f5cee","modified":1472287561540},{"_id":"public/tags/HeckPsi/index.html","hash":"62fdd3130a10851557421dbc2fd63ef0a04f5cee","modified":1472287561540},{"_id":"public/tags/Genji/index.html","hash":"62fdd3130a10851557421dbc2fd63ef0a04f5cee","modified":1472287561540},{"_id":"public/favicon.png","hash":"af4ad42a0f9c56a6fd0e8a4ac183586e9619ecce","modified":1472287561540},{"_id":"public/logo.png","hash":"09089694846c9792c54e71a3b678a90823929b14","modified":1472287561540},{"_id":"public/scss/apollo.scss","hash":"a3153dfedbaff08c20930b2bde95f2db49f6d518","modified":1472287561540},{"_id":"public/css/apollo.css","hash":"9a5ff2fbb383beb4451b98d2c516f10590e30ca0","modified":1472287561544}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"免费的代价还是畸形的产物——浅谈中国视频网站广告制度","date":"2014-05-01T13:34:52.000Z","_content":"\n这周倒是有不少大消息。其中一条比较有意思的就是看到爱奇艺视频全部退出了B站，各方的反应是相当不一的。借着这个机会来谈一下我对中国视频网站广告制度的看法。\n\n一切一切都开始，我们先要确定一个重要的观点。公司是要赚钱的，否则是要饿死的。有关于这个问题，我之前说中国的软件业的时候就提到过。我说在中国卖软件是一件很不靠谱的事情。目前中国人就把看不到实物的东西都当不要钱，还跑到店里大吵“我都花了两千元买了电脑，你给我装的系统还是盗版的！”。同理，中国所有的知识产权业都很难考出售产品本身来赚钱。比如唱片业，比如印刷业。\n\n<!--more-->\n\n同样的，视频网站是要赚钱的。同样的，在中国搞什么付费视频订阅是极度不靠谱的事情。不只是在中国，其实国外的视频网站也多是以广告收入作为主要收入的。别小看这广告收入啊，大家要明白一个重要的道理：免费的就是最贵的！有人说是 360 让中国杀毒软件进入了免费时代，实际上却是 360 让中国杀毒软件进入了群体性流氓状态。各种捆绑，各种弹窗，最赚钱了。你看卡巴斯基上市了吗？360 居然上市啦！\n在网络视频里，最赚钱的莫过于 Google 旗下的 Youtube 咯。不说别的，光一曲《江南Style》的视频播放的广告点击量就给谷歌带来净利润约 51000 美金（约合 33 万人民币）。以 2012 年一年为例，Google 在 Youtube 上就赚了 24 亿美金。要知道优酷的市值不过 30 来亿美金。\n\n但是，我们却发现，我们在优酷上看的广告时长是 Youtube 的好几倍。国内的各大视频公司的盈利率一般在 30% 左右，而 Youtube 的盈利率达到了 35%。为什么 Youtube 只有这么点广告（一般就十来秒，而且不感兴趣可跳过），而国内广告那么多，却达不到 Youtube 的盈利率呢？\n其实就是一个问题。广告点击率低！为什么广告点击率低？因为你不知道用户想要什么广告！为什么不知道用户想要什么广告？因为你技术不够硬啊！Youtube 会根据用户观看视频的记录以及看和他类似视频的人点了哪些广告来分析，这个人可能需要什么广告，当然这背后也包括了 Google 的相关数据。所以 Youtube 能提供给用户他们想要的广告。广告点击率高了，自然不用很长的广告也能带来足够的利润。\n\n爱奇艺为什么被 B 站网友喷呢？广告时间太长、各种闪退、各种崩溃问题其实无不透露出爱奇艺产品部门的无能。退出后还摆出一副高姿态的样子说是好心给网友看版权视频，却被喷。实际情况，确是因为自己技术差，被人骂了，受不了刺激，还摆出阿Q精神，说这是你们的错。你以正版片源为要挟，给用户看劣质、崩溃、大量广告、极差的用户体验的视频，能不被喷吗？\n\n中国公司总喜欢干一件事，叫多元化。也就是做大做强里面的做大。强还不强，大一定要大。做大之前请先把本分工作做好了。你爱奇艺搞直播、搞电视、还搞新闻、搞电影。求你先把你自己的用户体验好好做好吧。\n\n对于许多中国的互联网公司啊，其实我只有一句话来评价他们：\n`Jack of all trades.Master of none.`\n\n","source":"_posts/ads-on-videos-in-china.md","raw":"---\ntitle: 免费的代价还是畸形的产物——浅谈中国视频网站广告制度\ndate: 2014-05-01 21:34:52\ntags: [互联网,广告]\n---\n\n这周倒是有不少大消息。其中一条比较有意思的就是看到爱奇艺视频全部退出了B站，各方的反应是相当不一的。借着这个机会来谈一下我对中国视频网站广告制度的看法。\n\n一切一切都开始，我们先要确定一个重要的观点。公司是要赚钱的，否则是要饿死的。有关于这个问题，我之前说中国的软件业的时候就提到过。我说在中国卖软件是一件很不靠谱的事情。目前中国人就把看不到实物的东西都当不要钱，还跑到店里大吵“我都花了两千元买了电脑，你给我装的系统还是盗版的！”。同理，中国所有的知识产权业都很难考出售产品本身来赚钱。比如唱片业，比如印刷业。\n\n<!--more-->\n\n同样的，视频网站是要赚钱的。同样的，在中国搞什么付费视频订阅是极度不靠谱的事情。不只是在中国，其实国外的视频网站也多是以广告收入作为主要收入的。别小看这广告收入啊，大家要明白一个重要的道理：免费的就是最贵的！有人说是 360 让中国杀毒软件进入了免费时代，实际上却是 360 让中国杀毒软件进入了群体性流氓状态。各种捆绑，各种弹窗，最赚钱了。你看卡巴斯基上市了吗？360 居然上市啦！\n在网络视频里，最赚钱的莫过于 Google 旗下的 Youtube 咯。不说别的，光一曲《江南Style》的视频播放的广告点击量就给谷歌带来净利润约 51000 美金（约合 33 万人民币）。以 2012 年一年为例，Google 在 Youtube 上就赚了 24 亿美金。要知道优酷的市值不过 30 来亿美金。\n\n但是，我们却发现，我们在优酷上看的广告时长是 Youtube 的好几倍。国内的各大视频公司的盈利率一般在 30% 左右，而 Youtube 的盈利率达到了 35%。为什么 Youtube 只有这么点广告（一般就十来秒，而且不感兴趣可跳过），而国内广告那么多，却达不到 Youtube 的盈利率呢？\n其实就是一个问题。广告点击率低！为什么广告点击率低？因为你不知道用户想要什么广告！为什么不知道用户想要什么广告？因为你技术不够硬啊！Youtube 会根据用户观看视频的记录以及看和他类似视频的人点了哪些广告来分析，这个人可能需要什么广告，当然这背后也包括了 Google 的相关数据。所以 Youtube 能提供给用户他们想要的广告。广告点击率高了，自然不用很长的广告也能带来足够的利润。\n\n爱奇艺为什么被 B 站网友喷呢？广告时间太长、各种闪退、各种崩溃问题其实无不透露出爱奇艺产品部门的无能。退出后还摆出一副高姿态的样子说是好心给网友看版权视频，却被喷。实际情况，确是因为自己技术差，被人骂了，受不了刺激，还摆出阿Q精神，说这是你们的错。你以正版片源为要挟，给用户看劣质、崩溃、大量广告、极差的用户体验的视频，能不被喷吗？\n\n中国公司总喜欢干一件事，叫多元化。也就是做大做强里面的做大。强还不强，大一定要大。做大之前请先把本分工作做好了。你爱奇艺搞直播、搞电视、还搞新闻、搞电影。求你先把你自己的用户体验好好做好吧。\n\n对于许多中国的互联网公司啊，其实我只有一句话来评价他们：\n`Jack of all trades.Master of none.`\n\n","slug":"ads-on-videos-in-china","published":1,"updated":"2016-04-22T06:48:23.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscy00850000pp8z0hxqk1nk","content":"<p>这周倒是有不少大消息。其中一条比较有意思的就是看到爱奇艺视频全部退出了B站，各方的反应是相当不一的。借着这个机会来谈一下我对中国视频网站广告制度的看法。</p>\n<p>一切一切都开始，我们先要确定一个重要的观点。公司是要赚钱的，否则是要饿死的。有关于这个问题，我之前说中国的软件业的时候就提到过。我说在中国卖软件是一件很不靠谱的事情。目前中国人就把看不到实物的东西都当不要钱，还跑到店里大吵“我都花了两千元买了电脑，你给我装的系统还是盗版的！”。同理，中国所有的知识产权业都很难考出售产品本身来赚钱。比如唱片业，比如印刷业。</p>\n<a id=\"more\"></a>\n<p>同样的，视频网站是要赚钱的。同样的，在中国搞什么付费视频订阅是极度不靠谱的事情。不只是在中国，其实国外的视频网站也多是以广告收入作为主要收入的。别小看这广告收入啊，大家要明白一个重要的道理：免费的就是最贵的！有人说是 360 让中国杀毒软件进入了免费时代，实际上却是 360 让中国杀毒软件进入了群体性流氓状态。各种捆绑，各种弹窗，最赚钱了。你看卡巴斯基上市了吗？360 居然上市啦！<br>在网络视频里，最赚钱的莫过于 Google 旗下的 Youtube 咯。不说别的，光一曲《江南Style》的视频播放的广告点击量就给谷歌带来净利润约 51000 美金（约合 33 万人民币）。以 2012 年一年为例，Google 在 Youtube 上就赚了 24 亿美金。要知道优酷的市值不过 30 来亿美金。</p>\n<p>但是，我们却发现，我们在优酷上看的广告时长是 Youtube 的好几倍。国内的各大视频公司的盈利率一般在 30% 左右，而 Youtube 的盈利率达到了 35%。为什么 Youtube 只有这么点广告（一般就十来秒，而且不感兴趣可跳过），而国内广告那么多，却达不到 Youtube 的盈利率呢？<br>其实就是一个问题。广告点击率低！为什么广告点击率低？因为你不知道用户想要什么广告！为什么不知道用户想要什么广告？因为你技术不够硬啊！Youtube 会根据用户观看视频的记录以及看和他类似视频的人点了哪些广告来分析，这个人可能需要什么广告，当然这背后也包括了 Google 的相关数据。所以 Youtube 能提供给用户他们想要的广告。广告点击率高了，自然不用很长的广告也能带来足够的利润。</p>\n<p>爱奇艺为什么被 B 站网友喷呢？广告时间太长、各种闪退、各种崩溃问题其实无不透露出爱奇艺产品部门的无能。退出后还摆出一副高姿态的样子说是好心给网友看版权视频，却被喷。实际情况，确是因为自己技术差，被人骂了，受不了刺激，还摆出阿Q精神，说这是你们的错。你以正版片源为要挟，给用户看劣质、崩溃、大量广告、极差的用户体验的视频，能不被喷吗？</p>\n<p>中国公司总喜欢干一件事，叫多元化。也就是做大做强里面的做大。强还不强，大一定要大。做大之前请先把本分工作做好了。你爱奇艺搞直播、搞电视、还搞新闻、搞电影。求你先把你自己的用户体验好好做好吧。</p>\n<p>对于许多中国的互联网公司啊，其实我只有一句话来评价他们：<br><code>Jack of all trades.Master of none.</code></p>\n","excerpt":"<p>这周倒是有不少大消息。其中一条比较有意思的就是看到爱奇艺视频全部退出了B站，各方的反应是相当不一的。借着这个机会来谈一下我对中国视频网站广告制度的看法。</p>\n<p>一切一切都开始，我们先要确定一个重要的观点。公司是要赚钱的，否则是要饿死的。有关于这个问题，我之前说中国的软件业的时候就提到过。我说在中国卖软件是一件很不靠谱的事情。目前中国人就把看不到实物的东西都当不要钱，还跑到店里大吵“我都花了两千元买了电脑，你给我装的系统还是盗版的！”。同理，中国所有的知识产权业都很难考出售产品本身来赚钱。比如唱片业，比如印刷业。</p>","more":"<p>同样的，视频网站是要赚钱的。同样的，在中国搞什么付费视频订阅是极度不靠谱的事情。不只是在中国，其实国外的视频网站也多是以广告收入作为主要收入的。别小看这广告收入啊，大家要明白一个重要的道理：免费的就是最贵的！有人说是 360 让中国杀毒软件进入了免费时代，实际上却是 360 让中国杀毒软件进入了群体性流氓状态。各种捆绑，各种弹窗，最赚钱了。你看卡巴斯基上市了吗？360 居然上市啦！<br>在网络视频里，最赚钱的莫过于 Google 旗下的 Youtube 咯。不说别的，光一曲《江南Style》的视频播放的广告点击量就给谷歌带来净利润约 51000 美金（约合 33 万人民币）。以 2012 年一年为例，Google 在 Youtube 上就赚了 24 亿美金。要知道优酷的市值不过 30 来亿美金。</p>\n<p>但是，我们却发现，我们在优酷上看的广告时长是 Youtube 的好几倍。国内的各大视频公司的盈利率一般在 30% 左右，而 Youtube 的盈利率达到了 35%。为什么 Youtube 只有这么点广告（一般就十来秒，而且不感兴趣可跳过），而国内广告那么多，却达不到 Youtube 的盈利率呢？<br>其实就是一个问题。广告点击率低！为什么广告点击率低？因为你不知道用户想要什么广告！为什么不知道用户想要什么广告？因为你技术不够硬啊！Youtube 会根据用户观看视频的记录以及看和他类似视频的人点了哪些广告来分析，这个人可能需要什么广告，当然这背后也包括了 Google 的相关数据。所以 Youtube 能提供给用户他们想要的广告。广告点击率高了，自然不用很长的广告也能带来足够的利润。</p>\n<p>爱奇艺为什么被 B 站网友喷呢？广告时间太长、各种闪退、各种崩溃问题其实无不透露出爱奇艺产品部门的无能。退出后还摆出一副高姿态的样子说是好心给网友看版权视频，却被喷。实际情况，确是因为自己技术差，被人骂了，受不了刺激，还摆出阿Q精神，说这是你们的错。你以正版片源为要挟，给用户看劣质、崩溃、大量广告、极差的用户体验的视频，能不被喷吗？</p>\n<p>中国公司总喜欢干一件事，叫多元化。也就是做大做强里面的做大。强还不强，大一定要大。做大之前请先把本分工作做好了。你爱奇艺搞直播、搞电视、还搞新闻、搞电影。求你先把你自己的用户体验好好做好吧。</p>\n<p>对于许多中国的互联网公司啊，其实我只有一句话来评价他们：<br><code>Jack of all trades.Master of none.</code></p>"},{"title":"杀毒软件的免费化与流氓化","date":"2015-05-03T08:41:48.000Z","_content":"\n我至今还记得在 12 年前，当我第一次在一台赛扬3的机器上安装上金山毒霸 2003 之后的情形。这个杀毒软件也不过几个按钮，杀毒的时候我的电脑也不卡，半个小时可以扫描完一个 20G 的硬盘，没有弹窗也没有广告，不过倒是需要付费买下 CD-Key。\n\n我也记得 12 年前，当我第一次在这台机器上莫名其妙安装上了 3721 上网助手的情形。打开 IE 浏览器的速度明显变慢了，还多了奇奇怪怪的启动项。不过我并不很讨厌这个插件，它看起来很酷，也挺有意思，虽然不怎么用。\n\n```\n这是最好的时代，也是最坏的时代。\n—— 查尔斯·狄更斯《双城记》\n```\n\n<!--more-->\n\n2008 年的时候，我第一次认识了那个还在测试版本的 360 杀毒。这是中国杀毒软件中第一个敢于做免费的。测试版本的 360 杀毒非常轻，软件一共只有寥寥几个界面，使用的是 BitDefender 的查杀引擎，查杀的效果其实还挺不错。在 1.0 版本发布之后，360 也加大了宣传力度，一度以“免费”的概念打入市场，并且获得了非常大的市场占有。\n\n为了与之竞争，瑞星、金山等大量杀毒软件厂商也将自身产品免费化了。但是，问题来了，杀毒软件凭什么可以免费？\n\n当然，各大厂商会用一个非常通用的理由来给你解释：这个叫“互联网思维”。互联网本身就应该是产品免费的，通过基于免费产品的拓展服务来盈利，最大的例子就是 Google，搜索功能本身是免费的，而通过基于搜索的广告服务来实现盈利。这个理由听起来非常有道理，但是仔细想想其实漏洞百出。搜索引擎可以通过学习用户的搜索习惯来了解用户的需求，发现潜在的消费目标，推出合适的广告。那杀毒软件学习什么呢？学习用户中过的病毒可以用来推送广告？广告又推送在哪里呢？要知道搜索引擎通常实在浏览器前端运行的，而杀毒软件总是在系统后台默默运行的啊，没有展示的地方啊。\n\n拥有庞大装机量之后的 360 给我们展示了，什么是杀毒软件的“互联网思维”。360 最嚣张的时候莫过于 2011 年上市先后。通过给用户弹出弹窗，提示用户使用的 QQ 存在风险，要求用户下载安装 360 扣扣保镖，然后通过所谓“扫描”后提示 QQ 监控用户隐私文件，然后提示用户启用保护，阻止 QQ 对硬盘进行读取操作，同时屏蔽 QQ 的广告、迷你新闻等功能，还用户一个安全的“QQ”。\n\n这件事便是 3Q 大战的开始。一个长期静默在后台的“杀毒”软件，可以对用户病毒以外的程序进行直接的干涉，影响其他产品的正常运行。通过推送服务，使得自身其他产品快速获得高市场占有率，通过别的产品和服务来实现盈利。没错，杀毒软件的运行方式非常底层于系统，事实上他们可以干涉你系统里的任何东西，成为了你操作系统里的“老大哥”。\n\n之后的很多东西我们也能看到这种方式的影子，比如通过弹窗推送安装 360 浏览器、360 手机助手，使得在前端业务的市场占有极快提升。装一个 360，莫名其妙就把 360 全家给装上了。再通过广告等方式实现盈利。同样地，从收费走向免费的金山杀毒也开始弹出广告、弹出金山手机卫士、猎豹浏览器等服务来实现其业务的快速扩张。\n\n所以，以 2011 年可以做一个很明确的分界线。2011 年以前，上网中病毒、中流氓插件，2011年以后，上网中杀毒软件、中安全卫士。毕竟原来写病毒的都嫌弃病毒来钱慢都去搞流氓安全软件去了。\n\n但不得不说，这种模式虽然非常恶心，但却是非常精明的“生意人”，2011 年 360 在美国上市，2014 年猎豹在美国上市，这一个个发展飞快。但是这些软件在弹窗和推送中夹杂的“忽悠”用户下载其他软件的内容也并不完全没风险。2012 年 360 所有 iOS 手机端应用因被苹果查出刷票行为，被全面下架处理。2013 年 360 手机端产品再次因为涉及用户隐私等原因再遭苹果市场下架，并导致国家工信部介入调查。同样的，猎豹清理大师因为恶意推送广告，也遭到了 Google Play 市场下架。这些也都是流氓行为背后的问题。\n\n这时候我们看看中国的杀毒软件市场，注重技术研发的比如微点一个个入不敷出面临倒闭，一个个流氓运营的却如风顺水。反观国外市场，通常有面向个人用户的免费提供基本杀毒功能的产品比如微软MSE、小红伞免费版、Avast免费版，有面向更复杂需求的付费版本。至少没见到过一天到晚弹窗的。并且做杀毒软件的，也更倾向于提高杀毒软件的技术水平而不是横向扩展。\n\n所以杀毒软件在中国并不是走向了免费化，只不过是走向了流氓化，所谓，免费的才是最贵的。\n\n但今年最让人不可思议的是 360 被三大杀毒软件评测机构宣布在测试中存在舞弊行为，被撤销了认证。可能很多同学并不清楚这些测试机构是什么。他们每年会收集最新的病毒样本，然后测试杀毒软件的两个参数：是否能够查杀出全部的病毒？是否会将正常文件误判成病毒？360 被称舞弊是因为，在送去测试版本的 360 杀毒中默认打开了 BitDefender 引擎，查杀率 100%，误杀率 0%，被颁发了认证。但是，在 360 官网上下载的版本默认是关闭 BitDefender 引擎的，查杀率明显降低，误杀率明显提高，所以被称为舞弊。当然，360 之所以要关闭原因是显然的，BitDefender 引擎对资源消耗非常大，而 360 面向的用户中许多人电脑配置糟糕，根本没法打开这引擎。但是为了取得好的测试成绩，在送测时把这引擎打开了。这样的测试结果根本不真实，代表不了 360 杀毒在用户机器上运行的实际情况。\n\n这样的事情其实原先我是理解的，这毕竟和 360 面对的市场有关系。但是不可思议的是，360 随后发表了声明 [《传统杀毒评测标准落后云时代，我们宣布退出AV-C》](http://weibo.com/p/1001603838152715428532)。这就变得非常让人震惊了。如果你说考试制度不合理，你拒绝参加考试，我觉得也是可以理解的。但实际问题是你被抓出了考试作弊，然后你说考试要抓作弊这事不合理你要拒绝考试，这简直是滑天下之大稽！\n\n我们再反观这里面的逻辑，传统杀毒评测标准落后云时代。传统病毒评测标准就是两点：查杀率和误杀率。难道云时代的杀毒软件是可以在这两件事上放水的吗？而且这份声明也十分可笑。比如里面说 360 在送测版本中没有任何作弊行为，问题是作弊都被抓了现行竟还说没有作弊也是非常不可思议。再比如里面举例说病毒可以恶意操作 TeamViewer，所以理应把 TeamViewer 当病毒处理，这更是可笑。TeamViewer 本身又没有安全性问题，你要当病毒处理的是捆绑在 TeamViewer 上的病毒程序啊，你把整个 TeamViewer 当病毒了竟然还有理了，那你为什么不把同样拥有远程操作功能的 QQ 给当病毒处理了？全篇偷换概念玩得非常溜，也是要为 360 公关部门的水平要给出满分。\n\n那么所谓云时代的标准又是什么呢？是对未知病毒行为进行预测还是基于 P2P 的病毒库？我想恐怕还没有定论，反正无论哪个 360 都没做好。360 口中的云时代反大概是不停运用“云服务”给你推送其它软件的云流氓标准吧。\n\n","source":"_posts/anti-virus-softwares-in-china.md","raw":"---\ntitle: 杀毒软件的免费化与流氓化\ndate: 2015-05-03 16:41:48\ntags: [杀毒软件,安全]\n---\n\n我至今还记得在 12 年前，当我第一次在一台赛扬3的机器上安装上金山毒霸 2003 之后的情形。这个杀毒软件也不过几个按钮，杀毒的时候我的电脑也不卡，半个小时可以扫描完一个 20G 的硬盘，没有弹窗也没有广告，不过倒是需要付费买下 CD-Key。\n\n我也记得 12 年前，当我第一次在这台机器上莫名其妙安装上了 3721 上网助手的情形。打开 IE 浏览器的速度明显变慢了，还多了奇奇怪怪的启动项。不过我并不很讨厌这个插件，它看起来很酷，也挺有意思，虽然不怎么用。\n\n```\n这是最好的时代，也是最坏的时代。\n—— 查尔斯·狄更斯《双城记》\n```\n\n<!--more-->\n\n2008 年的时候，我第一次认识了那个还在测试版本的 360 杀毒。这是中国杀毒软件中第一个敢于做免费的。测试版本的 360 杀毒非常轻，软件一共只有寥寥几个界面，使用的是 BitDefender 的查杀引擎，查杀的效果其实还挺不错。在 1.0 版本发布之后，360 也加大了宣传力度，一度以“免费”的概念打入市场，并且获得了非常大的市场占有。\n\n为了与之竞争，瑞星、金山等大量杀毒软件厂商也将自身产品免费化了。但是，问题来了，杀毒软件凭什么可以免费？\n\n当然，各大厂商会用一个非常通用的理由来给你解释：这个叫“互联网思维”。互联网本身就应该是产品免费的，通过基于免费产品的拓展服务来盈利，最大的例子就是 Google，搜索功能本身是免费的，而通过基于搜索的广告服务来实现盈利。这个理由听起来非常有道理，但是仔细想想其实漏洞百出。搜索引擎可以通过学习用户的搜索习惯来了解用户的需求，发现潜在的消费目标，推出合适的广告。那杀毒软件学习什么呢？学习用户中过的病毒可以用来推送广告？广告又推送在哪里呢？要知道搜索引擎通常实在浏览器前端运行的，而杀毒软件总是在系统后台默默运行的啊，没有展示的地方啊。\n\n拥有庞大装机量之后的 360 给我们展示了，什么是杀毒软件的“互联网思维”。360 最嚣张的时候莫过于 2011 年上市先后。通过给用户弹出弹窗，提示用户使用的 QQ 存在风险，要求用户下载安装 360 扣扣保镖，然后通过所谓“扫描”后提示 QQ 监控用户隐私文件，然后提示用户启用保护，阻止 QQ 对硬盘进行读取操作，同时屏蔽 QQ 的广告、迷你新闻等功能，还用户一个安全的“QQ”。\n\n这件事便是 3Q 大战的开始。一个长期静默在后台的“杀毒”软件，可以对用户病毒以外的程序进行直接的干涉，影响其他产品的正常运行。通过推送服务，使得自身其他产品快速获得高市场占有率，通过别的产品和服务来实现盈利。没错，杀毒软件的运行方式非常底层于系统，事实上他们可以干涉你系统里的任何东西，成为了你操作系统里的“老大哥”。\n\n之后的很多东西我们也能看到这种方式的影子，比如通过弹窗推送安装 360 浏览器、360 手机助手，使得在前端业务的市场占有极快提升。装一个 360，莫名其妙就把 360 全家给装上了。再通过广告等方式实现盈利。同样地，从收费走向免费的金山杀毒也开始弹出广告、弹出金山手机卫士、猎豹浏览器等服务来实现其业务的快速扩张。\n\n所以，以 2011 年可以做一个很明确的分界线。2011 年以前，上网中病毒、中流氓插件，2011年以后，上网中杀毒软件、中安全卫士。毕竟原来写病毒的都嫌弃病毒来钱慢都去搞流氓安全软件去了。\n\n但不得不说，这种模式虽然非常恶心，但却是非常精明的“生意人”，2011 年 360 在美国上市，2014 年猎豹在美国上市，这一个个发展飞快。但是这些软件在弹窗和推送中夹杂的“忽悠”用户下载其他软件的内容也并不完全没风险。2012 年 360 所有 iOS 手机端应用因被苹果查出刷票行为，被全面下架处理。2013 年 360 手机端产品再次因为涉及用户隐私等原因再遭苹果市场下架，并导致国家工信部介入调查。同样的，猎豹清理大师因为恶意推送广告，也遭到了 Google Play 市场下架。这些也都是流氓行为背后的问题。\n\n这时候我们看看中国的杀毒软件市场，注重技术研发的比如微点一个个入不敷出面临倒闭，一个个流氓运营的却如风顺水。反观国外市场，通常有面向个人用户的免费提供基本杀毒功能的产品比如微软MSE、小红伞免费版、Avast免费版，有面向更复杂需求的付费版本。至少没见到过一天到晚弹窗的。并且做杀毒软件的，也更倾向于提高杀毒软件的技术水平而不是横向扩展。\n\n所以杀毒软件在中国并不是走向了免费化，只不过是走向了流氓化，所谓，免费的才是最贵的。\n\n但今年最让人不可思议的是 360 被三大杀毒软件评测机构宣布在测试中存在舞弊行为，被撤销了认证。可能很多同学并不清楚这些测试机构是什么。他们每年会收集最新的病毒样本，然后测试杀毒软件的两个参数：是否能够查杀出全部的病毒？是否会将正常文件误判成病毒？360 被称舞弊是因为，在送去测试版本的 360 杀毒中默认打开了 BitDefender 引擎，查杀率 100%，误杀率 0%，被颁发了认证。但是，在 360 官网上下载的版本默认是关闭 BitDefender 引擎的，查杀率明显降低，误杀率明显提高，所以被称为舞弊。当然，360 之所以要关闭原因是显然的，BitDefender 引擎对资源消耗非常大，而 360 面向的用户中许多人电脑配置糟糕，根本没法打开这引擎。但是为了取得好的测试成绩，在送测时把这引擎打开了。这样的测试结果根本不真实，代表不了 360 杀毒在用户机器上运行的实际情况。\n\n这样的事情其实原先我是理解的，这毕竟和 360 面对的市场有关系。但是不可思议的是，360 随后发表了声明 [《传统杀毒评测标准落后云时代，我们宣布退出AV-C》](http://weibo.com/p/1001603838152715428532)。这就变得非常让人震惊了。如果你说考试制度不合理，你拒绝参加考试，我觉得也是可以理解的。但实际问题是你被抓出了考试作弊，然后你说考试要抓作弊这事不合理你要拒绝考试，这简直是滑天下之大稽！\n\n我们再反观这里面的逻辑，传统杀毒评测标准落后云时代。传统病毒评测标准就是两点：查杀率和误杀率。难道云时代的杀毒软件是可以在这两件事上放水的吗？而且这份声明也十分可笑。比如里面说 360 在送测版本中没有任何作弊行为，问题是作弊都被抓了现行竟还说没有作弊也是非常不可思议。再比如里面举例说病毒可以恶意操作 TeamViewer，所以理应把 TeamViewer 当病毒处理，这更是可笑。TeamViewer 本身又没有安全性问题，你要当病毒处理的是捆绑在 TeamViewer 上的病毒程序啊，你把整个 TeamViewer 当病毒了竟然还有理了，那你为什么不把同样拥有远程操作功能的 QQ 给当病毒处理了？全篇偷换概念玩得非常溜，也是要为 360 公关部门的水平要给出满分。\n\n那么所谓云时代的标准又是什么呢？是对未知病毒行为进行预测还是基于 P2P 的病毒库？我想恐怕还没有定论，反正无论哪个 360 都没做好。360 口中的云时代反大概是不停运用“云服务”给你推送其它软件的云流氓标准吧。\n\n","slug":"anti-virus-softwares-in-china","published":1,"updated":"2016-04-23T13:03:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscy008a0001pp8znlh4yjwo","content":"<p>我至今还记得在 12 年前，当我第一次在一台赛扬3的机器上安装上金山毒霸 2003 之后的情形。这个杀毒软件也不过几个按钮，杀毒的时候我的电脑也不卡，半个小时可以扫描完一个 20G 的硬盘，没有弹窗也没有广告，不过倒是需要付费买下 CD-Key。</p>\n<p>我也记得 12 年前，当我第一次在这台机器上莫名其妙安装上了 3721 上网助手的情形。打开 IE 浏览器的速度明显变慢了，还多了奇奇怪怪的启动项。不过我并不很讨厌这个插件，它看起来很酷，也挺有意思，虽然不怎么用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这是最好的时代，也是最坏的时代。</span><br><span class=\"line\">—— 查尔斯·狄更斯《双城记》</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>2008 年的时候，我第一次认识了那个还在测试版本的 360 杀毒。这是中国杀毒软件中第一个敢于做免费的。测试版本的 360 杀毒非常轻，软件一共只有寥寥几个界面，使用的是 BitDefender 的查杀引擎，查杀的效果其实还挺不错。在 1.0 版本发布之后，360 也加大了宣传力度，一度以“免费”的概念打入市场，并且获得了非常大的市场占有。</p>\n<p>为了与之竞争，瑞星、金山等大量杀毒软件厂商也将自身产品免费化了。但是，问题来了，杀毒软件凭什么可以免费？</p>\n<p>当然，各大厂商会用一个非常通用的理由来给你解释：这个叫“互联网思维”。互联网本身就应该是产品免费的，通过基于免费产品的拓展服务来盈利，最大的例子就是 Google，搜索功能本身是免费的，而通过基于搜索的广告服务来实现盈利。这个理由听起来非常有道理，但是仔细想想其实漏洞百出。搜索引擎可以通过学习用户的搜索习惯来了解用户的需求，发现潜在的消费目标，推出合适的广告。那杀毒软件学习什么呢？学习用户中过的病毒可以用来推送广告？广告又推送在哪里呢？要知道搜索引擎通常实在浏览器前端运行的，而杀毒软件总是在系统后台默默运行的啊，没有展示的地方啊。</p>\n<p>拥有庞大装机量之后的 360 给我们展示了，什么是杀毒软件的“互联网思维”。360 最嚣张的时候莫过于 2011 年上市先后。通过给用户弹出弹窗，提示用户使用的 QQ 存在风险，要求用户下载安装 360 扣扣保镖，然后通过所谓“扫描”后提示 QQ 监控用户隐私文件，然后提示用户启用保护，阻止 QQ 对硬盘进行读取操作，同时屏蔽 QQ 的广告、迷你新闻等功能，还用户一个安全的“QQ”。</p>\n<p>这件事便是 3Q 大战的开始。一个长期静默在后台的“杀毒”软件，可以对用户病毒以外的程序进行直接的干涉，影响其他产品的正常运行。通过推送服务，使得自身其他产品快速获得高市场占有率，通过别的产品和服务来实现盈利。没错，杀毒软件的运行方式非常底层于系统，事实上他们可以干涉你系统里的任何东西，成为了你操作系统里的“老大哥”。</p>\n<p>之后的很多东西我们也能看到这种方式的影子，比如通过弹窗推送安装 360 浏览器、360 手机助手，使得在前端业务的市场占有极快提升。装一个 360，莫名其妙就把 360 全家给装上了。再通过广告等方式实现盈利。同样地，从收费走向免费的金山杀毒也开始弹出广告、弹出金山手机卫士、猎豹浏览器等服务来实现其业务的快速扩张。</p>\n<p>所以，以 2011 年可以做一个很明确的分界线。2011 年以前，上网中病毒、中流氓插件，2011年以后，上网中杀毒软件、中安全卫士。毕竟原来写病毒的都嫌弃病毒来钱慢都去搞流氓安全软件去了。</p>\n<p>但不得不说，这种模式虽然非常恶心，但却是非常精明的“生意人”，2011 年 360 在美国上市，2014 年猎豹在美国上市，这一个个发展飞快。但是这些软件在弹窗和推送中夹杂的“忽悠”用户下载其他软件的内容也并不完全没风险。2012 年 360 所有 iOS 手机端应用因被苹果查出刷票行为，被全面下架处理。2013 年 360 手机端产品再次因为涉及用户隐私等原因再遭苹果市场下架，并导致国家工信部介入调查。同样的，猎豹清理大师因为恶意推送广告，也遭到了 Google Play 市场下架。这些也都是流氓行为背后的问题。</p>\n<p>这时候我们看看中国的杀毒软件市场，注重技术研发的比如微点一个个入不敷出面临倒闭，一个个流氓运营的却如风顺水。反观国外市场，通常有面向个人用户的免费提供基本杀毒功能的产品比如微软MSE、小红伞免费版、Avast免费版，有面向更复杂需求的付费版本。至少没见到过一天到晚弹窗的。并且做杀毒软件的，也更倾向于提高杀毒软件的技术水平而不是横向扩展。</p>\n<p>所以杀毒软件在中国并不是走向了免费化，只不过是走向了流氓化，所谓，免费的才是最贵的。</p>\n<p>但今年最让人不可思议的是 360 被三大杀毒软件评测机构宣布在测试中存在舞弊行为，被撤销了认证。可能很多同学并不清楚这些测试机构是什么。他们每年会收集最新的病毒样本，然后测试杀毒软件的两个参数：是否能够查杀出全部的病毒？是否会将正常文件误判成病毒？360 被称舞弊是因为，在送去测试版本的 360 杀毒中默认打开了 BitDefender 引擎，查杀率 100%，误杀率 0%，被颁发了认证。但是，在 360 官网上下载的版本默认是关闭 BitDefender 引擎的，查杀率明显降低，误杀率明显提高，所以被称为舞弊。当然，360 之所以要关闭原因是显然的，BitDefender 引擎对资源消耗非常大，而 360 面向的用户中许多人电脑配置糟糕，根本没法打开这引擎。但是为了取得好的测试成绩，在送测时把这引擎打开了。这样的测试结果根本不真实，代表不了 360 杀毒在用户机器上运行的实际情况。</p>\n<p>这样的事情其实原先我是理解的，这毕竟和 360 面对的市场有关系。但是不可思议的是，360 随后发表了声明 <a href=\"http://weibo.com/p/1001603838152715428532\" target=\"_blank\" rel=\"external\">《传统杀毒评测标准落后云时代，我们宣布退出AV-C》</a>。这就变得非常让人震惊了。如果你说考试制度不合理，你拒绝参加考试，我觉得也是可以理解的。但实际问题是你被抓出了考试作弊，然后你说考试要抓作弊这事不合理你要拒绝考试，这简直是滑天下之大稽！</p>\n<p>我们再反观这里面的逻辑，传统杀毒评测标准落后云时代。传统病毒评测标准就是两点：查杀率和误杀率。难道云时代的杀毒软件是可以在这两件事上放水的吗？而且这份声明也十分可笑。比如里面说 360 在送测版本中没有任何作弊行为，问题是作弊都被抓了现行竟还说没有作弊也是非常不可思议。再比如里面举例说病毒可以恶意操作 TeamViewer，所以理应把 TeamViewer 当病毒处理，这更是可笑。TeamViewer 本身又没有安全性问题，你要当病毒处理的是捆绑在 TeamViewer 上的病毒程序啊，你把整个 TeamViewer 当病毒了竟然还有理了，那你为什么不把同样拥有远程操作功能的 QQ 给当病毒处理了？全篇偷换概念玩得非常溜，也是要为 360 公关部门的水平要给出满分。</p>\n<p>那么所谓云时代的标准又是什么呢？是对未知病毒行为进行预测还是基于 P2P 的病毒库？我想恐怕还没有定论，反正无论哪个 360 都没做好。360 口中的云时代反大概是不停运用“云服务”给你推送其它软件的云流氓标准吧。</p>\n","excerpt":"<p>我至今还记得在 12 年前，当我第一次在一台赛扬3的机器上安装上金山毒霸 2003 之后的情形。这个杀毒软件也不过几个按钮，杀毒的时候我的电脑也不卡，半个小时可以扫描完一个 20G 的硬盘，没有弹窗也没有广告，不过倒是需要付费买下 CD-Key。</p>\n<p>我也记得 12 年前，当我第一次在这台机器上莫名其妙安装上了 3721 上网助手的情形。打开 IE 浏览器的速度明显变慢了，还多了奇奇怪怪的启动项。不过我并不很讨厌这个插件，它看起来很酷，也挺有意思，虽然不怎么用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这是最好的时代，也是最坏的时代。</span><br><span class=\"line\">—— 查尔斯·狄更斯《双城记》</span><br></pre></td></tr></table></figure>","more":"<p>2008 年的时候，我第一次认识了那个还在测试版本的 360 杀毒。这是中国杀毒软件中第一个敢于做免费的。测试版本的 360 杀毒非常轻，软件一共只有寥寥几个界面，使用的是 BitDefender 的查杀引擎，查杀的效果其实还挺不错。在 1.0 版本发布之后，360 也加大了宣传力度，一度以“免费”的概念打入市场，并且获得了非常大的市场占有。</p>\n<p>为了与之竞争，瑞星、金山等大量杀毒软件厂商也将自身产品免费化了。但是，问题来了，杀毒软件凭什么可以免费？</p>\n<p>当然，各大厂商会用一个非常通用的理由来给你解释：这个叫“互联网思维”。互联网本身就应该是产品免费的，通过基于免费产品的拓展服务来盈利，最大的例子就是 Google，搜索功能本身是免费的，而通过基于搜索的广告服务来实现盈利。这个理由听起来非常有道理，但是仔细想想其实漏洞百出。搜索引擎可以通过学习用户的搜索习惯来了解用户的需求，发现潜在的消费目标，推出合适的广告。那杀毒软件学习什么呢？学习用户中过的病毒可以用来推送广告？广告又推送在哪里呢？要知道搜索引擎通常实在浏览器前端运行的，而杀毒软件总是在系统后台默默运行的啊，没有展示的地方啊。</p>\n<p>拥有庞大装机量之后的 360 给我们展示了，什么是杀毒软件的“互联网思维”。360 最嚣张的时候莫过于 2011 年上市先后。通过给用户弹出弹窗，提示用户使用的 QQ 存在风险，要求用户下载安装 360 扣扣保镖，然后通过所谓“扫描”后提示 QQ 监控用户隐私文件，然后提示用户启用保护，阻止 QQ 对硬盘进行读取操作，同时屏蔽 QQ 的广告、迷你新闻等功能，还用户一个安全的“QQ”。</p>\n<p>这件事便是 3Q 大战的开始。一个长期静默在后台的“杀毒”软件，可以对用户病毒以外的程序进行直接的干涉，影响其他产品的正常运行。通过推送服务，使得自身其他产品快速获得高市场占有率，通过别的产品和服务来实现盈利。没错，杀毒软件的运行方式非常底层于系统，事实上他们可以干涉你系统里的任何东西，成为了你操作系统里的“老大哥”。</p>\n<p>之后的很多东西我们也能看到这种方式的影子，比如通过弹窗推送安装 360 浏览器、360 手机助手，使得在前端业务的市场占有极快提升。装一个 360，莫名其妙就把 360 全家给装上了。再通过广告等方式实现盈利。同样地，从收费走向免费的金山杀毒也开始弹出广告、弹出金山手机卫士、猎豹浏览器等服务来实现其业务的快速扩张。</p>\n<p>所以，以 2011 年可以做一个很明确的分界线。2011 年以前，上网中病毒、中流氓插件，2011年以后，上网中杀毒软件、中安全卫士。毕竟原来写病毒的都嫌弃病毒来钱慢都去搞流氓安全软件去了。</p>\n<p>但不得不说，这种模式虽然非常恶心，但却是非常精明的“生意人”，2011 年 360 在美国上市，2014 年猎豹在美国上市，这一个个发展飞快。但是这些软件在弹窗和推送中夹杂的“忽悠”用户下载其他软件的内容也并不完全没风险。2012 年 360 所有 iOS 手机端应用因被苹果查出刷票行为，被全面下架处理。2013 年 360 手机端产品再次因为涉及用户隐私等原因再遭苹果市场下架，并导致国家工信部介入调查。同样的，猎豹清理大师因为恶意推送广告，也遭到了 Google Play 市场下架。这些也都是流氓行为背后的问题。</p>\n<p>这时候我们看看中国的杀毒软件市场，注重技术研发的比如微点一个个入不敷出面临倒闭，一个个流氓运营的却如风顺水。反观国外市场，通常有面向个人用户的免费提供基本杀毒功能的产品比如微软MSE、小红伞免费版、Avast免费版，有面向更复杂需求的付费版本。至少没见到过一天到晚弹窗的。并且做杀毒软件的，也更倾向于提高杀毒软件的技术水平而不是横向扩展。</p>\n<p>所以杀毒软件在中国并不是走向了免费化，只不过是走向了流氓化，所谓，免费的才是最贵的。</p>\n<p>但今年最让人不可思议的是 360 被三大杀毒软件评测机构宣布在测试中存在舞弊行为，被撤销了认证。可能很多同学并不清楚这些测试机构是什么。他们每年会收集最新的病毒样本，然后测试杀毒软件的两个参数：是否能够查杀出全部的病毒？是否会将正常文件误判成病毒？360 被称舞弊是因为，在送去测试版本的 360 杀毒中默认打开了 BitDefender 引擎，查杀率 100%，误杀率 0%，被颁发了认证。但是，在 360 官网上下载的版本默认是关闭 BitDefender 引擎的，查杀率明显降低，误杀率明显提高，所以被称为舞弊。当然，360 之所以要关闭原因是显然的，BitDefender 引擎对资源消耗非常大，而 360 面向的用户中许多人电脑配置糟糕，根本没法打开这引擎。但是为了取得好的测试成绩，在送测时把这引擎打开了。这样的测试结果根本不真实，代表不了 360 杀毒在用户机器上运行的实际情况。</p>\n<p>这样的事情其实原先我是理解的，这毕竟和 360 面对的市场有关系。但是不可思议的是，360 随后发表了声明 <a href=\"http://weibo.com/p/1001603838152715428532\">《传统杀毒评测标准落后云时代，我们宣布退出AV-C》</a>。这就变得非常让人震惊了。如果你说考试制度不合理，你拒绝参加考试，我觉得也是可以理解的。但实际问题是你被抓出了考试作弊，然后你说考试要抓作弊这事不合理你要拒绝考试，这简直是滑天下之大稽！</p>\n<p>我们再反观这里面的逻辑，传统杀毒评测标准落后云时代。传统病毒评测标准就是两点：查杀率和误杀率。难道云时代的杀毒软件是可以在这两件事上放水的吗？而且这份声明也十分可笑。比如里面说 360 在送测版本中没有任何作弊行为，问题是作弊都被抓了现行竟还说没有作弊也是非常不可思议。再比如里面举例说病毒可以恶意操作 TeamViewer，所以理应把 TeamViewer 当病毒处理，这更是可笑。TeamViewer 本身又没有安全性问题，你要当病毒处理的是捆绑在 TeamViewer 上的病毒程序啊，你把整个 TeamViewer 当病毒了竟然还有理了，那你为什么不把同样拥有远程操作功能的 QQ 给当病毒处理了？全篇偷换概念玩得非常溜，也是要为 360 公关部门的水平要给出满分。</p>\n<p>那么所谓云时代的标准又是什么呢？是对未知病毒行为进行预测还是基于 P2P 的病毒库？我想恐怕还没有定论，反正无论哪个 360 都没做好。360 口中的云时代反大概是不停运用“云服务”给你推送其它软件的云流氓标准吧。</p>"},{"title":"也谈 Android 应用的热更新","date":"2016-02-05T16:29:00.000Z","dsc":"我正在考虑我们是不是有一个其它的更加通用的路径在 Java 上来实现动态的修改方法从而进行热更新。","_content":"\n## 起因\n\n这几天支付宝的所谓「隐私门」的火热程度非同一般。至于支付宝有没有监控用户的隐私数据，双方至今也没有争论出一个结果出来。但我倒是被阿里官方所发的声明所惊讶到了，它们在声明中提到，他们可以在云端开关你手上支付宝的功能，这一点是违背对 Java 作为静态语言的常识的。而网友更是发现，这一点并不是用 API 来简单控制的，而是可以从云端下发代码下来来实现「热更新」，随时修改 apk 的本身。稍加研究，就发现了手机淘宝团队曾经在 QCon 上做过有关于相关主题的 [演讲](http://www.infoq.com/cn/presentations/mobile-phone-taobao-hotpatch-technology-introduction) 。\n\n手机淘宝的热更新技术基于他们所开发的 Dexposed 框架，而 Dexposed 框架其实就是一个应用内的 Xposed 框架，而手机淘宝团队也大方承认了他们的许多代码也是直接从 Xposed 的开源项目里拿的。通过这个技术，框架对应用内的类都实现了 hook，可以通过云端下发的 dex 对这些类进行动态的修改，并且只损失相当较小的性能。而这个技术脱离了传统想要动态修改代码必须把整个开发框架都更换为运行于脚本语言之上的尴尬。\n\n然而当我细究这个框架的时候发现了一些问题。阿里虽然对这一框架进行了 [开源](http://github.com/alibaba/dexposed) 。但已经很久没有更新过新版本了。当前的版本只支持到了 Android 4.4。由于 5.0 起新的 ART 虚拟机、更严格的 SELinux 策略以及对 64 位的支持之类的事，使得 Xposed 都在开发上做了很多调整。我不知道 Dexposed 现在是否支持，但至少阿里没有开源。\n\n考虑到这些情况，我正在考虑我们是不是有一个其它的更加通用的路径在 Java 上来实现动态的修改方法从而进行热更新。\n\n<!--more-->\n\n## 警告\n\n**在本地动态执行远端下发的代码是极度危险的行为。利用此方法执行非法代码等或用于绕过 Google Play 等市场的审查是违反相关协议的，也是对用户极度不负责任的行为。**\n\n## ART 虚拟机带来的挑战\n\nXposed 面对 ART 虚拟机的时候究竟是遇到了什么样的问题呢？这要从 ART 虚拟机的原理说起。Java 是一门编译成 ByteCode，并由本地的虚拟机进一步动态地解释成机器码的语言。在旧版本的 Android 上所使用的 Dalvik 虚拟机其运行原理与 Oracle 的官方虚拟机是非常接近的。这样的解释对性能的消耗，虽然有 JIT 对其运行的优化，比起像 Objective-C 这样的纯编译语言来说还是差上一些性能的。\n\n为了解决性能上的颓势，Android 在 4.4 版本上首次引入了默认不开启的测试版本的 ART 虚拟机，并在 Android 5.0 上成为了默认的虚拟机。其重要的变化是在 apk 的安装过程中，进行所谓 AOT(Ahead-of-Time) 的优化。即在安装过程中尽可能地将 ByteCode 静态编译了，并进行代码优化。这使得运行时注入的难度更高了。\n\nXposed 框架通过修改了 libart.so 等相关虚拟机文件关闭了一系列的优化，才使得框架终在 Android 5.0 上运行。而相对的，Dexposed 并不能修改系统虚拟机文件，毕竟这只是应用内的框架，这就使得难度变得很高。代码一旦被静态编译甚至被优化后再做 Java 层面上的 hook 确实难度很高。那么我们能不能在 Java 本身上找到一种被语言本身所支持的 hook 方式以使得更好的兼容呢？\n\n## Java 的馈赠\n\n显然，Java 是没有 eval() 函数的，也就是没有语言本身所支持的可以动态运行 Java 代码的方法。但当我在 Java 的文档里搜索 eval 的时候，我还真发现了一些什么。自 JDK 1.6 起，Java 内置了一个执行脚本的包 javax.script。目前支持的语言只有 JavaScript。也就是说 Java 内置了一个「动态语言」 JavaScript 的解释器！\n\n等一下，我并不是希望你用 JavaScript 来写 Android 应用，因为这毕竟不那么快，我们之所以写原生应用，性能是我们考虑的一大原因。但是如果我们仅在热更新时「临时地」插入一段 JavaScript 代码也并不是一件坏事。但这样的话就存在一个问题，那就是 Java 的变量和 JavaScript 变量如何绑定的问题了。没关系，ScriptEngine 早已实现了这一功能。你可以通过 ScriptEngine.put(String, Object) 的方法在运行前写入 JavaScript 的变量，在运行后通过 ScriptEngine.get(String) 的方法来获得变量。\n\n示例的 Java 代码：\n\n``` java\ntry {\n  ScriptEngine engine = new ScriptEngineManager().getEngineByName(\"javascript\");\n  engine.put(\"a\", 1);\n  engine.put(\"b\", 2);\n  engine.eval(\"var ans_1 = a + b; var ans_2 = a - b;\");\n  System.out.println(engine.get(\"ans_1\"));\n  System.out.println(engine.get(\"ans_2\"));\n} catch (Exception e){\n  e.printStackTrace();\n}\n```\n\n打印如下：\n\n``` \n3.0\n-1.0\n```\n\n## 利弊\n\n这样做的好处是很显然的，这是 Java 语言层的支持，兼容性好得惊人。而且，这不会影响到 ART 虚拟机的 AOT 优化，你的代码依然可以在 Android 5.0+ 上和原来一样快。\n\n但弊端也是很明显的。插入的代码由于是脚本语言，初始化脚本语言引擎和变量传递都是一个比较消耗性能的东西。但是你大可只在热更新的地方才初始化脚本语言引擎，在没有被更新到的地方依然正常地运行下去。不过在一些访问非常密集的地方使用热更新可能会对效率产生相对比较大的影响，应该避免使用。\n\n## 示例封装\n\n说完这些，我们可以对 Java 的 ScriptEngine 进行一些封装成为一个 HotPatch 类使得它更适合做热更新的工作。\n\nHot Patch 需要注入的地方分为三个类型\n\n1. 入口 Activity\n2. 类方法\n\n### 入口 Activity\n\n对于入口 Activity，我们希望它能发送一个异步的网络请求检测是否有新的热补丁，如果有，那么下载。下载后将对应的需要 hook 的地方的名称和对应的代码以 key-value 的形式保存下来就行。出于方便，我们可以直接使用 Android 内置的 `SharedPreferences` 来存储。这样我们只需要在 Activity 的 `onCreate` 中通过一个 Annotation 来插入。\n\n``` java\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n  super.onCreate(savedInstanceState);\n  @HotPatchUpdate(\"https://www.hotpatch.com/getUpdate\", this);\n}\n```\n\n需要注意的是，这个 Update 的实现需要有几个注意点。这个管道一定要建立在 https 上，因为下发代码是极其危险的，如果被劫持，后果是无法想象的。其次请求时最好自动带上 Android 版本、手机型号、地区、版本号等信息，以方便更精确地下发，千万不能下发错。然后每次执行到这里时应先检查是否有已经下载好的补丁。如果有，请校验其是否合法，以避免用户升级后，相关的补丁已经过期却仍然被运行导致更大的问题。\n\n### 类方法\n\n类方法里主要有两处做 hook 是最为有效的，一个是方法的一开始，而另一处是 return 处。只要将方法的 i/o hook 了，就能解决所有问题。\n\n所以我们分别在这两处插入两个 Annotation 的方法，在尽可能不影响优雅度地情况下插入代码。\n\n``` java\npublic class Test{\n  public android.content.Context context;\n  public Test (android.content.Context context){this.context = context;}\n  public int add(int a, int b){\n    @HotPatchHook(\"addStart\", context, a, b)\n    int c = a + b;\n    @HotPatchHook(\"addEnd\", context, c)\n    return c;\n  }\n}\n```\n\n其中 `\"addStart\"` 和 `\"addEnd\"` 分别是两个索引，分别对应去寻找热补丁中对应的代码。而 context 必须传入是因为要找 `SharedPreferences`，如果你通过其它方式来实现存储的话，则不需要。`a` 和 `b` 还有 `c` 是被 Hook 的变量。有一点特别注意，当参数被 JavaScript 引擎传回时请校验其是否是 null。至于如果一个类型在 JavaScript 中找不到的话，Java 中的 ScriptEngine 所支持的 JavaScript 是可以插入 Java 的 import 包的，所以可以避开这样的问题。形如  `String jsCode = \"importPackage(java.util);var list2 = Arrays.asList(['A', 'B', 'C']); \"; `  的代码是可以被解释的。当然你也可以只传入 `int`、`double`、`boolean` 类型，然后手动写 `set` 和 `get` 方法。这取决于你自己想要什么样的代码风格。\n\n## 总结\n\n至此，我们通过实现两个简单的 Annotation 的方法，实现在 Android 上 Java 语言层面所支持的热更新的方法。当然，这样的实现并不是太过完善，还需要做很多细节上的调整。但是对于简单的热更新来说已经是足够好用了，实现一遍的话所需要的代码数也很少。同时，稍作修改，我们可以将这样的代码运行在任何 Java 程序上，实现 Java 客户端的热更新，而不只局限于 Android。\n\n这样的热更新虽然会带来少许的性能问题，但比起将整个程序都跑在脚本上，这样的解决方案已经好上很多，更重要的是，当你没有热更新时，并不会对性能造成影响。同时，其 Java 语言层面的支持，也使得其兼容性非常良好，可以作为对于作为线上、线下调试的比较好的工具。\n\n相比 Dexposed，这样的方法还显得比较低级，也无法 hook 系统类，没有办法做更多更底层的操作，也无法支持 ndk。但一般意义上来说，这已经足够好用了。\n\n但是，最后还是要提醒一句：\n\n**在本地动态执行远端下发的代码是极度危险的行为。利用此方法执行非法代码等或用于绕过 Google Play 等市场的审查是违反相关协议的，也是对用户极度不负责任的行为。**\n\n","source":"_posts/android-hot-patch.md","raw":"---\ntitle: 也谈 Android 应用的热更新\ndate: 2016-02-06 00:29:00\ndsc: 我正在考虑我们是不是有一个其它的更加通用的路径在 Java 上来实现动态的修改方法从而进行热更新。\ntags: [Android,JavaScript,架构]\n---\n\n## 起因\n\n这几天支付宝的所谓「隐私门」的火热程度非同一般。至于支付宝有没有监控用户的隐私数据，双方至今也没有争论出一个结果出来。但我倒是被阿里官方所发的声明所惊讶到了，它们在声明中提到，他们可以在云端开关你手上支付宝的功能，这一点是违背对 Java 作为静态语言的常识的。而网友更是发现，这一点并不是用 API 来简单控制的，而是可以从云端下发代码下来来实现「热更新」，随时修改 apk 的本身。稍加研究，就发现了手机淘宝团队曾经在 QCon 上做过有关于相关主题的 [演讲](http://www.infoq.com/cn/presentations/mobile-phone-taobao-hotpatch-technology-introduction) 。\n\n手机淘宝的热更新技术基于他们所开发的 Dexposed 框架，而 Dexposed 框架其实就是一个应用内的 Xposed 框架，而手机淘宝团队也大方承认了他们的许多代码也是直接从 Xposed 的开源项目里拿的。通过这个技术，框架对应用内的类都实现了 hook，可以通过云端下发的 dex 对这些类进行动态的修改，并且只损失相当较小的性能。而这个技术脱离了传统想要动态修改代码必须把整个开发框架都更换为运行于脚本语言之上的尴尬。\n\n然而当我细究这个框架的时候发现了一些问题。阿里虽然对这一框架进行了 [开源](http://github.com/alibaba/dexposed) 。但已经很久没有更新过新版本了。当前的版本只支持到了 Android 4.4。由于 5.0 起新的 ART 虚拟机、更严格的 SELinux 策略以及对 64 位的支持之类的事，使得 Xposed 都在开发上做了很多调整。我不知道 Dexposed 现在是否支持，但至少阿里没有开源。\n\n考虑到这些情况，我正在考虑我们是不是有一个其它的更加通用的路径在 Java 上来实现动态的修改方法从而进行热更新。\n\n<!--more-->\n\n## 警告\n\n**在本地动态执行远端下发的代码是极度危险的行为。利用此方法执行非法代码等或用于绕过 Google Play 等市场的审查是违反相关协议的，也是对用户极度不负责任的行为。**\n\n## ART 虚拟机带来的挑战\n\nXposed 面对 ART 虚拟机的时候究竟是遇到了什么样的问题呢？这要从 ART 虚拟机的原理说起。Java 是一门编译成 ByteCode，并由本地的虚拟机进一步动态地解释成机器码的语言。在旧版本的 Android 上所使用的 Dalvik 虚拟机其运行原理与 Oracle 的官方虚拟机是非常接近的。这样的解释对性能的消耗，虽然有 JIT 对其运行的优化，比起像 Objective-C 这样的纯编译语言来说还是差上一些性能的。\n\n为了解决性能上的颓势，Android 在 4.4 版本上首次引入了默认不开启的测试版本的 ART 虚拟机，并在 Android 5.0 上成为了默认的虚拟机。其重要的变化是在 apk 的安装过程中，进行所谓 AOT(Ahead-of-Time) 的优化。即在安装过程中尽可能地将 ByteCode 静态编译了，并进行代码优化。这使得运行时注入的难度更高了。\n\nXposed 框架通过修改了 libart.so 等相关虚拟机文件关闭了一系列的优化，才使得框架终在 Android 5.0 上运行。而相对的，Dexposed 并不能修改系统虚拟机文件，毕竟这只是应用内的框架，这就使得难度变得很高。代码一旦被静态编译甚至被优化后再做 Java 层面上的 hook 确实难度很高。那么我们能不能在 Java 本身上找到一种被语言本身所支持的 hook 方式以使得更好的兼容呢？\n\n## Java 的馈赠\n\n显然，Java 是没有 eval() 函数的，也就是没有语言本身所支持的可以动态运行 Java 代码的方法。但当我在 Java 的文档里搜索 eval 的时候，我还真发现了一些什么。自 JDK 1.6 起，Java 内置了一个执行脚本的包 javax.script。目前支持的语言只有 JavaScript。也就是说 Java 内置了一个「动态语言」 JavaScript 的解释器！\n\n等一下，我并不是希望你用 JavaScript 来写 Android 应用，因为这毕竟不那么快，我们之所以写原生应用，性能是我们考虑的一大原因。但是如果我们仅在热更新时「临时地」插入一段 JavaScript 代码也并不是一件坏事。但这样的话就存在一个问题，那就是 Java 的变量和 JavaScript 变量如何绑定的问题了。没关系，ScriptEngine 早已实现了这一功能。你可以通过 ScriptEngine.put(String, Object) 的方法在运行前写入 JavaScript 的变量，在运行后通过 ScriptEngine.get(String) 的方法来获得变量。\n\n示例的 Java 代码：\n\n``` java\ntry {\n  ScriptEngine engine = new ScriptEngineManager().getEngineByName(\"javascript\");\n  engine.put(\"a\", 1);\n  engine.put(\"b\", 2);\n  engine.eval(\"var ans_1 = a + b; var ans_2 = a - b;\");\n  System.out.println(engine.get(\"ans_1\"));\n  System.out.println(engine.get(\"ans_2\"));\n} catch (Exception e){\n  e.printStackTrace();\n}\n```\n\n打印如下：\n\n``` \n3.0\n-1.0\n```\n\n## 利弊\n\n这样做的好处是很显然的，这是 Java 语言层的支持，兼容性好得惊人。而且，这不会影响到 ART 虚拟机的 AOT 优化，你的代码依然可以在 Android 5.0+ 上和原来一样快。\n\n但弊端也是很明显的。插入的代码由于是脚本语言，初始化脚本语言引擎和变量传递都是一个比较消耗性能的东西。但是你大可只在热更新的地方才初始化脚本语言引擎，在没有被更新到的地方依然正常地运行下去。不过在一些访问非常密集的地方使用热更新可能会对效率产生相对比较大的影响，应该避免使用。\n\n## 示例封装\n\n说完这些，我们可以对 Java 的 ScriptEngine 进行一些封装成为一个 HotPatch 类使得它更适合做热更新的工作。\n\nHot Patch 需要注入的地方分为三个类型\n\n1. 入口 Activity\n2. 类方法\n\n### 入口 Activity\n\n对于入口 Activity，我们希望它能发送一个异步的网络请求检测是否有新的热补丁，如果有，那么下载。下载后将对应的需要 hook 的地方的名称和对应的代码以 key-value 的形式保存下来就行。出于方便，我们可以直接使用 Android 内置的 `SharedPreferences` 来存储。这样我们只需要在 Activity 的 `onCreate` 中通过一个 Annotation 来插入。\n\n``` java\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n  super.onCreate(savedInstanceState);\n  @HotPatchUpdate(\"https://www.hotpatch.com/getUpdate\", this);\n}\n```\n\n需要注意的是，这个 Update 的实现需要有几个注意点。这个管道一定要建立在 https 上，因为下发代码是极其危险的，如果被劫持，后果是无法想象的。其次请求时最好自动带上 Android 版本、手机型号、地区、版本号等信息，以方便更精确地下发，千万不能下发错。然后每次执行到这里时应先检查是否有已经下载好的补丁。如果有，请校验其是否合法，以避免用户升级后，相关的补丁已经过期却仍然被运行导致更大的问题。\n\n### 类方法\n\n类方法里主要有两处做 hook 是最为有效的，一个是方法的一开始，而另一处是 return 处。只要将方法的 i/o hook 了，就能解决所有问题。\n\n所以我们分别在这两处插入两个 Annotation 的方法，在尽可能不影响优雅度地情况下插入代码。\n\n``` java\npublic class Test{\n  public android.content.Context context;\n  public Test (android.content.Context context){this.context = context;}\n  public int add(int a, int b){\n    @HotPatchHook(\"addStart\", context, a, b)\n    int c = a + b;\n    @HotPatchHook(\"addEnd\", context, c)\n    return c;\n  }\n}\n```\n\n其中 `\"addStart\"` 和 `\"addEnd\"` 分别是两个索引，分别对应去寻找热补丁中对应的代码。而 context 必须传入是因为要找 `SharedPreferences`，如果你通过其它方式来实现存储的话，则不需要。`a` 和 `b` 还有 `c` 是被 Hook 的变量。有一点特别注意，当参数被 JavaScript 引擎传回时请校验其是否是 null。至于如果一个类型在 JavaScript 中找不到的话，Java 中的 ScriptEngine 所支持的 JavaScript 是可以插入 Java 的 import 包的，所以可以避开这样的问题。形如  `String jsCode = \"importPackage(java.util);var list2 = Arrays.asList(['A', 'B', 'C']); \"; `  的代码是可以被解释的。当然你也可以只传入 `int`、`double`、`boolean` 类型，然后手动写 `set` 和 `get` 方法。这取决于你自己想要什么样的代码风格。\n\n## 总结\n\n至此，我们通过实现两个简单的 Annotation 的方法，实现在 Android 上 Java 语言层面所支持的热更新的方法。当然，这样的实现并不是太过完善，还需要做很多细节上的调整。但是对于简单的热更新来说已经是足够好用了，实现一遍的话所需要的代码数也很少。同时，稍作修改，我们可以将这样的代码运行在任何 Java 程序上，实现 Java 客户端的热更新，而不只局限于 Android。\n\n这样的热更新虽然会带来少许的性能问题，但比起将整个程序都跑在脚本上，这样的解决方案已经好上很多，更重要的是，当你没有热更新时，并不会对性能造成影响。同时，其 Java 语言层面的支持，也使得其兼容性非常良好，可以作为对于作为线上、线下调试的比较好的工具。\n\n相比 Dexposed，这样的方法还显得比较低级，也无法 hook 系统类，没有办法做更多更底层的操作，也无法支持 ndk。但一般意义上来说，这已经足够好用了。\n\n但是，最后还是要提醒一句：\n\n**在本地动态执行远端下发的代码是极度危险的行为。利用此方法执行非法代码等或用于绕过 Google Play 等市场的审查是违反相关协议的，也是对用户极度不负责任的行为。**\n\n","slug":"android-hot-patch","published":1,"updated":"2016-04-21T16:33:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscy008e0003pp8zwal8sedu","content":"<h2 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h2><p>这几天支付宝的所谓「隐私门」的火热程度非同一般。至于支付宝有没有监控用户的隐私数据，双方至今也没有争论出一个结果出来。但我倒是被阿里官方所发的声明所惊讶到了，它们在声明中提到，他们可以在云端开关你手上支付宝的功能，这一点是违背对 Java 作为静态语言的常识的。而网友更是发现，这一点并不是用 API 来简单控制的，而是可以从云端下发代码下来来实现「热更新」，随时修改 apk 的本身。稍加研究，就发现了手机淘宝团队曾经在 QCon 上做过有关于相关主题的 <a href=\"http://www.infoq.com/cn/presentations/mobile-phone-taobao-hotpatch-technology-introduction\" target=\"_blank\" rel=\"external\">演讲</a> 。</p>\n<p>手机淘宝的热更新技术基于他们所开发的 Dexposed 框架，而 Dexposed 框架其实就是一个应用内的 Xposed 框架，而手机淘宝团队也大方承认了他们的许多代码也是直接从 Xposed 的开源项目里拿的。通过这个技术，框架对应用内的类都实现了 hook，可以通过云端下发的 dex 对这些类进行动态的修改，并且只损失相当较小的性能。而这个技术脱离了传统想要动态修改代码必须把整个开发框架都更换为运行于脚本语言之上的尴尬。</p>\n<p>然而当我细究这个框架的时候发现了一些问题。阿里虽然对这一框架进行了 <a href=\"http://github.com/alibaba/dexposed\" target=\"_blank\" rel=\"external\">开源</a> 。但已经很久没有更新过新版本了。当前的版本只支持到了 Android 4.4。由于 5.0 起新的 ART 虚拟机、更严格的 SELinux 策略以及对 64 位的支持之类的事，使得 Xposed 都在开发上做了很多调整。我不知道 Dexposed 现在是否支持，但至少阿里没有开源。</p>\n<p>考虑到这些情况，我正在考虑我们是不是有一个其它的更加通用的路径在 Java 上来实现动态的修改方法从而进行热更新。</p>\n<a id=\"more\"></a>\n<h2 id=\"警告\"><a href=\"#警告\" class=\"headerlink\" title=\"警告\"></a>警告</h2><p><strong>在本地动态执行远端下发的代码是极度危险的行为。利用此方法执行非法代码等或用于绕过 Google Play 等市场的审查是违反相关协议的，也是对用户极度不负责任的行为。</strong></p>\n<h2 id=\"ART-虚拟机带来的挑战\"><a href=\"#ART-虚拟机带来的挑战\" class=\"headerlink\" title=\"ART 虚拟机带来的挑战\"></a>ART 虚拟机带来的挑战</h2><p>Xposed 面对 ART 虚拟机的时候究竟是遇到了什么样的问题呢？这要从 ART 虚拟机的原理说起。Java 是一门编译成 ByteCode，并由本地的虚拟机进一步动态地解释成机器码的语言。在旧版本的 Android 上所使用的 Dalvik 虚拟机其运行原理与 Oracle 的官方虚拟机是非常接近的。这样的解释对性能的消耗，虽然有 JIT 对其运行的优化，比起像 Objective-C 这样的纯编译语言来说还是差上一些性能的。</p>\n<p>为了解决性能上的颓势，Android 在 4.4 版本上首次引入了默认不开启的测试版本的 ART 虚拟机，并在 Android 5.0 上成为了默认的虚拟机。其重要的变化是在 apk 的安装过程中，进行所谓 AOT(Ahead-of-Time) 的优化。即在安装过程中尽可能地将 ByteCode 静态编译了，并进行代码优化。这使得运行时注入的难度更高了。</p>\n<p>Xposed 框架通过修改了 libart.so 等相关虚拟机文件关闭了一系列的优化，才使得框架终在 Android 5.0 上运行。而相对的，Dexposed 并不能修改系统虚拟机文件，毕竟这只是应用内的框架，这就使得难度变得很高。代码一旦被静态编译甚至被优化后再做 Java 层面上的 hook 确实难度很高。那么我们能不能在 Java 本身上找到一种被语言本身所支持的 hook 方式以使得更好的兼容呢？</p>\n<h2 id=\"Java-的馈赠\"><a href=\"#Java-的馈赠\" class=\"headerlink\" title=\"Java 的馈赠\"></a>Java 的馈赠</h2><p>显然，Java 是没有 eval() 函数的，也就是没有语言本身所支持的可以动态运行 Java 代码的方法。但当我在 Java 的文档里搜索 eval 的时候，我还真发现了一些什么。自 JDK 1.6 起，Java 内置了一个执行脚本的包 javax.script。目前支持的语言只有 JavaScript。也就是说 Java 内置了一个「动态语言」 JavaScript 的解释器！</p>\n<p>等一下，我并不是希望你用 JavaScript 来写 Android 应用，因为这毕竟不那么快，我们之所以写原生应用，性能是我们考虑的一大原因。但是如果我们仅在热更新时「临时地」插入一段 JavaScript 代码也并不是一件坏事。但这样的话就存在一个问题，那就是 Java 的变量和 JavaScript 变量如何绑定的问题了。没关系，ScriptEngine 早已实现了这一功能。你可以通过 ScriptEngine.put(String, Object) 的方法在运行前写入 JavaScript 的变量，在运行后通过 ScriptEngine.get(String) 的方法来获得变量。</p>\n<p>示例的 Java 代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  ScriptEngine engine = <span class=\"keyword\">new</span> ScriptEngineManager().getEngineByName(<span class=\"string\">\"javascript\"</span>);</span><br><span class=\"line\">  engine.put(<span class=\"string\">\"a\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">  engine.put(<span class=\"string\">\"b\"</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">  engine.eval(<span class=\"string\">\"var ans_1 = a + b; var ans_2 = a - b;\"</span>);</span><br><span class=\"line\">  System.out.println(engine.get(<span class=\"string\">\"ans_1\"</span>));</span><br><span class=\"line\">  System.out.println(engine.get(<span class=\"string\">\"ans_2\"</span>));</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e)&#123;</span><br><span class=\"line\">  e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>打印如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3.0</span><br><span class=\"line\">-1.0</span><br></pre></td></tr></table></figure>\n<h2 id=\"利弊\"><a href=\"#利弊\" class=\"headerlink\" title=\"利弊\"></a>利弊</h2><p>这样做的好处是很显然的，这是 Java 语言层的支持，兼容性好得惊人。而且，这不会影响到 ART 虚拟机的 AOT 优化，你的代码依然可以在 Android 5.0+ 上和原来一样快。</p>\n<p>但弊端也是很明显的。插入的代码由于是脚本语言，初始化脚本语言引擎和变量传递都是一个比较消耗性能的东西。但是你大可只在热更新的地方才初始化脚本语言引擎，在没有被更新到的地方依然正常地运行下去。不过在一些访问非常密集的地方使用热更新可能会对效率产生相对比较大的影响，应该避免使用。</p>\n<h2 id=\"示例封装\"><a href=\"#示例封装\" class=\"headerlink\" title=\"示例封装\"></a>示例封装</h2><p>说完这些，我们可以对 Java 的 ScriptEngine 进行一些封装成为一个 HotPatch 类使得它更适合做热更新的工作。</p>\n<p>Hot Patch 需要注入的地方分为三个类型</p>\n<ol>\n<li>入口 Activity</li>\n<li>类方法</li>\n</ol>\n<h3 id=\"入口-Activity\"><a href=\"#入口-Activity\" class=\"headerlink\" title=\"入口 Activity\"></a>入口 Activity</h3><p>对于入口 Activity，我们希望它能发送一个异步的网络请求检测是否有新的热补丁，如果有，那么下载。下载后将对应的需要 hook 的地方的名称和对应的代码以 key-value 的形式保存下来就行。出于方便，我们可以直接使用 Android 内置的 <code>SharedPreferences</code> 来存储。这样我们只需要在 Activity 的 <code>onCreate</code> 中通过一个 Annotation 来插入。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">  <span class=\"meta\">@HotPatchUpdate</span>(<span class=\"string\">\"https://www.hotpatch.com/getUpdate\"</span>, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，这个 Update 的实现需要有几个注意点。这个管道一定要建立在 https 上，因为下发代码是极其危险的，如果被劫持，后果是无法想象的。其次请求时最好自动带上 Android 版本、手机型号、地区、版本号等信息，以方便更精确地下发，千万不能下发错。然后每次执行到这里时应先检查是否有已经下载好的补丁。如果有，请校验其是否合法，以避免用户升级后，相关的补丁已经过期却仍然被运行导致更大的问题。</p>\n<h3 id=\"类方法\"><a href=\"#类方法\" class=\"headerlink\" title=\"类方法\"></a>类方法</h3><p>类方法里主要有两处做 hook 是最为有效的，一个是方法的一开始，而另一处是 return 处。只要将方法的 i/o hook 了，就能解决所有问题。</p>\n<p>所以我们分别在这两处插入两个 Annotation 的方法，在尽可能不影响优雅度地情况下插入代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> android.content.Context context;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span> <span class=\"params\">(android.content.Context context)</span></span>&#123;<span class=\"keyword\">this</span>.context = context;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@HotPatchHook</span>(<span class=\"string\">\"addStart\"</span>, context, a, b)</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = a + b;</span><br><span class=\"line\">    <span class=\"meta\">@HotPatchHook</span>(<span class=\"string\">\"addEnd\"</span>, context, c)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中 <code>&quot;addStart&quot;</code> 和 <code>&quot;addEnd&quot;</code> 分别是两个索引，分别对应去寻找热补丁中对应的代码。而 context 必须传入是因为要找 <code>SharedPreferences</code>，如果你通过其它方式来实现存储的话，则不需要。<code>a</code> 和 <code>b</code> 还有 <code>c</code> 是被 Hook 的变量。有一点特别注意，当参数被 JavaScript 引擎传回时请校验其是否是 null。至于如果一个类型在 JavaScript 中找不到的话，Java 中的 ScriptEngine 所支持的 JavaScript 是可以插入 Java 的 import 包的，所以可以避开这样的问题。形如  <code>String jsCode = &quot;importPackage(java.util);var list2 = Arrays.asList([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]); &quot;;</code>  的代码是可以被解释的。当然你也可以只传入 <code>int</code>、<code>double</code>、<code>boolean</code> 类型，然后手动写 <code>set</code> 和 <code>get</code> 方法。这取决于你自己想要什么样的代码风格。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>至此，我们通过实现两个简单的 Annotation 的方法，实现在 Android 上 Java 语言层面所支持的热更新的方法。当然，这样的实现并不是太过完善，还需要做很多细节上的调整。但是对于简单的热更新来说已经是足够好用了，实现一遍的话所需要的代码数也很少。同时，稍作修改，我们可以将这样的代码运行在任何 Java 程序上，实现 Java 客户端的热更新，而不只局限于 Android。</p>\n<p>这样的热更新虽然会带来少许的性能问题，但比起将整个程序都跑在脚本上，这样的解决方案已经好上很多，更重要的是，当你没有热更新时，并不会对性能造成影响。同时，其 Java 语言层面的支持，也使得其兼容性非常良好，可以作为对于作为线上、线下调试的比较好的工具。</p>\n<p>相比 Dexposed，这样的方法还显得比较低级，也无法 hook 系统类，没有办法做更多更底层的操作，也无法支持 ndk。但一般意义上来说，这已经足够好用了。</p>\n<p>但是，最后还是要提醒一句：</p>\n<p><strong>在本地动态执行远端下发的代码是极度危险的行为。利用此方法执行非法代码等或用于绕过 Google Play 等市场的审查是违反相关协议的，也是对用户极度不负责任的行为。</strong></p>\n","excerpt":"<h2 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h2><p>这几天支付宝的所谓「隐私门」的火热程度非同一般。至于支付宝有没有监控用户的隐私数据，双方至今也没有争论出一个结果出来。但我倒是被阿里官方所发的声明所惊讶到了，它们在声明中提到，他们可以在云端开关你手上支付宝的功能，这一点是违背对 Java 作为静态语言的常识的。而网友更是发现，这一点并不是用 API 来简单控制的，而是可以从云端下发代码下来来实现「热更新」，随时修改 apk 的本身。稍加研究，就发现了手机淘宝团队曾经在 QCon 上做过有关于相关主题的 <a href=\"http://www.infoq.com/cn/presentations/mobile-phone-taobao-hotpatch-technology-introduction\">演讲</a> 。</p>\n<p>手机淘宝的热更新技术基于他们所开发的 Dexposed 框架，而 Dexposed 框架其实就是一个应用内的 Xposed 框架，而手机淘宝团队也大方承认了他们的许多代码也是直接从 Xposed 的开源项目里拿的。通过这个技术，框架对应用内的类都实现了 hook，可以通过云端下发的 dex 对这些类进行动态的修改，并且只损失相当较小的性能。而这个技术脱离了传统想要动态修改代码必须把整个开发框架都更换为运行于脚本语言之上的尴尬。</p>\n<p>然而当我细究这个框架的时候发现了一些问题。阿里虽然对这一框架进行了 <a href=\"http://github.com/alibaba/dexposed\">开源</a> 。但已经很久没有更新过新版本了。当前的版本只支持到了 Android 4.4。由于 5.0 起新的 ART 虚拟机、更严格的 SELinux 策略以及对 64 位的支持之类的事，使得 Xposed 都在开发上做了很多调整。我不知道 Dexposed 现在是否支持，但至少阿里没有开源。</p>\n<p>考虑到这些情况，我正在考虑我们是不是有一个其它的更加通用的路径在 Java 上来实现动态的修改方法从而进行热更新。</p>","more":"<h2 id=\"警告\"><a href=\"#警告\" class=\"headerlink\" title=\"警告\"></a>警告</h2><p><strong>在本地动态执行远端下发的代码是极度危险的行为。利用此方法执行非法代码等或用于绕过 Google Play 等市场的审查是违反相关协议的，也是对用户极度不负责任的行为。</strong></p>\n<h2 id=\"ART-虚拟机带来的挑战\"><a href=\"#ART-虚拟机带来的挑战\" class=\"headerlink\" title=\"ART 虚拟机带来的挑战\"></a>ART 虚拟机带来的挑战</h2><p>Xposed 面对 ART 虚拟机的时候究竟是遇到了什么样的问题呢？这要从 ART 虚拟机的原理说起。Java 是一门编译成 ByteCode，并由本地的虚拟机进一步动态地解释成机器码的语言。在旧版本的 Android 上所使用的 Dalvik 虚拟机其运行原理与 Oracle 的官方虚拟机是非常接近的。这样的解释对性能的消耗，虽然有 JIT 对其运行的优化，比起像 Objective-C 这样的纯编译语言来说还是差上一些性能的。</p>\n<p>为了解决性能上的颓势，Android 在 4.4 版本上首次引入了默认不开启的测试版本的 ART 虚拟机，并在 Android 5.0 上成为了默认的虚拟机。其重要的变化是在 apk 的安装过程中，进行所谓 AOT(Ahead-of-Time) 的优化。即在安装过程中尽可能地将 ByteCode 静态编译了，并进行代码优化。这使得运行时注入的难度更高了。</p>\n<p>Xposed 框架通过修改了 libart.so 等相关虚拟机文件关闭了一系列的优化，才使得框架终在 Android 5.0 上运行。而相对的，Dexposed 并不能修改系统虚拟机文件，毕竟这只是应用内的框架，这就使得难度变得很高。代码一旦被静态编译甚至被优化后再做 Java 层面上的 hook 确实难度很高。那么我们能不能在 Java 本身上找到一种被语言本身所支持的 hook 方式以使得更好的兼容呢？</p>\n<h2 id=\"Java-的馈赠\"><a href=\"#Java-的馈赠\" class=\"headerlink\" title=\"Java 的馈赠\"></a>Java 的馈赠</h2><p>显然，Java 是没有 eval() 函数的，也就是没有语言本身所支持的可以动态运行 Java 代码的方法。但当我在 Java 的文档里搜索 eval 的时候，我还真发现了一些什么。自 JDK 1.6 起，Java 内置了一个执行脚本的包 javax.script。目前支持的语言只有 JavaScript。也就是说 Java 内置了一个「动态语言」 JavaScript 的解释器！</p>\n<p>等一下，我并不是希望你用 JavaScript 来写 Android 应用，因为这毕竟不那么快，我们之所以写原生应用，性能是我们考虑的一大原因。但是如果我们仅在热更新时「临时地」插入一段 JavaScript 代码也并不是一件坏事。但这样的话就存在一个问题，那就是 Java 的变量和 JavaScript 变量如何绑定的问题了。没关系，ScriptEngine 早已实现了这一功能。你可以通过 ScriptEngine.put(String, Object) 的方法在运行前写入 JavaScript 的变量，在运行后通过 ScriptEngine.get(String) 的方法来获得变量。</p>\n<p>示例的 Java 代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  ScriptEngine engine = <span class=\"keyword\">new</span> ScriptEngineManager().getEngineByName(<span class=\"string\">\"javascript\"</span>);</span><br><span class=\"line\">  engine.put(<span class=\"string\">\"a\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">  engine.put(<span class=\"string\">\"b\"</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">  engine.eval(<span class=\"string\">\"var ans_1 = a + b; var ans_2 = a - b;\"</span>);</span><br><span class=\"line\">  System.out.println(engine.get(<span class=\"string\">\"ans_1\"</span>));</span><br><span class=\"line\">  System.out.println(engine.get(<span class=\"string\">\"ans_2\"</span>));</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e)&#123;</span><br><span class=\"line\">  e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>打印如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3.0</span><br><span class=\"line\">-1.0</span><br></pre></td></tr></table></figure>\n<h2 id=\"利弊\"><a href=\"#利弊\" class=\"headerlink\" title=\"利弊\"></a>利弊</h2><p>这样做的好处是很显然的，这是 Java 语言层的支持，兼容性好得惊人。而且，这不会影响到 ART 虚拟机的 AOT 优化，你的代码依然可以在 Android 5.0+ 上和原来一样快。</p>\n<p>但弊端也是很明显的。插入的代码由于是脚本语言，初始化脚本语言引擎和变量传递都是一个比较消耗性能的东西。但是你大可只在热更新的地方才初始化脚本语言引擎，在没有被更新到的地方依然正常地运行下去。不过在一些访问非常密集的地方使用热更新可能会对效率产生相对比较大的影响，应该避免使用。</p>\n<h2 id=\"示例封装\"><a href=\"#示例封装\" class=\"headerlink\" title=\"示例封装\"></a>示例封装</h2><p>说完这些，我们可以对 Java 的 ScriptEngine 进行一些封装成为一个 HotPatch 类使得它更适合做热更新的工作。</p>\n<p>Hot Patch 需要注入的地方分为三个类型</p>\n<ol>\n<li>入口 Activity</li>\n<li>类方法</li>\n</ol>\n<h3 id=\"入口-Activity\"><a href=\"#入口-Activity\" class=\"headerlink\" title=\"入口 Activity\"></a>入口 Activity</h3><p>对于入口 Activity，我们希望它能发送一个异步的网络请求检测是否有新的热补丁，如果有，那么下载。下载后将对应的需要 hook 的地方的名称和对应的代码以 key-value 的形式保存下来就行。出于方便，我们可以直接使用 Android 内置的 <code>SharedPreferences</code> 来存储。这样我们只需要在 Activity 的 <code>onCreate</code> 中通过一个 Annotation 来插入。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">  <span class=\"meta\">@HotPatchUpdate</span>(<span class=\"string\">\"https://www.hotpatch.com/getUpdate\"</span>, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，这个 Update 的实现需要有几个注意点。这个管道一定要建立在 https 上，因为下发代码是极其危险的，如果被劫持，后果是无法想象的。其次请求时最好自动带上 Android 版本、手机型号、地区、版本号等信息，以方便更精确地下发，千万不能下发错。然后每次执行到这里时应先检查是否有已经下载好的补丁。如果有，请校验其是否合法，以避免用户升级后，相关的补丁已经过期却仍然被运行导致更大的问题。</p>\n<h3 id=\"类方法\"><a href=\"#类方法\" class=\"headerlink\" title=\"类方法\"></a>类方法</h3><p>类方法里主要有两处做 hook 是最为有效的，一个是方法的一开始，而另一处是 return 处。只要将方法的 i/o hook 了，就能解决所有问题。</p>\n<p>所以我们分别在这两处插入两个 Annotation 的方法，在尽可能不影响优雅度地情况下插入代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> android.content.Context context;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span> <span class=\"params\">(android.content.Context context)</span></span>&#123;<span class=\"keyword\">this</span>.context = context;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@HotPatchHook</span>(<span class=\"string\">\"addStart\"</span>, context, a, b)</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = a + b;</span><br><span class=\"line\">    <span class=\"meta\">@HotPatchHook</span>(<span class=\"string\">\"addEnd\"</span>, context, c)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中 <code>&quot;addStart&quot;</code> 和 <code>&quot;addEnd&quot;</code> 分别是两个索引，分别对应去寻找热补丁中对应的代码。而 context 必须传入是因为要找 <code>SharedPreferences</code>，如果你通过其它方式来实现存储的话，则不需要。<code>a</code> 和 <code>b</code> 还有 <code>c</code> 是被 Hook 的变量。有一点特别注意，当参数被 JavaScript 引擎传回时请校验其是否是 null。至于如果一个类型在 JavaScript 中找不到的话，Java 中的 ScriptEngine 所支持的 JavaScript 是可以插入 Java 的 import 包的，所以可以避开这样的问题。形如  <code>String jsCode = &quot;importPackage(java.util);var list2 = Arrays.asList([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]); &quot;;</code>  的代码是可以被解释的。当然你也可以只传入 <code>int</code>、<code>double</code>、<code>boolean</code> 类型，然后手动写 <code>set</code> 和 <code>get</code> 方法。这取决于你自己想要什么样的代码风格。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>至此，我们通过实现两个简单的 Annotation 的方法，实现在 Android 上 Java 语言层面所支持的热更新的方法。当然，这样的实现并不是太过完善，还需要做很多细节上的调整。但是对于简单的热更新来说已经是足够好用了，实现一遍的话所需要的代码数也很少。同时，稍作修改，我们可以将这样的代码运行在任何 Java 程序上，实现 Java 客户端的热更新，而不只局限于 Android。</p>\n<p>这样的热更新虽然会带来少许的性能问题，但比起将整个程序都跑在脚本上，这样的解决方案已经好上很多，更重要的是，当你没有热更新时，并不会对性能造成影响。同时，其 Java 语言层面的支持，也使得其兼容性非常良好，可以作为对于作为线上、线下调试的比较好的工具。</p>\n<p>相比 Dexposed，这样的方法还显得比较低级，也无法 hook 系统类，没有办法做更多更底层的操作，也无法支持 ndk。但一般意义上来说，这已经足够好用了。</p>\n<p>但是，最后还是要提醒一句：</p>\n<p><strong>在本地动态执行远端下发的代码是极度危险的行为。利用此方法执行非法代码等或用于绕过 Google Play 等市场的审查是违反相关协议的，也是对用户极度不负责任的行为。</strong></p>"},{"title":"第一封致用户的道歉信","date":"2015-03-27T10:25:28.000Z","_content":"\nHeckPsi 对所有访问我们网站的用户道歉。\n\n在今天上午 HeckPsi 作为“帮凶”对 GitHub 的两个项目 greatfire 和 cn-nytimes 进行了 DDoS 攻击。\n\n对此，我们深表遗憾并且必须致以我们最为诚挚的道歉。\n\n<!--more-->\n\n造成这样的问题，是由于我们网页内嵌了 百度统计 的代码以统计我们的页面访问量。而今天，百度统计的代码被恶意内嵌了进行 DDoS 攻击的代码。目前暂时不知道这些代码是由百度嵌入的还是由政府要求嵌入的亦或者是黑客攻击百度嵌入的。但其实际造成了严重的影响，造成了严重的后果。\n\nHeckPsi 一向支持开源软件事业，开源软件对我们很重要。我们的服务中所使用的部分软件也是根据开放源代码许可提供的。HeckPsi 绝对不会有意去攻击 GitHub 这样的网站。但是事实上，我们无意中参与了这样的攻击，我们也必须要为如此愚蠢的行为负责。\n\n由于之前百度的种种恶迹，我们在选用第三方服务时已经尽量避开了百度的服务。在过去的几个月内，我们也逐渐将存放于百度云存储的、百度静态库CDN的一些服务出于安全原因进行了几次迁移，但忘记了网页统计使用的依然是百度的服务，没有进行及时的变更，才造成了今天的问题。\n\n目前，HeckPsi 已经停用了全部百度统计的代码，并强制更新了所有页面缓存。临时使用了 Google Analytics 对我们的网站进行统计。同时，我们会在接下来几周内深度检查网页中的各种代码，以避免使用百度的全部服务。同时，我们将在未来使用第三方服务的时候，严格考察第三方服务的可靠性。\n\n对此，给各位造成的影响，表示最大程度的道歉。\n\n","source":"_posts/apology-to-visitors.md","raw":"---\ntitle: 第一封致用户的道歉信\ndate: 2015-03-27 18:25:28\ntags: [站务,百度]\n---\n\nHeckPsi 对所有访问我们网站的用户道歉。\n\n在今天上午 HeckPsi 作为“帮凶”对 GitHub 的两个项目 greatfire 和 cn-nytimes 进行了 DDoS 攻击。\n\n对此，我们深表遗憾并且必须致以我们最为诚挚的道歉。\n\n<!--more-->\n\n造成这样的问题，是由于我们网页内嵌了 百度统计 的代码以统计我们的页面访问量。而今天，百度统计的代码被恶意内嵌了进行 DDoS 攻击的代码。目前暂时不知道这些代码是由百度嵌入的还是由政府要求嵌入的亦或者是黑客攻击百度嵌入的。但其实际造成了严重的影响，造成了严重的后果。\n\nHeckPsi 一向支持开源软件事业，开源软件对我们很重要。我们的服务中所使用的部分软件也是根据开放源代码许可提供的。HeckPsi 绝对不会有意去攻击 GitHub 这样的网站。但是事实上，我们无意中参与了这样的攻击，我们也必须要为如此愚蠢的行为负责。\n\n由于之前百度的种种恶迹，我们在选用第三方服务时已经尽量避开了百度的服务。在过去的几个月内，我们也逐渐将存放于百度云存储的、百度静态库CDN的一些服务出于安全原因进行了几次迁移，但忘记了网页统计使用的依然是百度的服务，没有进行及时的变更，才造成了今天的问题。\n\n目前，HeckPsi 已经停用了全部百度统计的代码，并强制更新了所有页面缓存。临时使用了 Google Analytics 对我们的网站进行统计。同时，我们会在接下来几周内深度检查网页中的各种代码，以避免使用百度的全部服务。同时，我们将在未来使用第三方服务的时候，严格考察第三方服务的可靠性。\n\n对此，给各位造成的影响，表示最大程度的道歉。\n\n","slug":"apology-to-visitors","published":1,"updated":"2016-04-22T06:50:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscy008f0004pp8za1kzx3o6","content":"<p>HeckPsi 对所有访问我们网站的用户道歉。</p>\n<p>在今天上午 HeckPsi 作为“帮凶”对 GitHub 的两个项目 greatfire 和 cn-nytimes 进行了 DDoS 攻击。</p>\n<p>对此，我们深表遗憾并且必须致以我们最为诚挚的道歉。</p>\n<a id=\"more\"></a>\n<p>造成这样的问题，是由于我们网页内嵌了 百度统计 的代码以统计我们的页面访问量。而今天，百度统计的代码被恶意内嵌了进行 DDoS 攻击的代码。目前暂时不知道这些代码是由百度嵌入的还是由政府要求嵌入的亦或者是黑客攻击百度嵌入的。但其实际造成了严重的影响，造成了严重的后果。</p>\n<p>HeckPsi 一向支持开源软件事业，开源软件对我们很重要。我们的服务中所使用的部分软件也是根据开放源代码许可提供的。HeckPsi 绝对不会有意去攻击 GitHub 这样的网站。但是事实上，我们无意中参与了这样的攻击，我们也必须要为如此愚蠢的行为负责。</p>\n<p>由于之前百度的种种恶迹，我们在选用第三方服务时已经尽量避开了百度的服务。在过去的几个月内，我们也逐渐将存放于百度云存储的、百度静态库CDN的一些服务出于安全原因进行了几次迁移，但忘记了网页统计使用的依然是百度的服务，没有进行及时的变更，才造成了今天的问题。</p>\n<p>目前，HeckPsi 已经停用了全部百度统计的代码，并强制更新了所有页面缓存。临时使用了 Google Analytics 对我们的网站进行统计。同时，我们会在接下来几周内深度检查网页中的各种代码，以避免使用百度的全部服务。同时，我们将在未来使用第三方服务的时候，严格考察第三方服务的可靠性。</p>\n<p>对此，给各位造成的影响，表示最大程度的道歉。</p>\n","excerpt":"<p>HeckPsi 对所有访问我们网站的用户道歉。</p>\n<p>在今天上午 HeckPsi 作为“帮凶”对 GitHub 的两个项目 greatfire 和 cn-nytimes 进行了 DDoS 攻击。</p>\n<p>对此，我们深表遗憾并且必须致以我们最为诚挚的道歉。</p>","more":"<p>造成这样的问题，是由于我们网页内嵌了 百度统计 的代码以统计我们的页面访问量。而今天，百度统计的代码被恶意内嵌了进行 DDoS 攻击的代码。目前暂时不知道这些代码是由百度嵌入的还是由政府要求嵌入的亦或者是黑客攻击百度嵌入的。但其实际造成了严重的影响，造成了严重的后果。</p>\n<p>HeckPsi 一向支持开源软件事业，开源软件对我们很重要。我们的服务中所使用的部分软件也是根据开放源代码许可提供的。HeckPsi 绝对不会有意去攻击 GitHub 这样的网站。但是事实上，我们无意中参与了这样的攻击，我们也必须要为如此愚蠢的行为负责。</p>\n<p>由于之前百度的种种恶迹，我们在选用第三方服务时已经尽量避开了百度的服务。在过去的几个月内，我们也逐渐将存放于百度云存储的、百度静态库CDN的一些服务出于安全原因进行了几次迁移，但忘记了网页统计使用的依然是百度的服务，没有进行及时的变更，才造成了今天的问题。</p>\n<p>目前，HeckPsi 已经停用了全部百度统计的代码，并强制更新了所有页面缓存。临时使用了 Google Analytics 对我们的网站进行统计。同时，我们会在接下来几周内深度检查网页中的各种代码，以避免使用百度的全部服务。同时，我们将在未来使用第三方服务的时候，严格考察第三方服务的可靠性。</p>\n<p>对此，给各位造成的影响，表示最大程度的道歉。</p>"},{"title":"选择困难？贝叶斯拯救你！","date":"2015-01-19T08:07:16.000Z","_content":"\n我们或多或少都有遇到过选择困难的情况。比如，今天晚上去哪吃？吃什么？怎么吃？（等等，为什么都是吃...）面对选择困难的时候如何做出选择是一个让很多人头疼和纠结的事情。\n\n如果我们对我们吃完之后对哪个比较满意提前就知道的话我们当然就不会有如此的纠结。所谓的纠结其实就是因为情报不完全而难以做出判断。如果把这个问题说得更宽泛一点，它就是一个决策的问题。在不完全情报下做出最优的策略？\n\n<!--more-->\n\n事实上有一样东西做起决策来比你还纠结，它就是计算机。如果不给定一个确定的计算方法，它可是做不出决策出来。这在计算机人工智能领域有一个非常常用的方法来帮助计算机来做出这样的决策，它就是“贝叶斯决策”。利用该方法来决定每天吃什么，即可以消除自己的纠结，也可以避免使用随机方法（比如抛硬币）这样比较愚蠢的方法。\n\n贝叶斯决策是基于18世纪著名的英国数学家提出的贝叶斯公式来的。但是我并不是一个喜欢说公式这样生涩难懂的东西的人，所以我们可以先聊聊别的。\n\n---\n\n我们来假设一种情况，我们来估计我明天有没有事要不要出门，为了简化模型，我们认为只有明天有事的情况下出门。于是我去看了一眼天气预报，明天的降水概率是30%，然后再去想了一下，其实上个月 30 天里，有 10 天下了雨，这 10 天里有 1 天有事，而剩下 20 天里有 5 天有事。\n\n画一个 10×10 的正方形，横轴 3：7 分开，分别代表明天的下雨还是不下雨。\n\n然后分开来看，左边下雨的部分，分成 10 分，取 1 分，因为下雨天有事的概率只有 1/10，右边分成 4 分取 1 分因为不下雨有事的概率是 1/4。于是下图中红色面积和黄色面积加起来就是明天会出门的概率啦。\n\n![](http://cdn.heckpsi.com/890_2.jpg)\n\n显然地红色加黄色的面积（出门）比蓝色加绿色的面积（不出门）要大啊！如果精确算一下的话，整个正方形的面积是10×10的话，红色加黄色的面积是 1×3+2.5×7=20.5，大约只有1/5的概率会出门。哈！果然死宅是不用出门的呢！（这么自暴自弃可好？）\n\n这是简单的贝叶斯公式的应用，但是实际情况比这个复杂得多，因为并不是什么情况都能在做一件事之前就清楚地知道每个部分的概率的。于是便有了贝叶斯决策的核心内容，也就是 先进行主观的概率估计（这个概率估计被称为先验概率），然后通过一些数据对这个估计进行修正（修正后的概率称之为后验概率），通过后验概率的大小来进行决策。\n\n所以我们回到一上来考虑的问题，今天晚上吃什么。\n\n为了简化模型，我们发现面前来到的地方只有“肯打鸡”和“铜钱豹”两家店在营业。一个想知道哪家更好吃的办法就是看看别人的意见，于是打开了大众点评，发现肯打鸡的评分是 4/5，铜钱豹的评分是 3.5/5。于是我们就不妨假设先验概率为 8：7。\n\n然后我发现，过去我在大众点评吃过的所有4星的餐厅里，大概有 70% 是满意的。而所有 3.5 星餐厅中，大概有 50% 是满意的。于是变成了下图。\n\n![](http://cdn.heckpsi.com/890_3.png)\n\n红色+黄色的面积成为了我选择肯打鸡的概率 60.67%，蓝色+绿色面积是我选择铜钱豹的概率，39.33%。\n\n然后更神奇的一幕出现，贝叶斯算法对于条件还可以嵌套使用。也就是说用更多条件来约束，从而求得更精确的后验概率。比如肯打鸡的人均消费是 50 元，而铜钱豹的人均消费是 200。我过去吃人均消费 50 左右的次数是吃 200 左右的 3 倍，然后再代入，再求出相应的当前我选择肯打鸡的概率和选择铜钱豹的概率。当你认为把各个条件都考虑差不多了，最终的后验概率也就出现了，哪个概率高，就去吃哪个咯~\n\n之所以贝叶斯决策能很好地终结选择困难是因为你终于将困扰你的所有因素的写了下来，并用数学的方法确定了他们对你决策的影响。每次考虑的时候都是两两考虑，尽可能地避免了其它因素的干扰。而且，根据现有经验的增长，可以对公式进行不断的修正，随着对这个公式的使用次数越来越多，得出结果的准确性也会越来越高。从而能得到一个基于现有经验的客观合理的选择，并且给了自己一个信服的理由，而不是抛硬币的一个草率的结果。\n\n对于贝叶斯公式的应用当然远不止如此，尤其是它是机器学习的重要手段。比如2002年时，[Paul Graham](http://www.paulgraham.com/spam.html) 提出的垃圾邮件过滤器（这是我们现在垃圾邮件过滤的主要方法之一），就是通过贝叶斯公式，学习一定样本量的垃圾邮件，然后判断下一封邮件是不是垃圾邮件，并且判断完垃圾邮件之后还可以通过这封新的垃圾邮件继续学习。该过滤器在当时可以过滤超过 99% 的垃圾邮件（当然魔高一尺道高一丈，现在垃圾邮件也通过干扰字符等手段不但破解这个系统，也促使了过滤器的进一步发展）。\n\n<div class=\"tip\">\n\n后记：其实很少说有关算法或者数学方面的内容，因为公式之类的东西实在是生涩难懂让人厌烦。所以我尽量在描述的时候用通俗的方法来描述概念，而不是列一个公式出来。虽便于理解，但有时也颇有不够严谨之处。不知道这样的文章大家是否可以看懂，是否觉得有意思，以及有哪些可以改进的地方。偶尔做一些这样的尝试，如有不妥之处也请各位指出，谢谢。\n\n</div>\n\n","source":"_posts/application-of-bayes-theorem.md","raw":"---\ntitle: 选择困难？贝叶斯拯救你！\ndate: 2015-01-19 16:07:16\ntags: [数学,统计,概率]\n---\n\n我们或多或少都有遇到过选择困难的情况。比如，今天晚上去哪吃？吃什么？怎么吃？（等等，为什么都是吃...）面对选择困难的时候如何做出选择是一个让很多人头疼和纠结的事情。\n\n如果我们对我们吃完之后对哪个比较满意提前就知道的话我们当然就不会有如此的纠结。所谓的纠结其实就是因为情报不完全而难以做出判断。如果把这个问题说得更宽泛一点，它就是一个决策的问题。在不完全情报下做出最优的策略？\n\n<!--more-->\n\n事实上有一样东西做起决策来比你还纠结，它就是计算机。如果不给定一个确定的计算方法，它可是做不出决策出来。这在计算机人工智能领域有一个非常常用的方法来帮助计算机来做出这样的决策，它就是“贝叶斯决策”。利用该方法来决定每天吃什么，即可以消除自己的纠结，也可以避免使用随机方法（比如抛硬币）这样比较愚蠢的方法。\n\n贝叶斯决策是基于18世纪著名的英国数学家提出的贝叶斯公式来的。但是我并不是一个喜欢说公式这样生涩难懂的东西的人，所以我们可以先聊聊别的。\n\n---\n\n我们来假设一种情况，我们来估计我明天有没有事要不要出门，为了简化模型，我们认为只有明天有事的情况下出门。于是我去看了一眼天气预报，明天的降水概率是30%，然后再去想了一下，其实上个月 30 天里，有 10 天下了雨，这 10 天里有 1 天有事，而剩下 20 天里有 5 天有事。\n\n画一个 10×10 的正方形，横轴 3：7 分开，分别代表明天的下雨还是不下雨。\n\n然后分开来看，左边下雨的部分，分成 10 分，取 1 分，因为下雨天有事的概率只有 1/10，右边分成 4 分取 1 分因为不下雨有事的概率是 1/4。于是下图中红色面积和黄色面积加起来就是明天会出门的概率啦。\n\n![](http://cdn.heckpsi.com/890_2.jpg)\n\n显然地红色加黄色的面积（出门）比蓝色加绿色的面积（不出门）要大啊！如果精确算一下的话，整个正方形的面积是10×10的话，红色加黄色的面积是 1×3+2.5×7=20.5，大约只有1/5的概率会出门。哈！果然死宅是不用出门的呢！（这么自暴自弃可好？）\n\n这是简单的贝叶斯公式的应用，但是实际情况比这个复杂得多，因为并不是什么情况都能在做一件事之前就清楚地知道每个部分的概率的。于是便有了贝叶斯决策的核心内容，也就是 先进行主观的概率估计（这个概率估计被称为先验概率），然后通过一些数据对这个估计进行修正（修正后的概率称之为后验概率），通过后验概率的大小来进行决策。\n\n所以我们回到一上来考虑的问题，今天晚上吃什么。\n\n为了简化模型，我们发现面前来到的地方只有“肯打鸡”和“铜钱豹”两家店在营业。一个想知道哪家更好吃的办法就是看看别人的意见，于是打开了大众点评，发现肯打鸡的评分是 4/5，铜钱豹的评分是 3.5/5。于是我们就不妨假设先验概率为 8：7。\n\n然后我发现，过去我在大众点评吃过的所有4星的餐厅里，大概有 70% 是满意的。而所有 3.5 星餐厅中，大概有 50% 是满意的。于是变成了下图。\n\n![](http://cdn.heckpsi.com/890_3.png)\n\n红色+黄色的面积成为了我选择肯打鸡的概率 60.67%，蓝色+绿色面积是我选择铜钱豹的概率，39.33%。\n\n然后更神奇的一幕出现，贝叶斯算法对于条件还可以嵌套使用。也就是说用更多条件来约束，从而求得更精确的后验概率。比如肯打鸡的人均消费是 50 元，而铜钱豹的人均消费是 200。我过去吃人均消费 50 左右的次数是吃 200 左右的 3 倍，然后再代入，再求出相应的当前我选择肯打鸡的概率和选择铜钱豹的概率。当你认为把各个条件都考虑差不多了，最终的后验概率也就出现了，哪个概率高，就去吃哪个咯~\n\n之所以贝叶斯决策能很好地终结选择困难是因为你终于将困扰你的所有因素的写了下来，并用数学的方法确定了他们对你决策的影响。每次考虑的时候都是两两考虑，尽可能地避免了其它因素的干扰。而且，根据现有经验的增长，可以对公式进行不断的修正，随着对这个公式的使用次数越来越多，得出结果的准确性也会越来越高。从而能得到一个基于现有经验的客观合理的选择，并且给了自己一个信服的理由，而不是抛硬币的一个草率的结果。\n\n对于贝叶斯公式的应用当然远不止如此，尤其是它是机器学习的重要手段。比如2002年时，[Paul Graham](http://www.paulgraham.com/spam.html) 提出的垃圾邮件过滤器（这是我们现在垃圾邮件过滤的主要方法之一），就是通过贝叶斯公式，学习一定样本量的垃圾邮件，然后判断下一封邮件是不是垃圾邮件，并且判断完垃圾邮件之后还可以通过这封新的垃圾邮件继续学习。该过滤器在当时可以过滤超过 99% 的垃圾邮件（当然魔高一尺道高一丈，现在垃圾邮件也通过干扰字符等手段不但破解这个系统，也促使了过滤器的进一步发展）。\n\n<div class=\"tip\">\n\n后记：其实很少说有关算法或者数学方面的内容，因为公式之类的东西实在是生涩难懂让人厌烦。所以我尽量在描述的时候用通俗的方法来描述概念，而不是列一个公式出来。虽便于理解，但有时也颇有不够严谨之处。不知道这样的文章大家是否可以看懂，是否觉得有意思，以及有哪些可以改进的地方。偶尔做一些这样的尝试，如有不妥之处也请各位指出，谢谢。\n\n</div>\n\n","slug":"application-of-bayes-theorem","published":1,"updated":"2016-05-15T03:20:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscy008g0006pp8zu3akkg03","content":"<p>我们或多或少都有遇到过选择困难的情况。比如，今天晚上去哪吃？吃什么？怎么吃？（等等，为什么都是吃…）面对选择困难的时候如何做出选择是一个让很多人头疼和纠结的事情。</p>\n<p>如果我们对我们吃完之后对哪个比较满意提前就知道的话我们当然就不会有如此的纠结。所谓的纠结其实就是因为情报不完全而难以做出判断。如果把这个问题说得更宽泛一点，它就是一个决策的问题。在不完全情报下做出最优的策略？</p>\n<a id=\"more\"></a>\n<p>事实上有一样东西做起决策来比你还纠结，它就是计算机。如果不给定一个确定的计算方法，它可是做不出决策出来。这在计算机人工智能领域有一个非常常用的方法来帮助计算机来做出这样的决策，它就是“贝叶斯决策”。利用该方法来决定每天吃什么，即可以消除自己的纠结，也可以避免使用随机方法（比如抛硬币）这样比较愚蠢的方法。</p>\n<p>贝叶斯决策是基于18世纪著名的英国数学家提出的贝叶斯公式来的。但是我并不是一个喜欢说公式这样生涩难懂的东西的人，所以我们可以先聊聊别的。</p>\n<hr>\n<p>我们来假设一种情况，我们来估计我明天有没有事要不要出门，为了简化模型，我们认为只有明天有事的情况下出门。于是我去看了一眼天气预报，明天的降水概率是30%，然后再去想了一下，其实上个月 30 天里，有 10 天下了雨，这 10 天里有 1 天有事，而剩下 20 天里有 5 天有事。</p>\n<p>画一个 10×10 的正方形，横轴 3：7 分开，分别代表明天的下雨还是不下雨。</p>\n<p>然后分开来看，左边下雨的部分，分成 10 分，取 1 分，因为下雨天有事的概率只有 1/10，右边分成 4 分取 1 分因为不下雨有事的概率是 1/4。于是下图中红色面积和黄色面积加起来就是明天会出门的概率啦。</p>\n<p><img src=\"http://cdn.heckpsi.com/890_2.jpg\" alt=\"\"></p>\n<p>显然地红色加黄色的面积（出门）比蓝色加绿色的面积（不出门）要大啊！如果精确算一下的话，整个正方形的面积是10×10的话，红色加黄色的面积是 1×3+2.5×7=20.5，大约只有1/5的概率会出门。哈！果然死宅是不用出门的呢！（这么自暴自弃可好？）</p>\n<p>这是简单的贝叶斯公式的应用，但是实际情况比这个复杂得多，因为并不是什么情况都能在做一件事之前就清楚地知道每个部分的概率的。于是便有了贝叶斯决策的核心内容，也就是 先进行主观的概率估计（这个概率估计被称为先验概率），然后通过一些数据对这个估计进行修正（修正后的概率称之为后验概率），通过后验概率的大小来进行决策。</p>\n<p>所以我们回到一上来考虑的问题，今天晚上吃什么。</p>\n<p>为了简化模型，我们发现面前来到的地方只有“肯打鸡”和“铜钱豹”两家店在营业。一个想知道哪家更好吃的办法就是看看别人的意见，于是打开了大众点评，发现肯打鸡的评分是 4/5，铜钱豹的评分是 3.5/5。于是我们就不妨假设先验概率为 8：7。</p>\n<p>然后我发现，过去我在大众点评吃过的所有4星的餐厅里，大概有 70% 是满意的。而所有 3.5 星餐厅中，大概有 50% 是满意的。于是变成了下图。</p>\n<p><img src=\"http://cdn.heckpsi.com/890_3.png\" alt=\"\"></p>\n<p>红色+黄色的面积成为了我选择肯打鸡的概率 60.67%，蓝色+绿色面积是我选择铜钱豹的概率，39.33%。</p>\n<p>然后更神奇的一幕出现，贝叶斯算法对于条件还可以嵌套使用。也就是说用更多条件来约束，从而求得更精确的后验概率。比如肯打鸡的人均消费是 50 元，而铜钱豹的人均消费是 200。我过去吃人均消费 50 左右的次数是吃 200 左右的 3 倍，然后再代入，再求出相应的当前我选择肯打鸡的概率和选择铜钱豹的概率。当你认为把各个条件都考虑差不多了，最终的后验概率也就出现了，哪个概率高，就去吃哪个咯~</p>\n<p>之所以贝叶斯决策能很好地终结选择困难是因为你终于将困扰你的所有因素的写了下来，并用数学的方法确定了他们对你决策的影响。每次考虑的时候都是两两考虑，尽可能地避免了其它因素的干扰。而且，根据现有经验的增长，可以对公式进行不断的修正，随着对这个公式的使用次数越来越多，得出结果的准确性也会越来越高。从而能得到一个基于现有经验的客观合理的选择，并且给了自己一个信服的理由，而不是抛硬币的一个草率的结果。</p>\n<p>对于贝叶斯公式的应用当然远不止如此，尤其是它是机器学习的重要手段。比如2002年时，<a href=\"http://www.paulgraham.com/spam.html\" target=\"_blank\" rel=\"external\">Paul Graham</a> 提出的垃圾邮件过滤器（这是我们现在垃圾邮件过滤的主要方法之一），就是通过贝叶斯公式，学习一定样本量的垃圾邮件，然后判断下一封邮件是不是垃圾邮件，并且判断完垃圾邮件之后还可以通过这封新的垃圾邮件继续学习。该过滤器在当时可以过滤超过 99% 的垃圾邮件（当然魔高一尺道高一丈，现在垃圾邮件也通过干扰字符等手段不但破解这个系统，也促使了过滤器的进一步发展）。</p>\n<div class=\"tip\"><br><br>后记：其实很少说有关算法或者数学方面的内容，因为公式之类的东西实在是生涩难懂让人厌烦。所以我尽量在描述的时候用通俗的方法来描述概念，而不是列一个公式出来。虽便于理解，但有时也颇有不够严谨之处。不知道这样的文章大家是否可以看懂，是否觉得有意思，以及有哪些可以改进的地方。偶尔做一些这样的尝试，如有不妥之处也请各位指出，谢谢。<br><br></div>\n\n","excerpt":"<p>我们或多或少都有遇到过选择困难的情况。比如，今天晚上去哪吃？吃什么？怎么吃？（等等，为什么都是吃…）面对选择困难的时候如何做出选择是一个让很多人头疼和纠结的事情。</p>\n<p>如果我们对我们吃完之后对哪个比较满意提前就知道的话我们当然就不会有如此的纠结。所谓的纠结其实就是因为情报不完全而难以做出判断。如果把这个问题说得更宽泛一点，它就是一个决策的问题。在不完全情报下做出最优的策略？</p>","more":"<p>事实上有一样东西做起决策来比你还纠结，它就是计算机。如果不给定一个确定的计算方法，它可是做不出决策出来。这在计算机人工智能领域有一个非常常用的方法来帮助计算机来做出这样的决策，它就是“贝叶斯决策”。利用该方法来决定每天吃什么，即可以消除自己的纠结，也可以避免使用随机方法（比如抛硬币）这样比较愚蠢的方法。</p>\n<p>贝叶斯决策是基于18世纪著名的英国数学家提出的贝叶斯公式来的。但是我并不是一个喜欢说公式这样生涩难懂的东西的人，所以我们可以先聊聊别的。</p>\n<hr>\n<p>我们来假设一种情况，我们来估计我明天有没有事要不要出门，为了简化模型，我们认为只有明天有事的情况下出门。于是我去看了一眼天气预报，明天的降水概率是30%，然后再去想了一下，其实上个月 30 天里，有 10 天下了雨，这 10 天里有 1 天有事，而剩下 20 天里有 5 天有事。</p>\n<p>画一个 10×10 的正方形，横轴 3：7 分开，分别代表明天的下雨还是不下雨。</p>\n<p>然后分开来看，左边下雨的部分，分成 10 分，取 1 分，因为下雨天有事的概率只有 1/10，右边分成 4 分取 1 分因为不下雨有事的概率是 1/4。于是下图中红色面积和黄色面积加起来就是明天会出门的概率啦。</p>\n<p><img src=\"http://cdn.heckpsi.com/890_2.jpg\" alt=\"\"></p>\n<p>显然地红色加黄色的面积（出门）比蓝色加绿色的面积（不出门）要大啊！如果精确算一下的话，整个正方形的面积是10×10的话，红色加黄色的面积是 1×3+2.5×7=20.5，大约只有1/5的概率会出门。哈！果然死宅是不用出门的呢！（这么自暴自弃可好？）</p>\n<p>这是简单的贝叶斯公式的应用，但是实际情况比这个复杂得多，因为并不是什么情况都能在做一件事之前就清楚地知道每个部分的概率的。于是便有了贝叶斯决策的核心内容，也就是 先进行主观的概率估计（这个概率估计被称为先验概率），然后通过一些数据对这个估计进行修正（修正后的概率称之为后验概率），通过后验概率的大小来进行决策。</p>\n<p>所以我们回到一上来考虑的问题，今天晚上吃什么。</p>\n<p>为了简化模型，我们发现面前来到的地方只有“肯打鸡”和“铜钱豹”两家店在营业。一个想知道哪家更好吃的办法就是看看别人的意见，于是打开了大众点评，发现肯打鸡的评分是 4/5，铜钱豹的评分是 3.5/5。于是我们就不妨假设先验概率为 8：7。</p>\n<p>然后我发现，过去我在大众点评吃过的所有4星的餐厅里，大概有 70% 是满意的。而所有 3.5 星餐厅中，大概有 50% 是满意的。于是变成了下图。</p>\n<p><img src=\"http://cdn.heckpsi.com/890_3.png\" alt=\"\"></p>\n<p>红色+黄色的面积成为了我选择肯打鸡的概率 60.67%，蓝色+绿色面积是我选择铜钱豹的概率，39.33%。</p>\n<p>然后更神奇的一幕出现，贝叶斯算法对于条件还可以嵌套使用。也就是说用更多条件来约束，从而求得更精确的后验概率。比如肯打鸡的人均消费是 50 元，而铜钱豹的人均消费是 200。我过去吃人均消费 50 左右的次数是吃 200 左右的 3 倍，然后再代入，再求出相应的当前我选择肯打鸡的概率和选择铜钱豹的概率。当你认为把各个条件都考虑差不多了，最终的后验概率也就出现了，哪个概率高，就去吃哪个咯~</p>\n<p>之所以贝叶斯决策能很好地终结选择困难是因为你终于将困扰你的所有因素的写了下来，并用数学的方法确定了他们对你决策的影响。每次考虑的时候都是两两考虑，尽可能地避免了其它因素的干扰。而且，根据现有经验的增长，可以对公式进行不断的修正，随着对这个公式的使用次数越来越多，得出结果的准确性也会越来越高。从而能得到一个基于现有经验的客观合理的选择，并且给了自己一个信服的理由，而不是抛硬币的一个草率的结果。</p>\n<p>对于贝叶斯公式的应用当然远不止如此，尤其是它是机器学习的重要手段。比如2002年时，<a href=\"http://www.paulgraham.com/spam.html\">Paul Graham</a> 提出的垃圾邮件过滤器（这是我们现在垃圾邮件过滤的主要方法之一），就是通过贝叶斯公式，学习一定样本量的垃圾邮件，然后判断下一封邮件是不是垃圾邮件，并且判断完垃圾邮件之后还可以通过这封新的垃圾邮件继续学习。该过滤器在当时可以过滤超过 99% 的垃圾邮件（当然魔高一尺道高一丈，现在垃圾邮件也通过干扰字符等手段不但破解这个系统，也促使了过滤器的进一步发展）。</p>\n<div class=\"tip\"><br><br>后记：其实很少说有关算法或者数学方面的内容，因为公式之类的东西实在是生涩难懂让人厌烦。所以我尽量在描述的时候用通俗的方法来描述概念，而不是列一个公式出来。虽便于理解，但有时也颇有不够严谨之处。不知道这样的文章大家是否可以看懂，是否觉得有意思，以及有哪些可以改进的地方。偶尔做一些这样的尝试，如有不妥之处也请各位指出，谢谢。<br><br></div>"},{"title":"我们是否存在一个数据量越大，处理起来反而越快的程序？","date":"2014-10-19T04:14:47.000Z","_content":"\n~~试图想这个问题的我一定是没有吃药。~~\n\n首先，这个问题的存在是非常违背常识的。因为我们总会觉得数据量越大处理起来一定会越费劲，那么耗时一定会更长。但是讨论这个问题并不是毫无意义的。这个问题和 P=NP 问题一样，看起来非常的离谱，但是却也是细思极恐的问题。因为你很难想到使用哪个数学工具来证明这个问题的不可能性。而这个问题更离谱一点的问题在于，我们似乎能用数学方法证明一个数据量越大，处理起来反而越快的程序是存在的。\n\n<!--more-->\n\n要像证明这个问题我们应该从算法分析的基本工具 [大 O 符号](http://zh.wikipedia.org/wiki/%E5%A4%A7O%E7%AC%A6%E5%8F%B7) 出发。一个最简单的例子是是否存在一个 O(1/n) 的算法，使得当数据足够大时，运算的时间渐进于 1/n，如果存在这种情况，显然地，存在一个数据量越大，处理起来反而越快的程序。当我们用大 O 符号的定义进行证明的时候我们完全找不到任何有问题的地方，可以很容易地发现 O(1/n) 是满足大O符号的一切定义的。那么 O(1/n) 真的是存在的吗？\n\n虽然数学上看起来存在一个满足的程序。那么谁能写出这样的程序呢？似乎现实生活中从未见过这样的程序。但是，今天在翻阅 StackOverFlow 的时候，我似乎见到了 [这样的程序](http://stackoverflow.com/questions/905551/are-there-any-o1-n-algorithms)。\n\n```python\ndef get_faster(list):\n  how_long = (1 / len(list)) * 100000\n  sleep(how_long)\n```\n\n这个程序是这样的，简单来说，就是读取一串数据后，使机器暂停输入数据量的倒数时间。这个程序看起来是完全满足 O(1/n) 的，因为数据越多，运行越快。但，这个程序真的是 O(1/n) 吗？完全不是，这程序是一个 O(1)。因为当数据量足够大时，决定程序运行速度的将不再是机器暂停的时间，而是你计算数据量倒数的时间，而这个时间和输入的数据量无关，由于1，也就是 n^0 比 1/n，也就是 n^-1 高一阶，这个程序实际上是 O(1) 而不是 O(1/n) 的。\n\n然后从这个程序出发我们再来考虑一下，O(1/n) 不存在的根本原因。其实根本原因出在图灵机或者冯诺依曼机上。当输入的数据量足够大的时候，O(1/n) 的运算时间会无限趋近于0。而实际上无论是图灵机还是冯诺依曼机，所有的硬件操作都存在一个最小的单位时间。这使得无论如何，程序的运行时间至少是一个最小的单位时间的，而这个时间迫使你算法的效率最小不可能小于 O(1)。\n\n于是，我们知道了，在数学上也许是存在一个 O(1/n) 的，但是在图灵机、冯诺依曼机以及在此基础上发展的所有现代计算机都是不可能存在一个 O(1/n)。\n\n那么回到我们开头的问题，存在一个数据量越大，处理起来反而越快的程序吗？事实上是存在的，上述例子程序就是一个这样的程序。但是当数据足够大时，运行时间不会无限下降，而是趋向于一个常数时间，无论这个时间有多小。\n\n","source":"_posts/can-a-program-runs-faster-when-data-goes-larger.md","raw":"---\ntitle: 我们是否存在一个数据量越大，处理起来反而越快的程序？\ndate: 2014-10-19 12:14:47\ntags: [算法,数学]\n---\n\n~~试图想这个问题的我一定是没有吃药。~~\n\n首先，这个问题的存在是非常违背常识的。因为我们总会觉得数据量越大处理起来一定会越费劲，那么耗时一定会更长。但是讨论这个问题并不是毫无意义的。这个问题和 P=NP 问题一样，看起来非常的离谱，但是却也是细思极恐的问题。因为你很难想到使用哪个数学工具来证明这个问题的不可能性。而这个问题更离谱一点的问题在于，我们似乎能用数学方法证明一个数据量越大，处理起来反而越快的程序是存在的。\n\n<!--more-->\n\n要像证明这个问题我们应该从算法分析的基本工具 [大 O 符号](http://zh.wikipedia.org/wiki/%E5%A4%A7O%E7%AC%A6%E5%8F%B7) 出发。一个最简单的例子是是否存在一个 O(1/n) 的算法，使得当数据足够大时，运算的时间渐进于 1/n，如果存在这种情况，显然地，存在一个数据量越大，处理起来反而越快的程序。当我们用大 O 符号的定义进行证明的时候我们完全找不到任何有问题的地方，可以很容易地发现 O(1/n) 是满足大O符号的一切定义的。那么 O(1/n) 真的是存在的吗？\n\n虽然数学上看起来存在一个满足的程序。那么谁能写出这样的程序呢？似乎现实生活中从未见过这样的程序。但是，今天在翻阅 StackOverFlow 的时候，我似乎见到了 [这样的程序](http://stackoverflow.com/questions/905551/are-there-any-o1-n-algorithms)。\n\n```python\ndef get_faster(list):\n  how_long = (1 / len(list)) * 100000\n  sleep(how_long)\n```\n\n这个程序是这样的，简单来说，就是读取一串数据后，使机器暂停输入数据量的倒数时间。这个程序看起来是完全满足 O(1/n) 的，因为数据越多，运行越快。但，这个程序真的是 O(1/n) 吗？完全不是，这程序是一个 O(1)。因为当数据量足够大时，决定程序运行速度的将不再是机器暂停的时间，而是你计算数据量倒数的时间，而这个时间和输入的数据量无关，由于1，也就是 n^0 比 1/n，也就是 n^-1 高一阶，这个程序实际上是 O(1) 而不是 O(1/n) 的。\n\n然后从这个程序出发我们再来考虑一下，O(1/n) 不存在的根本原因。其实根本原因出在图灵机或者冯诺依曼机上。当输入的数据量足够大的时候，O(1/n) 的运算时间会无限趋近于0。而实际上无论是图灵机还是冯诺依曼机，所有的硬件操作都存在一个最小的单位时间。这使得无论如何，程序的运行时间至少是一个最小的单位时间的，而这个时间迫使你算法的效率最小不可能小于 O(1)。\n\n于是，我们知道了，在数学上也许是存在一个 O(1/n) 的，但是在图灵机、冯诺依曼机以及在此基础上发展的所有现代计算机都是不可能存在一个 O(1/n)。\n\n那么回到我们开头的问题，存在一个数据量越大，处理起来反而越快的程序吗？事实上是存在的，上述例子程序就是一个这样的程序。但是当数据足够大时，运行时间不会无限下降，而是趋向于一个常数时间，无论这个时间有多小。\n\n","slug":"can-a-program-runs-faster-when-data-goes-larger","published":1,"updated":"2016-04-23T12:52:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscy008i0007pp8zqonwrzin","content":"<p><del>试图想这个问题的我一定是没有吃药。</del></p>\n<p>首先，这个问题的存在是非常违背常识的。因为我们总会觉得数据量越大处理起来一定会越费劲，那么耗时一定会更长。但是讨论这个问题并不是毫无意义的。这个问题和 P=NP 问题一样，看起来非常的离谱，但是却也是细思极恐的问题。因为你很难想到使用哪个数学工具来证明这个问题的不可能性。而这个问题更离谱一点的问题在于，我们似乎能用数学方法证明一个数据量越大，处理起来反而越快的程序是存在的。</p>\n<a id=\"more\"></a>\n<p>要像证明这个问题我们应该从算法分析的基本工具 <a href=\"http://zh.wikipedia.org/wiki/%E5%A4%A7O%E7%AC%A6%E5%8F%B7\" target=\"_blank\" rel=\"external\">大 O 符号</a> 出发。一个最简单的例子是是否存在一个 O(1/n) 的算法，使得当数据足够大时，运算的时间渐进于 1/n，如果存在这种情况，显然地，存在一个数据量越大，处理起来反而越快的程序。当我们用大 O 符号的定义进行证明的时候我们完全找不到任何有问题的地方，可以很容易地发现 O(1/n) 是满足大O符号的一切定义的。那么 O(1/n) 真的是存在的吗？</p>\n<p>虽然数学上看起来存在一个满足的程序。那么谁能写出这样的程序呢？似乎现实生活中从未见过这样的程序。但是，今天在翻阅 StackOverFlow 的时候，我似乎见到了 <a href=\"http://stackoverflow.com/questions/905551/are-there-any-o1-n-algorithms\" target=\"_blank\" rel=\"external\">这样的程序</a>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_faster</span><span class=\"params\">(list)</span>:</span></span><br><span class=\"line\">  how_long = (<span class=\"number\">1</span> / len(list)) * <span class=\"number\">100000</span></span><br><span class=\"line\">  sleep(how_long)</span><br></pre></td></tr></table></figure>\n<p>这个程序是这样的，简单来说，就是读取一串数据后，使机器暂停输入数据量的倒数时间。这个程序看起来是完全满足 O(1/n) 的，因为数据越多，运行越快。但，这个程序真的是 O(1/n) 吗？完全不是，这程序是一个 O(1)。因为当数据量足够大时，决定程序运行速度的将不再是机器暂停的时间，而是你计算数据量倒数的时间，而这个时间和输入的数据量无关，由于1，也就是 n^0 比 1/n，也就是 n^-1 高一阶，这个程序实际上是 O(1) 而不是 O(1/n) 的。</p>\n<p>然后从这个程序出发我们再来考虑一下，O(1/n) 不存在的根本原因。其实根本原因出在图灵机或者冯诺依曼机上。当输入的数据量足够大的时候，O(1/n) 的运算时间会无限趋近于0。而实际上无论是图灵机还是冯诺依曼机，所有的硬件操作都存在一个最小的单位时间。这使得无论如何，程序的运行时间至少是一个最小的单位时间的，而这个时间迫使你算法的效率最小不可能小于 O(1)。</p>\n<p>于是，我们知道了，在数学上也许是存在一个 O(1/n) 的，但是在图灵机、冯诺依曼机以及在此基础上发展的所有现代计算机都是不可能存在一个 O(1/n)。</p>\n<p>那么回到我们开头的问题，存在一个数据量越大，处理起来反而越快的程序吗？事实上是存在的，上述例子程序就是一个这样的程序。但是当数据足够大时，运行时间不会无限下降，而是趋向于一个常数时间，无论这个时间有多小。</p>\n","excerpt":"<p><del>试图想这个问题的我一定是没有吃药。</del></p>\n<p>首先，这个问题的存在是非常违背常识的。因为我们总会觉得数据量越大处理起来一定会越费劲，那么耗时一定会更长。但是讨论这个问题并不是毫无意义的。这个问题和 P=NP 问题一样，看起来非常的离谱，但是却也是细思极恐的问题。因为你很难想到使用哪个数学工具来证明这个问题的不可能性。而这个问题更离谱一点的问题在于，我们似乎能用数学方法证明一个数据量越大，处理起来反而越快的程序是存在的。</p>","more":"<p>要像证明这个问题我们应该从算法分析的基本工具 <a href=\"http://zh.wikipedia.org/wiki/%E5%A4%A7O%E7%AC%A6%E5%8F%B7\">大 O 符号</a> 出发。一个最简单的例子是是否存在一个 O(1/n) 的算法，使得当数据足够大时，运算的时间渐进于 1/n，如果存在这种情况，显然地，存在一个数据量越大，处理起来反而越快的程序。当我们用大 O 符号的定义进行证明的时候我们完全找不到任何有问题的地方，可以很容易地发现 O(1/n) 是满足大O符号的一切定义的。那么 O(1/n) 真的是存在的吗？</p>\n<p>虽然数学上看起来存在一个满足的程序。那么谁能写出这样的程序呢？似乎现实生活中从未见过这样的程序。但是，今天在翻阅 StackOverFlow 的时候，我似乎见到了 <a href=\"http://stackoverflow.com/questions/905551/are-there-any-o1-n-algorithms\">这样的程序</a>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_faster</span><span class=\"params\">(list)</span>:</span></span><br><span class=\"line\">  how_long = (<span class=\"number\">1</span> / len(list)) * <span class=\"number\">100000</span></span><br><span class=\"line\">  sleep(how_long)</span><br></pre></td></tr></table></figure>\n<p>这个程序是这样的，简单来说，就是读取一串数据后，使机器暂停输入数据量的倒数时间。这个程序看起来是完全满足 O(1/n) 的，因为数据越多，运行越快。但，这个程序真的是 O(1/n) 吗？完全不是，这程序是一个 O(1)。因为当数据量足够大时，决定程序运行速度的将不再是机器暂停的时间，而是你计算数据量倒数的时间，而这个时间和输入的数据量无关，由于1，也就是 n^0 比 1/n，也就是 n^-1 高一阶，这个程序实际上是 O(1) 而不是 O(1/n) 的。</p>\n<p>然后从这个程序出发我们再来考虑一下，O(1/n) 不存在的根本原因。其实根本原因出在图灵机或者冯诺依曼机上。当输入的数据量足够大的时候，O(1/n) 的运算时间会无限趋近于0。而实际上无论是图灵机还是冯诺依曼机，所有的硬件操作都存在一个最小的单位时间。这使得无论如何，程序的运行时间至少是一个最小的单位时间的，而这个时间迫使你算法的效率最小不可能小于 O(1)。</p>\n<p>于是，我们知道了，在数学上也许是存在一个 O(1/n) 的，但是在图灵机、冯诺依曼机以及在此基础上发展的所有现代计算机都是不可能存在一个 O(1/n)。</p>\n<p>那么回到我们开头的问题，存在一个数据量越大，处理起来反而越快的程序吗？事实上是存在的，上述例子程序就是一个这样的程序。但是当数据足够大时，运行时间不会无限下降，而是趋向于一个常数时间，无论这个时间有多小。</p>"},{"title":"一款祖传的机械键盘","date":"2016-05-14T08:31:15.000Z","_content":"\n## 引\n\n去年的时候就打算购买一款 60% 键盘以方便日常携带。时值开源哥在搞团购 Vim 布局的机械键盘的订购，就订了一把，结果由于一些原因，这单子被取消了。于是我就购买了一把 HHKB pro 2 静电容键盘。虽然说 HHKB 的键位设置和跳线的设计携带起来非常好，但是缺乏段落感的按键还是让人没有那种敲打起来的爽快感。于是我就打算客制化一把机械键盘来满足这个要求。\n\n<!--more-->\n\n## 硬件\n\n如果要说 60% 的客制化套件的话，主要还是以 GH60 以及其延伸的一系列板子为主。开源哥之前推荐我使用 NerD60 的板子，可惜这块板子在国内并不容易买到。\n\n轴体的选择使用了相对非常激进的 Cherry 绿轴，比起青轴，同样拥有二段式设计的绿轴的压力克数更高（clerk 声也更响），敲击感非常强，反馈非常明确，当然，对于害怕吵到其他人的话，这轴显然不是一个好选择。\n\n键帽使用了三种颜色搭配的 PBT 无刻键帽，主要是因为现成的刻字键帽来说，显然是无法印刷修改非常严重的自定义按键的，而定制刻字的 PBT 键帽成本又太高，索性也就选择了无刻。\n\n虽然阳极氧化铝的底座轻便又质感十足，通常是首选。不过既然作为一款码农世家祖传的键盘，最终选择了相对来说观感上更有冲击力的红花梨木底座。其余配置见下表：\n\n| 类别   | 选料               |\n| ---- | ---------------- |\n| 主板   | GH60 (Rev.CHN)   |\n| 轴体   | Cherry 绿轴        |\n| 键帽   | PBT 无刻（红色、灰色、白色） |\n| LED  | 白色               |\n| 定位板  | 黑色阳极氧化铝上色        |\n| 底座   | 红花梨木             |\n| USB  | LINDY Mini-USB   |\n\n由于我这个烙铁苦手，就上淘宝找了一家常州的 [厂家](https://yikewaishe.taobao.com/shop/view_shop.htm?user_number_id=134583372)（并没有广告关系，也没有肮脏的交易），对方当天就组装完发货，第二天一大早竟然就送到了。于是拿到手后就进入了修改固件，修改键位的过程了。\n\n到手的货物长这样：\n\n![](http://cdn.heckpsi.com/keyboard-2.jpg)\n\n![](http://cdn.heckpsi.com/keyboard-1.jpg)\n\n## 固件\n\n客制化键盘的一大好处就是客制化的按键配列，这一点在 60% 和 40% 的键盘上非常重要。我结合我之前 HHKB 的使用经验，我就大致设计了一个如下的配列：\n\n![](http://cdn.heckpsi.com/keyboard_5.png)\n\n（其中左前方的按键为 Fn 组合键，右前方的是 Fn1 组合键）\n\n然而客制化固件的刷入还有一些问题。首先这板子是 Rev.CHN 的，一上来刷入就失败了好几次。直到看到了大鹰的 [这篇文章](https://bigeagle.me/2015/07/gh60/)（没想到大鹰去年也参了开源哥的团，后来也从同一个卖家手里组装了键盘）。\n\n当然这之前我找到了一个简便的选择 [TKG Keypad Generator](http://www.enjoyclick.org/tkg/#help)，它能自动生成 avr 单片机的 eep 文件，理论上可以直接刷入。但是我刷入之后无法正常引导键盘，所以还是需要使用 [tmk-keyboard-custom](https://github.com/kairyu/tmk_keyboard_custom) 自己编译刷入（`git clone` 的时候切记加入 `recursive` 参数，因为核心模块以 `submodule` 的形式出现在这个 `repository` 中）。不过还是可以使用 TKG Keypad Generator 所生成的 c 语言代码，稍作修改进行编译即可。\n\n首先把生成的文件命名成 `keypad_xxx.c` 文件，`xxx` 为你配列自己的命名。不过直接刷入似乎会遇到一些编译问题，需要在文件后加入如下代码：\n\n```c\n#ifdef KEYMAP_IN_EEPROM_ENABLE\nuint16_t keys_count(void) {\n    return sizeof(keymaps) / sizeof(keymaps[0]) * MATRIX_ROWS * MATRIX_COLS;\n}\n\nuint16_t fn_actions_count(void) {\n    return sizeof(fn_actions) / sizeof(fn_actions[0]);\n}\n#endif\n```\n\n然后按下键盘背后的 dfu 按钮，使用命令行指令刷入\n\n```bash\nmake KEYPAD=xxx\nmake KEYPAD=xxx dfu\n```\n\n刷入后拔掉 USB 线，按住 BackSpace + Space，插入线缆，3 秒后放掉按键刷新 EEPROM 后，新配列即可工作。\n\n然后我发现我设计的三个多媒体用途的键中，只有暂停键是可用的，上一首和下一首都不能正常工作，仔细研究后才发现 Mac 机器的上一首和下一首的 KeyCode 和 PC 略有区别，修改后重新编译了固件，按键都能正常工作了。\n\n## 后\n\n当然这块键盘有哪些不满意的地方呢，还是有的。一个问题是右上角的大按键如果拆成两个小按键，对于 `BackSpace` 和 `\\` 的设计会变得方便更多，这个实在定位板的选择上出了一些问题。\n\n另一个就是白色的 LED 灯，哪怕是最低亮度也能轻易地透过白色的按键却无法透过别的按键，这使得这个灯的开启变成了一个比较尴尬的问题。","source":"_posts/customized-machanical-keyboard.md","raw":"---\ntitle: 一款祖传的机械键盘\ndate: 2016-05-14 16:31:15\ntags: [键盘]\n---\n\n## 引\n\n去年的时候就打算购买一款 60% 键盘以方便日常携带。时值开源哥在搞团购 Vim 布局的机械键盘的订购，就订了一把，结果由于一些原因，这单子被取消了。于是我就购买了一把 HHKB pro 2 静电容键盘。虽然说 HHKB 的键位设置和跳线的设计携带起来非常好，但是缺乏段落感的按键还是让人没有那种敲打起来的爽快感。于是我就打算客制化一把机械键盘来满足这个要求。\n\n<!--more-->\n\n## 硬件\n\n如果要说 60% 的客制化套件的话，主要还是以 GH60 以及其延伸的一系列板子为主。开源哥之前推荐我使用 NerD60 的板子，可惜这块板子在国内并不容易买到。\n\n轴体的选择使用了相对非常激进的 Cherry 绿轴，比起青轴，同样拥有二段式设计的绿轴的压力克数更高（clerk 声也更响），敲击感非常强，反馈非常明确，当然，对于害怕吵到其他人的话，这轴显然不是一个好选择。\n\n键帽使用了三种颜色搭配的 PBT 无刻键帽，主要是因为现成的刻字键帽来说，显然是无法印刷修改非常严重的自定义按键的，而定制刻字的 PBT 键帽成本又太高，索性也就选择了无刻。\n\n虽然阳极氧化铝的底座轻便又质感十足，通常是首选。不过既然作为一款码农世家祖传的键盘，最终选择了相对来说观感上更有冲击力的红花梨木底座。其余配置见下表：\n\n| 类别   | 选料               |\n| ---- | ---------------- |\n| 主板   | GH60 (Rev.CHN)   |\n| 轴体   | Cherry 绿轴        |\n| 键帽   | PBT 无刻（红色、灰色、白色） |\n| LED  | 白色               |\n| 定位板  | 黑色阳极氧化铝上色        |\n| 底座   | 红花梨木             |\n| USB  | LINDY Mini-USB   |\n\n由于我这个烙铁苦手，就上淘宝找了一家常州的 [厂家](https://yikewaishe.taobao.com/shop/view_shop.htm?user_number_id=134583372)（并没有广告关系，也没有肮脏的交易），对方当天就组装完发货，第二天一大早竟然就送到了。于是拿到手后就进入了修改固件，修改键位的过程了。\n\n到手的货物长这样：\n\n![](http://cdn.heckpsi.com/keyboard-2.jpg)\n\n![](http://cdn.heckpsi.com/keyboard-1.jpg)\n\n## 固件\n\n客制化键盘的一大好处就是客制化的按键配列，这一点在 60% 和 40% 的键盘上非常重要。我结合我之前 HHKB 的使用经验，我就大致设计了一个如下的配列：\n\n![](http://cdn.heckpsi.com/keyboard_5.png)\n\n（其中左前方的按键为 Fn 组合键，右前方的是 Fn1 组合键）\n\n然而客制化固件的刷入还有一些问题。首先这板子是 Rev.CHN 的，一上来刷入就失败了好几次。直到看到了大鹰的 [这篇文章](https://bigeagle.me/2015/07/gh60/)（没想到大鹰去年也参了开源哥的团，后来也从同一个卖家手里组装了键盘）。\n\n当然这之前我找到了一个简便的选择 [TKG Keypad Generator](http://www.enjoyclick.org/tkg/#help)，它能自动生成 avr 单片机的 eep 文件，理论上可以直接刷入。但是我刷入之后无法正常引导键盘，所以还是需要使用 [tmk-keyboard-custom](https://github.com/kairyu/tmk_keyboard_custom) 自己编译刷入（`git clone` 的时候切记加入 `recursive` 参数，因为核心模块以 `submodule` 的形式出现在这个 `repository` 中）。不过还是可以使用 TKG Keypad Generator 所生成的 c 语言代码，稍作修改进行编译即可。\n\n首先把生成的文件命名成 `keypad_xxx.c` 文件，`xxx` 为你配列自己的命名。不过直接刷入似乎会遇到一些编译问题，需要在文件后加入如下代码：\n\n```c\n#ifdef KEYMAP_IN_EEPROM_ENABLE\nuint16_t keys_count(void) {\n    return sizeof(keymaps) / sizeof(keymaps[0]) * MATRIX_ROWS * MATRIX_COLS;\n}\n\nuint16_t fn_actions_count(void) {\n    return sizeof(fn_actions) / sizeof(fn_actions[0]);\n}\n#endif\n```\n\n然后按下键盘背后的 dfu 按钮，使用命令行指令刷入\n\n```bash\nmake KEYPAD=xxx\nmake KEYPAD=xxx dfu\n```\n\n刷入后拔掉 USB 线，按住 BackSpace + Space，插入线缆，3 秒后放掉按键刷新 EEPROM 后，新配列即可工作。\n\n然后我发现我设计的三个多媒体用途的键中，只有暂停键是可用的，上一首和下一首都不能正常工作，仔细研究后才发现 Mac 机器的上一首和下一首的 KeyCode 和 PC 略有区别，修改后重新编译了固件，按键都能正常工作了。\n\n## 后\n\n当然这块键盘有哪些不满意的地方呢，还是有的。一个问题是右上角的大按键如果拆成两个小按键，对于 `BackSpace` 和 `\\` 的设计会变得方便更多，这个实在定位板的选择上出了一些问题。\n\n另一个就是白色的 LED 灯，哪怕是最低亮度也能轻易地透过白色的按键却无法透过别的按键，这使得这个灯的开启变成了一个比较尴尬的问题。","slug":"customized-machanical-keyboard","published":1,"updated":"2016-05-15T03:20:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscy008l0008pp8zb70fc1kd","content":"<h2 id=\"引\"><a href=\"#引\" class=\"headerlink\" title=\"引\"></a>引</h2><p>去年的时候就打算购买一款 60% 键盘以方便日常携带。时值开源哥在搞团购 Vim 布局的机械键盘的订购，就订了一把，结果由于一些原因，这单子被取消了。于是我就购买了一把 HHKB pro 2 静电容键盘。虽然说 HHKB 的键位设置和跳线的设计携带起来非常好，但是缺乏段落感的按键还是让人没有那种敲打起来的爽快感。于是我就打算客制化一把机械键盘来满足这个要求。</p>\n<a id=\"more\"></a>\n<h2 id=\"硬件\"><a href=\"#硬件\" class=\"headerlink\" title=\"硬件\"></a>硬件</h2><p>如果要说 60% 的客制化套件的话，主要还是以 GH60 以及其延伸的一系列板子为主。开源哥之前推荐我使用 NerD60 的板子，可惜这块板子在国内并不容易买到。</p>\n<p>轴体的选择使用了相对非常激进的 Cherry 绿轴，比起青轴，同样拥有二段式设计的绿轴的压力克数更高（clerk 声也更响），敲击感非常强，反馈非常明确，当然，对于害怕吵到其他人的话，这轴显然不是一个好选择。</p>\n<p>键帽使用了三种颜色搭配的 PBT 无刻键帽，主要是因为现成的刻字键帽来说，显然是无法印刷修改非常严重的自定义按键的，而定制刻字的 PBT 键帽成本又太高，索性也就选择了无刻。</p>\n<p>虽然阳极氧化铝的底座轻便又质感十足，通常是首选。不过既然作为一款码农世家祖传的键盘，最终选择了相对来说观感上更有冲击力的红花梨木底座。其余配置见下表：</p>\n<table>\n<thead>\n<tr>\n<th>类别</th>\n<th>选料</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>主板</td>\n<td>GH60 (Rev.CHN)</td>\n</tr>\n<tr>\n<td>轴体</td>\n<td>Cherry 绿轴</td>\n</tr>\n<tr>\n<td>键帽</td>\n<td>PBT 无刻（红色、灰色、白色）</td>\n</tr>\n<tr>\n<td>LED</td>\n<td>白色</td>\n</tr>\n<tr>\n<td>定位板</td>\n<td>黑色阳极氧化铝上色</td>\n</tr>\n<tr>\n<td>底座</td>\n<td>红花梨木</td>\n</tr>\n<tr>\n<td>USB</td>\n<td>LINDY Mini-USB</td>\n</tr>\n</tbody>\n</table>\n<p>由于我这个烙铁苦手，就上淘宝找了一家常州的 <a href=\"https://yikewaishe.taobao.com/shop/view_shop.htm?user_number_id=134583372\" target=\"_blank\" rel=\"external\">厂家</a>（并没有广告关系，也没有肮脏的交易），对方当天就组装完发货，第二天一大早竟然就送到了。于是拿到手后就进入了修改固件，修改键位的过程了。</p>\n<p>到手的货物长这样：</p>\n<p><img src=\"http://cdn.heckpsi.com/keyboard-2.jpg\" alt=\"\"></p>\n<p><img src=\"http://cdn.heckpsi.com/keyboard-1.jpg\" alt=\"\"></p>\n<h2 id=\"固件\"><a href=\"#固件\" class=\"headerlink\" title=\"固件\"></a>固件</h2><p>客制化键盘的一大好处就是客制化的按键配列，这一点在 60% 和 40% 的键盘上非常重要。我结合我之前 HHKB 的使用经验，我就大致设计了一个如下的配列：</p>\n<p><img src=\"http://cdn.heckpsi.com/keyboard_5.png\" alt=\"\"></p>\n<p>（其中左前方的按键为 Fn 组合键，右前方的是 Fn1 组合键）</p>\n<p>然而客制化固件的刷入还有一些问题。首先这板子是 Rev.CHN 的，一上来刷入就失败了好几次。直到看到了大鹰的 <a href=\"https://bigeagle.me/2015/07/gh60/\" target=\"_blank\" rel=\"external\">这篇文章</a>（没想到大鹰去年也参了开源哥的团，后来也从同一个卖家手里组装了键盘）。</p>\n<p>当然这之前我找到了一个简便的选择 <a href=\"http://www.enjoyclick.org/tkg/#help\" target=\"_blank\" rel=\"external\">TKG Keypad Generator</a>，它能自动生成 avr 单片机的 eep 文件，理论上可以直接刷入。但是我刷入之后无法正常引导键盘，所以还是需要使用 <a href=\"https://github.com/kairyu/tmk_keyboard_custom\" target=\"_blank\" rel=\"external\">tmk-keyboard-custom</a> 自己编译刷入（<code>git clone</code> 的时候切记加入 <code>recursive</code> 参数，因为核心模块以 <code>submodule</code> 的形式出现在这个 <code>repository</code> 中）。不过还是可以使用 TKG Keypad Generator 所生成的 c 语言代码，稍作修改进行编译即可。</p>\n<p>首先把生成的文件命名成 <code>keypad_xxx.c</code> 文件，<code>xxx</code> 为你配列自己的命名。不过直接刷入似乎会遇到一些编译问题，需要在文件后加入如下代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> KEYMAP_IN_EEPROM_ENABLE</span></span><br><span class=\"line\"><span class=\"keyword\">uint16_t</span> keys_count(<span class=\"keyword\">void</span>) &#123;</span><br><span class=\"line\">    return <span class=\"keyword\">sizeof</span>(keymaps) / <span class=\"keyword\">sizeof</span>(keymaps[<span class=\"number\">0</span>]) * MATRIX_ROWS * MATRIX_COLS;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">uint16_t</span> fn_actions_count(<span class=\"keyword\">void</span>) &#123;</span><br><span class=\"line\">    return <span class=\"keyword\">sizeof</span>(fn_actions) / <span class=\"keyword\">sizeof</span>(fn_actions[<span class=\"number\">0</span>]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<p>然后按下键盘背后的 dfu 按钮，使用命令行指令刷入</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make KEYPAD=xxx</span><br><span class=\"line\">make KEYPAD=xxx dfu</span><br></pre></td></tr></table></figure>\n<p>刷入后拔掉 USB 线，按住 BackSpace + Space，插入线缆，3 秒后放掉按键刷新 EEPROM 后，新配列即可工作。</p>\n<p>然后我发现我设计的三个多媒体用途的键中，只有暂停键是可用的，上一首和下一首都不能正常工作，仔细研究后才发现 Mac 机器的上一首和下一首的 KeyCode 和 PC 略有区别，修改后重新编译了固件，按键都能正常工作了。</p>\n<h2 id=\"后\"><a href=\"#后\" class=\"headerlink\" title=\"后\"></a>后</h2><p>当然这块键盘有哪些不满意的地方呢，还是有的。一个问题是右上角的大按键如果拆成两个小按键，对于 <code>BackSpace</code> 和 <code>\\</code> 的设计会变得方便更多，这个实在定位板的选择上出了一些问题。</p>\n<p>另一个就是白色的 LED 灯，哪怕是最低亮度也能轻易地透过白色的按键却无法透过别的按键，这使得这个灯的开启变成了一个比较尴尬的问题。</p>\n","excerpt":"<h2 id=\"引\"><a href=\"#引\" class=\"headerlink\" title=\"引\"></a>引</h2><p>去年的时候就打算购买一款 60% 键盘以方便日常携带。时值开源哥在搞团购 Vim 布局的机械键盘的订购，就订了一把，结果由于一些原因，这单子被取消了。于是我就购买了一把 HHKB pro 2 静电容键盘。虽然说 HHKB 的键位设置和跳线的设计携带起来非常好，但是缺乏段落感的按键还是让人没有那种敲打起来的爽快感。于是我就打算客制化一把机械键盘来满足这个要求。</p>","more":"<h2 id=\"硬件\"><a href=\"#硬件\" class=\"headerlink\" title=\"硬件\"></a>硬件</h2><p>如果要说 60% 的客制化套件的话，主要还是以 GH60 以及其延伸的一系列板子为主。开源哥之前推荐我使用 NerD60 的板子，可惜这块板子在国内并不容易买到。</p>\n<p>轴体的选择使用了相对非常激进的 Cherry 绿轴，比起青轴，同样拥有二段式设计的绿轴的压力克数更高（clerk 声也更响），敲击感非常强，反馈非常明确，当然，对于害怕吵到其他人的话，这轴显然不是一个好选择。</p>\n<p>键帽使用了三种颜色搭配的 PBT 无刻键帽，主要是因为现成的刻字键帽来说，显然是无法印刷修改非常严重的自定义按键的，而定制刻字的 PBT 键帽成本又太高，索性也就选择了无刻。</p>\n<p>虽然阳极氧化铝的底座轻便又质感十足，通常是首选。不过既然作为一款码农世家祖传的键盘，最终选择了相对来说观感上更有冲击力的红花梨木底座。其余配置见下表：</p>\n<table>\n<thead>\n<tr>\n<th>类别</th>\n<th>选料</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>主板</td>\n<td>GH60 (Rev.CHN)</td>\n</tr>\n<tr>\n<td>轴体</td>\n<td>Cherry 绿轴</td>\n</tr>\n<tr>\n<td>键帽</td>\n<td>PBT 无刻（红色、灰色、白色）</td>\n</tr>\n<tr>\n<td>LED</td>\n<td>白色</td>\n</tr>\n<tr>\n<td>定位板</td>\n<td>黑色阳极氧化铝上色</td>\n</tr>\n<tr>\n<td>底座</td>\n<td>红花梨木</td>\n</tr>\n<tr>\n<td>USB</td>\n<td>LINDY Mini-USB</td>\n</tr>\n</tbody>\n</table>\n<p>由于我这个烙铁苦手，就上淘宝找了一家常州的 <a href=\"https://yikewaishe.taobao.com/shop/view_shop.htm?user_number_id=134583372\">厂家</a>（并没有广告关系，也没有肮脏的交易），对方当天就组装完发货，第二天一大早竟然就送到了。于是拿到手后就进入了修改固件，修改键位的过程了。</p>\n<p>到手的货物长这样：</p>\n<p><img src=\"http://cdn.heckpsi.com/keyboard-2.jpg\" alt=\"\"></p>\n<p><img src=\"http://cdn.heckpsi.com/keyboard-1.jpg\" alt=\"\"></p>\n<h2 id=\"固件\"><a href=\"#固件\" class=\"headerlink\" title=\"固件\"></a>固件</h2><p>客制化键盘的一大好处就是客制化的按键配列，这一点在 60% 和 40% 的键盘上非常重要。我结合我之前 HHKB 的使用经验，我就大致设计了一个如下的配列：</p>\n<p><img src=\"http://cdn.heckpsi.com/keyboard_5.png\" alt=\"\"></p>\n<p>（其中左前方的按键为 Fn 组合键，右前方的是 Fn1 组合键）</p>\n<p>然而客制化固件的刷入还有一些问题。首先这板子是 Rev.CHN 的，一上来刷入就失败了好几次。直到看到了大鹰的 <a href=\"https://bigeagle.me/2015/07/gh60/\">这篇文章</a>（没想到大鹰去年也参了开源哥的团，后来也从同一个卖家手里组装了键盘）。</p>\n<p>当然这之前我找到了一个简便的选择 <a href=\"http://www.enjoyclick.org/tkg/#help\">TKG Keypad Generator</a>，它能自动生成 avr 单片机的 eep 文件，理论上可以直接刷入。但是我刷入之后无法正常引导键盘，所以还是需要使用 <a href=\"https://github.com/kairyu/tmk_keyboard_custom\">tmk-keyboard-custom</a> 自己编译刷入（<code>git clone</code> 的时候切记加入 <code>recursive</code> 参数，因为核心模块以 <code>submodule</code> 的形式出现在这个 <code>repository</code> 中）。不过还是可以使用 TKG Keypad Generator 所生成的 c 语言代码，稍作修改进行编译即可。</p>\n<p>首先把生成的文件命名成 <code>keypad_xxx.c</code> 文件，<code>xxx</code> 为你配列自己的命名。不过直接刷入似乎会遇到一些编译问题，需要在文件后加入如下代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> KEYMAP_IN_EEPROM_ENABLE</span></span><br><span class=\"line\"><span class=\"keyword\">uint16_t</span> keys_count(<span class=\"keyword\">void</span>) &#123;</span><br><span class=\"line\">    return <span class=\"keyword\">sizeof</span>(keymaps) / <span class=\"keyword\">sizeof</span>(keymaps[<span class=\"number\">0</span>]) * MATRIX_ROWS * MATRIX_COLS;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">uint16_t</span> fn_actions_count(<span class=\"keyword\">void</span>) &#123;</span><br><span class=\"line\">    return <span class=\"keyword\">sizeof</span>(fn_actions) / <span class=\"keyword\">sizeof</span>(fn_actions[<span class=\"number\">0</span>]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<p>然后按下键盘背后的 dfu 按钮，使用命令行指令刷入</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make KEYPAD=xxx</span><br><span class=\"line\">make KEYPAD=xxx dfu</span><br></pre></td></tr></table></figure>\n<p>刷入后拔掉 USB 线，按住 BackSpace + Space，插入线缆，3 秒后放掉按键刷新 EEPROM 后，新配列即可工作。</p>\n<p>然后我发现我设计的三个多媒体用途的键中，只有暂停键是可用的，上一首和下一首都不能正常工作，仔细研究后才发现 Mac 机器的上一首和下一首的 KeyCode 和 PC 略有区别，修改后重新编译了固件，按键都能正常工作了。</p>\n<h2 id=\"后\"><a href=\"#后\" class=\"headerlink\" title=\"后\"></a>后</h2><p>当然这块键盘有哪些不满意的地方呢，还是有的。一个问题是右上角的大按键如果拆成两个小按键，对于 <code>BackSpace</code> 和 <code>\\</code> 的设计会变得方便更多，这个实在定位板的选择上出了一些问题。</p>\n<p>另一个就是白色的 LED 灯，哪怕是最低亮度也能轻易地透过白色的按键却无法透过别的按键，这使得这个灯的开启变成了一个比较尴尬的问题。</p>"},{"title":"混合应用 —— 一场美味却危险的盛宴","date":"2015-04-02T05:18:38.000Z","_content":"\n随着 HTML 5 的标准的提出、响应式布局的成熟、许多针对移动优化的网页架构的开源项目的推出，手机浏览器能做的已经远不是以前可以想象的了，它几乎可以做任何事情。所以许多概念认为手机上的浏览器应该起到主要作用，Web App 在手机上的一个用这几年成为了一个热点。Ubuntu Mobile 的手机 ROM 更是以 Web App 作为主要功能，也让人体验到了这种想法的可能性。\n\n<!--more-->\n\n网页最大的优势莫过于灵活，用户不需要去更新新版客户端，只要你后端悄悄上线就行了，甚至不需要有版本号这样可以的东西，并且能在各种平台上兼容，同步更新。容器可以随意变化，可以变身文章阅读器、视频播放器甚至是复杂的3D游戏，可以给应用带来各种各样的变化，而且这种变化是非常灵活的，随时都可以。但是就目前使用最常见的 Android iOS WP 系统而言，浏览器还不足以实现全部的特性以支撑整个系统，比如及时的通知系统、后台系统。\n\n在这两者的矛盾下，很快就有人提出了混合应用（Hybrid App），这种应用通过系统私有的方法实现一些网页不能完成的事情，把剩下的内容全部用一个网页容器来实现，大大降低了开发成本。即使许多应用不完全采用这种模式，但多少也会整幅地使用 WebView，尤其是来部署一些灵活的活动信息等，比如微信、微博等都多少有这样的方法。\n\n其实这样的开发虽然降低了复杂度并增加了灵活性，但是其中的安全性却是值得商榷的。比如之前在所有系统版本小于 Android 4.4 的手机上都曝出了 WebView 的 Javascript 注入漏洞，并且 Google 放弃了对这一漏洞的修补，因为认为就安全性而言用户应该先升级到 Android 4.4，无限的向下补丁是不现实的，这么说来也是有道理的。但也使得混合应用的开发存在了一丝疑问。如果这样的漏洞还只是偶然，实际情况中出现的问题常常更为简单，但是却很难想到。\n\n这一类问题往往出现在 Native - WebView 层上。昨天早上人人网愚人节活动系统曝出了系统漏洞，使得黑客在调用后可以任意以任何用户的身份进行发帖，这实在是愚人不成反被愚。曝出后人人的公关部门进行了紧急的处理制止了事态的进一步扩展，实际上，在4月1日一结束后，人人网草草撤下了页面，因为从技术上来说，修复的可能性非常小。\n\n为什么非常小呢？其实核心问题在于，如果 WebView 拥有可以发帖的权限时，我们应该如何确认发帖者的身份。这个问题通常是显然的，常用的方法就是 user - token 验证。即验证用户的 id 和登录成功后系统返回的唯一编号是否一致。但是，在混合应用上这一点却存在一定的问题。有时 token 并不直接由网页获取到，而是由客户端的 Native 部分获取到的。那么当它打开 WebView 的时候就需要将这参数传递进去，这通常是通过创建一个 Cookie 来实现的，在技术上也没有问题。\n\n但是实际问题是，什么时候传呢？\n\n我们继续以昨天人人网的漏洞为例，由于人人在聊天时也可以调用 WebView 来打开第三方的链接，所以就使得传输这个参数成为一个比较难的问题。如果打开第三方链接的时候也把参数传递进去，显然地，我们可以通过伪造一个链接来抓取这个 Cookie 使得 user - token 泄露，实现对用户权限的全部控制，所以是绝对不可取的。所以人人采取的方法是 —— 不传 token。\n\n不传 token 带来的问题叫做 “死无对证”，用户的ID是可以随便并且非常轻易的伪造的。尤其是当人人今天愚人节活动页面最后会发送一条可编辑的消息到用户网页上时，通过伪造 user 可以对所有用户进行操作，造成了重大安全漏洞的爆发。而且更糟糕的是，传递参数这事是在客户端完成的，如果不更新客户端，就永远不会多传一个参数进来，出了问题也无法及时解决。\n\n![](http://cdn.heckpsi.com/1009_1.png)\n\n（通过绕过 token 可以任意账号发布信息）\n\n而这一问题同样存在于许多混合应用之中，不过是他们对待 token 的传递处理方式不同，问题的细节上各有差别。那么，我们也可以来思考一下，假如你是人人网的程序员，同时，你也知道不传 token 和见谁都传 token 都是不对的（其实许多应用都是栽在这前两个问题上）。现在要修复这一问题，你会如何重新选择你何时传递 token 参数这一问题呢？\n\n一、当访问的网址以 http://www.renren.com 开始时，将参数传入。\n\n我想，这是很多人的第一想法。这个方法看起来逻辑是正确的。只有网址以自己网站的目标地址开头时再传，而且这一点是非常容易从 URL 上判断出来的，并且也可以避免访问第三方网站时传入。但是这种方法真的是正确的吗？\n\n答案是否。如果你这么操作了，其实是你对 http 协议的认识不够完备。显然我可以伪造一个这样的地址 http://www.renren.com@heckpsi.com 。这个地址也是以自己目标网站开始的，但是用了@符号，这事实上指的是用 www.renren.com 为用户名登录 heckpsi.com 的网站。不信的用户可以复制上面的地址到浏览器里看一下，它绝对会打开 heckpsi.com 的。所以这么操作是不行的。\n\n二、判断 WebView 访问的目标 Host 是不是 www.renren.com。\n\n这种方法比上面一种显然更靠谱，因为判断的是目标 Host。像上面这种障眼法是不可能改变实际的目标服务器的。但是这种操作在实现上往往会遇到问题，因为当从一个 URL 变成一个目标 Host 的时候实际上浏览器已经开始了解析的工作，这使得你无法及时传入参数了。这样的实现方法在主流的操作系统上都是非常困难的，因为在运行着的 WebView 上试图再写入数据在安全性上是比较有问题的，操作系统一般也不会允许你这么做。而且这么做也并非完全避开了真正的危险，因为显然这种方法可以被下面这种方法所替代。\n\n三、通过字符串解析 URL，算出实际的访问地址，再判断。\n\n这一点其实模拟了浏览器解析 Host 的地址的行为。但解析 URL 这事是否安全本身取决于你解析的方法，当然，我们假设，解析不存在任何问题，它得到了目标的访问地址。这时候再判断一定可以确认用户是否访问的是 www.renren.com 这个地址。这通常来说是安全的了，但是其实还是可以进行攻击的，只不过攻击范围减小了，需要进行路由上的攻击。只要我们将 www.renren.com 的包进行解析商的伪造引向我们的攻击地址，依然可以实现攻击。但是这一点，我认为可以不用很深刻考虑。因为同样我们也能发现，Native 的应用也可以用这种方法进行攻击，已经不是混合应用才有的问题了。\n\n但是真正的安全是不存在的吗？其实也不见得。对于这种伪造地址的方法最方便的解决方案当然是 HTTPS。至于能解决的原因可以参见[\"HTTPS 是如何保证安全的？\"](http://blog.heckpsi.com/2015/04/16/how-https-makes-communication-secured/) 。HTTPS 可以从根本上杜绝嗅探攻击和中间人攻击。对于所有的敏感数据如密码、token 传输的唯一解决方案只有可靠的加密。相比之下，twitter 全网支持 https 传输，Facebook 全网支持 https 传输，而微博和人人都全部不支持 https 传输，可见安全意识之差。\n\n所以混合应用增加了一层传输使得安全性上存在未知的隐患。但大多数安全问题并不是出在理论意义的系统层面上，不过是安全意识差导致的。而归根究底，其实还是做产品的时候，究竟是有什么作为根本驱动的。\n\n","source":"_posts/danger-of-hybrid-apps.md","raw":"---\ntitle: 混合应用 —— 一场美味却危险的盛宴\ndate: 2015-04-02 13:18:38\ntags: [App,Hybrid,安全]\n---\n\n随着 HTML 5 的标准的提出、响应式布局的成熟、许多针对移动优化的网页架构的开源项目的推出，手机浏览器能做的已经远不是以前可以想象的了，它几乎可以做任何事情。所以许多概念认为手机上的浏览器应该起到主要作用，Web App 在手机上的一个用这几年成为了一个热点。Ubuntu Mobile 的手机 ROM 更是以 Web App 作为主要功能，也让人体验到了这种想法的可能性。\n\n<!--more-->\n\n网页最大的优势莫过于灵活，用户不需要去更新新版客户端，只要你后端悄悄上线就行了，甚至不需要有版本号这样可以的东西，并且能在各种平台上兼容，同步更新。容器可以随意变化，可以变身文章阅读器、视频播放器甚至是复杂的3D游戏，可以给应用带来各种各样的变化，而且这种变化是非常灵活的，随时都可以。但是就目前使用最常见的 Android iOS WP 系统而言，浏览器还不足以实现全部的特性以支撑整个系统，比如及时的通知系统、后台系统。\n\n在这两者的矛盾下，很快就有人提出了混合应用（Hybrid App），这种应用通过系统私有的方法实现一些网页不能完成的事情，把剩下的内容全部用一个网页容器来实现，大大降低了开发成本。即使许多应用不完全采用这种模式，但多少也会整幅地使用 WebView，尤其是来部署一些灵活的活动信息等，比如微信、微博等都多少有这样的方法。\n\n其实这样的开发虽然降低了复杂度并增加了灵活性，但是其中的安全性却是值得商榷的。比如之前在所有系统版本小于 Android 4.4 的手机上都曝出了 WebView 的 Javascript 注入漏洞，并且 Google 放弃了对这一漏洞的修补，因为认为就安全性而言用户应该先升级到 Android 4.4，无限的向下补丁是不现实的，这么说来也是有道理的。但也使得混合应用的开发存在了一丝疑问。如果这样的漏洞还只是偶然，实际情况中出现的问题常常更为简单，但是却很难想到。\n\n这一类问题往往出现在 Native - WebView 层上。昨天早上人人网愚人节活动系统曝出了系统漏洞，使得黑客在调用后可以任意以任何用户的身份进行发帖，这实在是愚人不成反被愚。曝出后人人的公关部门进行了紧急的处理制止了事态的进一步扩展，实际上，在4月1日一结束后，人人网草草撤下了页面，因为从技术上来说，修复的可能性非常小。\n\n为什么非常小呢？其实核心问题在于，如果 WebView 拥有可以发帖的权限时，我们应该如何确认发帖者的身份。这个问题通常是显然的，常用的方法就是 user - token 验证。即验证用户的 id 和登录成功后系统返回的唯一编号是否一致。但是，在混合应用上这一点却存在一定的问题。有时 token 并不直接由网页获取到，而是由客户端的 Native 部分获取到的。那么当它打开 WebView 的时候就需要将这参数传递进去，这通常是通过创建一个 Cookie 来实现的，在技术上也没有问题。\n\n但是实际问题是，什么时候传呢？\n\n我们继续以昨天人人网的漏洞为例，由于人人在聊天时也可以调用 WebView 来打开第三方的链接，所以就使得传输这个参数成为一个比较难的问题。如果打开第三方链接的时候也把参数传递进去，显然地，我们可以通过伪造一个链接来抓取这个 Cookie 使得 user - token 泄露，实现对用户权限的全部控制，所以是绝对不可取的。所以人人采取的方法是 —— 不传 token。\n\n不传 token 带来的问题叫做 “死无对证”，用户的ID是可以随便并且非常轻易的伪造的。尤其是当人人今天愚人节活动页面最后会发送一条可编辑的消息到用户网页上时，通过伪造 user 可以对所有用户进行操作，造成了重大安全漏洞的爆发。而且更糟糕的是，传递参数这事是在客户端完成的，如果不更新客户端，就永远不会多传一个参数进来，出了问题也无法及时解决。\n\n![](http://cdn.heckpsi.com/1009_1.png)\n\n（通过绕过 token 可以任意账号发布信息）\n\n而这一问题同样存在于许多混合应用之中，不过是他们对待 token 的传递处理方式不同，问题的细节上各有差别。那么，我们也可以来思考一下，假如你是人人网的程序员，同时，你也知道不传 token 和见谁都传 token 都是不对的（其实许多应用都是栽在这前两个问题上）。现在要修复这一问题，你会如何重新选择你何时传递 token 参数这一问题呢？\n\n一、当访问的网址以 http://www.renren.com 开始时，将参数传入。\n\n我想，这是很多人的第一想法。这个方法看起来逻辑是正确的。只有网址以自己网站的目标地址开头时再传，而且这一点是非常容易从 URL 上判断出来的，并且也可以避免访问第三方网站时传入。但是这种方法真的是正确的吗？\n\n答案是否。如果你这么操作了，其实是你对 http 协议的认识不够完备。显然我可以伪造一个这样的地址 http://www.renren.com@heckpsi.com 。这个地址也是以自己目标网站开始的，但是用了@符号，这事实上指的是用 www.renren.com 为用户名登录 heckpsi.com 的网站。不信的用户可以复制上面的地址到浏览器里看一下，它绝对会打开 heckpsi.com 的。所以这么操作是不行的。\n\n二、判断 WebView 访问的目标 Host 是不是 www.renren.com。\n\n这种方法比上面一种显然更靠谱，因为判断的是目标 Host。像上面这种障眼法是不可能改变实际的目标服务器的。但是这种操作在实现上往往会遇到问题，因为当从一个 URL 变成一个目标 Host 的时候实际上浏览器已经开始了解析的工作，这使得你无法及时传入参数了。这样的实现方法在主流的操作系统上都是非常困难的，因为在运行着的 WebView 上试图再写入数据在安全性上是比较有问题的，操作系统一般也不会允许你这么做。而且这么做也并非完全避开了真正的危险，因为显然这种方法可以被下面这种方法所替代。\n\n三、通过字符串解析 URL，算出实际的访问地址，再判断。\n\n这一点其实模拟了浏览器解析 Host 的地址的行为。但解析 URL 这事是否安全本身取决于你解析的方法，当然，我们假设，解析不存在任何问题，它得到了目标的访问地址。这时候再判断一定可以确认用户是否访问的是 www.renren.com 这个地址。这通常来说是安全的了，但是其实还是可以进行攻击的，只不过攻击范围减小了，需要进行路由上的攻击。只要我们将 www.renren.com 的包进行解析商的伪造引向我们的攻击地址，依然可以实现攻击。但是这一点，我认为可以不用很深刻考虑。因为同样我们也能发现，Native 的应用也可以用这种方法进行攻击，已经不是混合应用才有的问题了。\n\n但是真正的安全是不存在的吗？其实也不见得。对于这种伪造地址的方法最方便的解决方案当然是 HTTPS。至于能解决的原因可以参见[\"HTTPS 是如何保证安全的？\"](http://blog.heckpsi.com/2015/04/16/how-https-makes-communication-secured/) 。HTTPS 可以从根本上杜绝嗅探攻击和中间人攻击。对于所有的敏感数据如密码、token 传输的唯一解决方案只有可靠的加密。相比之下，twitter 全网支持 https 传输，Facebook 全网支持 https 传输，而微博和人人都全部不支持 https 传输，可见安全意识之差。\n\n所以混合应用增加了一层传输使得安全性上存在未知的隐患。但大多数安全问题并不是出在理论意义的系统层面上，不过是安全意识差导致的。而归根究底，其实还是做产品的时候，究竟是有什么作为根本驱动的。\n\n","slug":"danger-of-hybrid-apps","published":1,"updated":"2016-05-15T03:20:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscy008o000bpp8zqckg43iy","content":"<p>随着 HTML 5 的标准的提出、响应式布局的成熟、许多针对移动优化的网页架构的开源项目的推出，手机浏览器能做的已经远不是以前可以想象的了，它几乎可以做任何事情。所以许多概念认为手机上的浏览器应该起到主要作用，Web App 在手机上的一个用这几年成为了一个热点。Ubuntu Mobile 的手机 ROM 更是以 Web App 作为主要功能，也让人体验到了这种想法的可能性。</p>\n<a id=\"more\"></a>\n<p>网页最大的优势莫过于灵活，用户不需要去更新新版客户端，只要你后端悄悄上线就行了，甚至不需要有版本号这样可以的东西，并且能在各种平台上兼容，同步更新。容器可以随意变化，可以变身文章阅读器、视频播放器甚至是复杂的3D游戏，可以给应用带来各种各样的变化，而且这种变化是非常灵活的，随时都可以。但是就目前使用最常见的 Android iOS WP 系统而言，浏览器还不足以实现全部的特性以支撑整个系统，比如及时的通知系统、后台系统。</p>\n<p>在这两者的矛盾下，很快就有人提出了混合应用（Hybrid App），这种应用通过系统私有的方法实现一些网页不能完成的事情，把剩下的内容全部用一个网页容器来实现，大大降低了开发成本。即使许多应用不完全采用这种模式，但多少也会整幅地使用 WebView，尤其是来部署一些灵活的活动信息等，比如微信、微博等都多少有这样的方法。</p>\n<p>其实这样的开发虽然降低了复杂度并增加了灵活性，但是其中的安全性却是值得商榷的。比如之前在所有系统版本小于 Android 4.4 的手机上都曝出了 WebView 的 Javascript 注入漏洞，并且 Google 放弃了对这一漏洞的修补，因为认为就安全性而言用户应该先升级到 Android 4.4，无限的向下补丁是不现实的，这么说来也是有道理的。但也使得混合应用的开发存在了一丝疑问。如果这样的漏洞还只是偶然，实际情况中出现的问题常常更为简单，但是却很难想到。</p>\n<p>这一类问题往往出现在 Native - WebView 层上。昨天早上人人网愚人节活动系统曝出了系统漏洞，使得黑客在调用后可以任意以任何用户的身份进行发帖，这实在是愚人不成反被愚。曝出后人人的公关部门进行了紧急的处理制止了事态的进一步扩展，实际上，在4月1日一结束后，人人网草草撤下了页面，因为从技术上来说，修复的可能性非常小。</p>\n<p>为什么非常小呢？其实核心问题在于，如果 WebView 拥有可以发帖的权限时，我们应该如何确认发帖者的身份。这个问题通常是显然的，常用的方法就是 user - token 验证。即验证用户的 id 和登录成功后系统返回的唯一编号是否一致。但是，在混合应用上这一点却存在一定的问题。有时 token 并不直接由网页获取到，而是由客户端的 Native 部分获取到的。那么当它打开 WebView 的时候就需要将这参数传递进去，这通常是通过创建一个 Cookie 来实现的，在技术上也没有问题。</p>\n<p>但是实际问题是，什么时候传呢？</p>\n<p>我们继续以昨天人人网的漏洞为例，由于人人在聊天时也可以调用 WebView 来打开第三方的链接，所以就使得传输这个参数成为一个比较难的问题。如果打开第三方链接的时候也把参数传递进去，显然地，我们可以通过伪造一个链接来抓取这个 Cookie 使得 user - token 泄露，实现对用户权限的全部控制，所以是绝对不可取的。所以人人采取的方法是 —— 不传 token。</p>\n<p>不传 token 带来的问题叫做 “死无对证”，用户的ID是可以随便并且非常轻易的伪造的。尤其是当人人今天愚人节活动页面最后会发送一条可编辑的消息到用户网页上时，通过伪造 user 可以对所有用户进行操作，造成了重大安全漏洞的爆发。而且更糟糕的是，传递参数这事是在客户端完成的，如果不更新客户端，就永远不会多传一个参数进来，出了问题也无法及时解决。</p>\n<p><img src=\"http://cdn.heckpsi.com/1009_1.png\" alt=\"\"></p>\n<p>（通过绕过 token 可以任意账号发布信息）</p>\n<p>而这一问题同样存在于许多混合应用之中，不过是他们对待 token 的传递处理方式不同，问题的细节上各有差别。那么，我们也可以来思考一下，假如你是人人网的程序员，同时，你也知道不传 token 和见谁都传 token 都是不对的（其实许多应用都是栽在这前两个问题上）。现在要修复这一问题，你会如何重新选择你何时传递 token 参数这一问题呢？</p>\n<p>一、当访问的网址以 <a href=\"http://www.renren.com\" target=\"_blank\" rel=\"external\">http://www.renren.com</a> 开始时，将参数传入。</p>\n<p>我想，这是很多人的第一想法。这个方法看起来逻辑是正确的。只有网址以自己网站的目标地址开头时再传，而且这一点是非常容易从 URL 上判断出来的，并且也可以避免访问第三方网站时传入。但是这种方法真的是正确的吗？</p>\n<p>答案是否。如果你这么操作了，其实是你对 http 协议的认识不够完备。显然我可以伪造一个这样的地址 <a href=\"http://www.renren.com@heckpsi.com\" target=\"_blank\" rel=\"external\">http://www.renren.com@heckpsi.com</a> 。这个地址也是以自己目标网站开始的，但是用了@符号，这事实上指的是用 www.renren.com 为用户名登录 heckpsi.com 的网站。不信的用户可以复制上面的地址到浏览器里看一下，它绝对会打开 heckpsi.com 的。所以这么操作是不行的。</p>\n<p>二、判断 WebView 访问的目标 Host 是不是 www.renren.com。</p>\n<p>这种方法比上面一种显然更靠谱，因为判断的是目标 Host。像上面这种障眼法是不可能改变实际的目标服务器的。但是这种操作在实现上往往会遇到问题，因为当从一个 URL 变成一个目标 Host 的时候实际上浏览器已经开始了解析的工作，这使得你无法及时传入参数了。这样的实现方法在主流的操作系统上都是非常困难的，因为在运行着的 WebView 上试图再写入数据在安全性上是比较有问题的，操作系统一般也不会允许你这么做。而且这么做也并非完全避开了真正的危险，因为显然这种方法可以被下面这种方法所替代。</p>\n<p>三、通过字符串解析 URL，算出实际的访问地址，再判断。</p>\n<p>这一点其实模拟了浏览器解析 Host 的地址的行为。但解析 URL 这事是否安全本身取决于你解析的方法，当然，我们假设，解析不存在任何问题，它得到了目标的访问地址。这时候再判断一定可以确认用户是否访问的是 www.renren.com 这个地址。这通常来说是安全的了，但是其实还是可以进行攻击的，只不过攻击范围减小了，需要进行路由上的攻击。只要我们将 www.renren.com 的包进行解析商的伪造引向我们的攻击地址，依然可以实现攻击。但是这一点，我认为可以不用很深刻考虑。因为同样我们也能发现，Native 的应用也可以用这种方法进行攻击，已经不是混合应用才有的问题了。</p>\n<p>但是真正的安全是不存在的吗？其实也不见得。对于这种伪造地址的方法最方便的解决方案当然是 HTTPS。至于能解决的原因可以参见<a href=\"http://blog.heckpsi.com/2015/04/16/how-https-makes-communication-secured/\">“HTTPS 是如何保证安全的？”</a> 。HTTPS 可以从根本上杜绝嗅探攻击和中间人攻击。对于所有的敏感数据如密码、token 传输的唯一解决方案只有可靠的加密。相比之下，twitter 全网支持 https 传输，Facebook 全网支持 https 传输，而微博和人人都全部不支持 https 传输，可见安全意识之差。</p>\n<p>所以混合应用增加了一层传输使得安全性上存在未知的隐患。但大多数安全问题并不是出在理论意义的系统层面上，不过是安全意识差导致的。而归根究底，其实还是做产品的时候，究竟是有什么作为根本驱动的。</p>\n","excerpt":"<p>随着 HTML 5 的标准的提出、响应式布局的成熟、许多针对移动优化的网页架构的开源项目的推出，手机浏览器能做的已经远不是以前可以想象的了，它几乎可以做任何事情。所以许多概念认为手机上的浏览器应该起到主要作用，Web App 在手机上的一个用这几年成为了一个热点。Ubuntu Mobile 的手机 ROM 更是以 Web App 作为主要功能，也让人体验到了这种想法的可能性。</p>","more":"<p>网页最大的优势莫过于灵活，用户不需要去更新新版客户端，只要你后端悄悄上线就行了，甚至不需要有版本号这样可以的东西，并且能在各种平台上兼容，同步更新。容器可以随意变化，可以变身文章阅读器、视频播放器甚至是复杂的3D游戏，可以给应用带来各种各样的变化，而且这种变化是非常灵活的，随时都可以。但是就目前使用最常见的 Android iOS WP 系统而言，浏览器还不足以实现全部的特性以支撑整个系统，比如及时的通知系统、后台系统。</p>\n<p>在这两者的矛盾下，很快就有人提出了混合应用（Hybrid App），这种应用通过系统私有的方法实现一些网页不能完成的事情，把剩下的内容全部用一个网页容器来实现，大大降低了开发成本。即使许多应用不完全采用这种模式，但多少也会整幅地使用 WebView，尤其是来部署一些灵活的活动信息等，比如微信、微博等都多少有这样的方法。</p>\n<p>其实这样的开发虽然降低了复杂度并增加了灵活性，但是其中的安全性却是值得商榷的。比如之前在所有系统版本小于 Android 4.4 的手机上都曝出了 WebView 的 Javascript 注入漏洞，并且 Google 放弃了对这一漏洞的修补，因为认为就安全性而言用户应该先升级到 Android 4.4，无限的向下补丁是不现实的，这么说来也是有道理的。但也使得混合应用的开发存在了一丝疑问。如果这样的漏洞还只是偶然，实际情况中出现的问题常常更为简单，但是却很难想到。</p>\n<p>这一类问题往往出现在 Native - WebView 层上。昨天早上人人网愚人节活动系统曝出了系统漏洞，使得黑客在调用后可以任意以任何用户的身份进行发帖，这实在是愚人不成反被愚。曝出后人人的公关部门进行了紧急的处理制止了事态的进一步扩展，实际上，在4月1日一结束后，人人网草草撤下了页面，因为从技术上来说，修复的可能性非常小。</p>\n<p>为什么非常小呢？其实核心问题在于，如果 WebView 拥有可以发帖的权限时，我们应该如何确认发帖者的身份。这个问题通常是显然的，常用的方法就是 user - token 验证。即验证用户的 id 和登录成功后系统返回的唯一编号是否一致。但是，在混合应用上这一点却存在一定的问题。有时 token 并不直接由网页获取到，而是由客户端的 Native 部分获取到的。那么当它打开 WebView 的时候就需要将这参数传递进去，这通常是通过创建一个 Cookie 来实现的，在技术上也没有问题。</p>\n<p>但是实际问题是，什么时候传呢？</p>\n<p>我们继续以昨天人人网的漏洞为例，由于人人在聊天时也可以调用 WebView 来打开第三方的链接，所以就使得传输这个参数成为一个比较难的问题。如果打开第三方链接的时候也把参数传递进去，显然地，我们可以通过伪造一个链接来抓取这个 Cookie 使得 user - token 泄露，实现对用户权限的全部控制，所以是绝对不可取的。所以人人采取的方法是 —— 不传 token。</p>\n<p>不传 token 带来的问题叫做 “死无对证”，用户的ID是可以随便并且非常轻易的伪造的。尤其是当人人今天愚人节活动页面最后会发送一条可编辑的消息到用户网页上时，通过伪造 user 可以对所有用户进行操作，造成了重大安全漏洞的爆发。而且更糟糕的是，传递参数这事是在客户端完成的，如果不更新客户端，就永远不会多传一个参数进来，出了问题也无法及时解决。</p>\n<p><img src=\"http://cdn.heckpsi.com/1009_1.png\" alt=\"\"></p>\n<p>（通过绕过 token 可以任意账号发布信息）</p>\n<p>而这一问题同样存在于许多混合应用之中，不过是他们对待 token 的传递处理方式不同，问题的细节上各有差别。那么，我们也可以来思考一下，假如你是人人网的程序员，同时，你也知道不传 token 和见谁都传 token 都是不对的（其实许多应用都是栽在这前两个问题上）。现在要修复这一问题，你会如何重新选择你何时传递 token 参数这一问题呢？</p>\n<p>一、当访问的网址以 <a href=\"http://www.renren.com\">http://www.renren.com</a> 开始时，将参数传入。</p>\n<p>我想，这是很多人的第一想法。这个方法看起来逻辑是正确的。只有网址以自己网站的目标地址开头时再传，而且这一点是非常容易从 URL 上判断出来的，并且也可以避免访问第三方网站时传入。但是这种方法真的是正确的吗？</p>\n<p>答案是否。如果你这么操作了，其实是你对 http 协议的认识不够完备。显然我可以伪造一个这样的地址 <a href=\"http://www.renren.com@heckpsi.com\">http://www.renren.com@heckpsi.com</a> 。这个地址也是以自己目标网站开始的，但是用了@符号，这事实上指的是用 www.renren.com 为用户名登录 heckpsi.com 的网站。不信的用户可以复制上面的地址到浏览器里看一下，它绝对会打开 heckpsi.com 的。所以这么操作是不行的。</p>\n<p>二、判断 WebView 访问的目标 Host 是不是 www.renren.com。</p>\n<p>这种方法比上面一种显然更靠谱，因为判断的是目标 Host。像上面这种障眼法是不可能改变实际的目标服务器的。但是这种操作在实现上往往会遇到问题，因为当从一个 URL 变成一个目标 Host 的时候实际上浏览器已经开始了解析的工作，这使得你无法及时传入参数了。这样的实现方法在主流的操作系统上都是非常困难的，因为在运行着的 WebView 上试图再写入数据在安全性上是比较有问题的，操作系统一般也不会允许你这么做。而且这么做也并非完全避开了真正的危险，因为显然这种方法可以被下面这种方法所替代。</p>\n<p>三、通过字符串解析 URL，算出实际的访问地址，再判断。</p>\n<p>这一点其实模拟了浏览器解析 Host 的地址的行为。但解析 URL 这事是否安全本身取决于你解析的方法，当然，我们假设，解析不存在任何问题，它得到了目标的访问地址。这时候再判断一定可以确认用户是否访问的是 www.renren.com 这个地址。这通常来说是安全的了，但是其实还是可以进行攻击的，只不过攻击范围减小了，需要进行路由上的攻击。只要我们将 www.renren.com 的包进行解析商的伪造引向我们的攻击地址，依然可以实现攻击。但是这一点，我认为可以不用很深刻考虑。因为同样我们也能发现，Native 的应用也可以用这种方法进行攻击，已经不是混合应用才有的问题了。</p>\n<p>但是真正的安全是不存在的吗？其实也不见得。对于这种伪造地址的方法最方便的解决方案当然是 HTTPS。至于能解决的原因可以参见<a href=\"http://blog.heckpsi.com/2015/04/16/how-https-makes-communication-secured/\">“HTTPS 是如何保证安全的？”</a> 。HTTPS 可以从根本上杜绝嗅探攻击和中间人攻击。对于所有的敏感数据如密码、token 传输的唯一解决方案只有可靠的加密。相比之下，twitter 全网支持 https 传输，Facebook 全网支持 https 传输，而微博和人人都全部不支持 https 传输，可见安全意识之差。</p>\n<p>所以混合应用增加了一层传输使得安全性上存在未知的隐患。但大多数安全问题并不是出在理论意义的系统层面上，不过是安全意识差导致的。而归根究底，其实还是做产品的时候，究竟是有什么作为根本驱动的。</p>"},{"title":"从 “没有响应” 说到哥德尔不完备定理","date":"2015-04-27T12:15:54.000Z","_content":"\n当你看到窗口的标题栏上出现了 “没有响应” (No Responding) 四个字，电脑陷入了莫名的卡顿的时候，你一拍脑袋，大喝一声 “又死机了！” ，点下结束进程的你是否想过，这玩意，真的死机了吗？有时莫名卡顿了几分钟后，程序又莫名其妙恢复正常了。这又是什么情况呢？\n\n<!--more-->\n\n首先，我们先来理解一下，什么是 “没有响应”，[微软](http://windows.microsoft.com/zh-cn/windows-vista/what-does-it-mean-when-a-program-is-not-responding) 的官方帮助告诉我们：表示该程序与 Windows 的连接速度比平常慢，一般原因是程序中出现问题。如果我们深入理解一下的话，我们可以先考虑一下带窗口界面的程序通常的运行形式。\n\n一个程序通常可以拥有很多线程，意味着它可以同时干很多事。然而通常只有主线程是可以用来更新窗口上显示的内容的，别的线程只能在背后默默进行计算、网络通讯等其它工作。对于同一个线程，一次只能干一件事。主线程虽然更新界面，但大多数情况下，它也会进行一些运算。但如果这个线程长达数秒都迟迟无法更新界面，也就是说这个线程在运行某些内容时阻塞了，系统就会认为这是程序 “没有响应” 了。没有响应通常有两种可能性，第一种是程序运行出现了死循环，怎么也跑不出来了，这就是我们常说的死机。为了帮助大家理解这种 “死循环”，大家可以思考一下下面这个程序：\n\n```\n第一步：运行 1+x\n第二步：如果上一步运行结果是2，那么重新运行第一步\n第三步：显示结果\n```\n\n非常显然，当 x=1 时，这个程序将无限在一二步中循环，这就是传说中的死循环。死循环会导致主线程阻塞（如果这个运算在主线程执行的话）。这就会出现 “没有响应” 的情况。\n\n当然造成 “没有响应” 并不止这一种可能，另一种可能那就是主线程真的在执行某个计算很费时的运算。比如运算小于 10000000000000 的所有素数，这由于算的时间太长也会阻塞主线程，导致 “没有响应”。不过这种阻塞是暂时的，并不是真正的死循环，稍等片刻也是可以解出来的。\n\n然而，为什么系统不能区分出这两种阻塞哪一种是真正的死循环而哪一种只是运算太慢了呢？因为。。。真的不能。。。区分。。。\n\n这种 “不能”，是数学意义上证明的，它就是不能。\n\n给出这个证明的是年仅24岁的计算机科学之父——艾伦·图灵，证明这个问题，这篇论文有近40页（[原文](http://www.cs.virginia.edu/~robins/Turing_Paper_1936.pdf)），不过实际上的证明过程，只需要一张纸就能说明了。\n\n还是以刚刚演示的会死循环的程序为例，显然这个程序在 x=1 时发生死循环，我们记这个程序为 F(x)，当 x=1 时死循环。我们假设存在一个程序能判定程序是不是会死循环，我发这个程序叫 G(f,x)，指该程序可以判定程序f是否在输入x时会死循环。如果判定为死循环就返回1，正常运行就返回0。所以显然 G(F,1) = 1，G(F,2)=0。\n\n我们现在再构造一个更恶心的函数，它叫 T(f,x)，它内部会先运行 G(f,x)，如果发现 G(f,x) = 1 就正常退出，而如果  G(f,x)=0 时就让自己死循环。\n\n那么问题来了，T(T,x) 会不会死机呢？\n\n我们可以假设 T(T,x) 是不死机的，那么意味着 G(T,x) 返回的是1，而 G(T,x) 返回1的前提是 T(T,x) 是死机的，相矛盾，反之同样矛盾。由此证明，一个判断程序是否可能死机的函数  G(f,x) 不存在。\n\n这就是著名的图灵停机问题，在80年前还没有计算机的时候，图灵就证明了这个问题。\n\n不过图灵的这个证明恰好证明了另一个问题，那就是希尔伯特的23个问题。这是德国数学家大卫·希尔伯特（David Hilbert）于1900年在巴黎举行的第二届国际数学家大会上所提出23道最重要的数学问题中的第2个问题 —— 算术公理之相容性。这个问题其本质是希望找到一个方法证明任意公理系统的内部是不矛盾的。\n\n但实际上是事与愿违的，许多公理系统都是自相矛盾的。图灵的停机问题就是这样一种自相矛盾的一个证明。当然，一些更熟悉更易理解的问题其实也可以证明这样的问题。\n\n比如最常见的是 罗素悖论 的一个通俗描述，那就是 理发师悖论。一个理发师给所有不给自己理发的人理发，那么他给不给自己理发？这时候无论理还是不理，都是相矛盾的。\n\n罗素悖论的相对深入的通俗描述可以这么理解：比如一个集合：世界上所有描述它字数少于100字的集合都是这个集合的子集。这个描述本身是完备的，但显然这个集合本身也是自己的子集，并且这个集合包含的还不止有自己集合本身，意味着这个集合本身是自己的真子集，这就是非常荒谬而矛盾的了。\n\n无论图灵还是罗素提出的悖论都证明了我们的计算系统存在不完备的漏洞，然而 1931 年数学家库尔特·哥德尔给出了更为完整的证明，这个证明直接把这种不完备提升到了一个巨大的前提下：任何相容的形式系统，只要蕴涵皮亚诺算术公理，就可以在其中构造在体系中不能被证明的真命题，因此通过推演不能得到所有真命题（即体系是不完备的）。\n\n也就是说，任何形式的数学系统，只要包含关于自然数最最基础的公理：皮亚诺公理，那么它就是不完备的，如此残念。\n\n```\n我看到了它，却不敢相信它。 —— 康托尔\n```\n\n","source":"_posts/from-no-response-to-godels-incompleteness.md","raw":"---\ntitle: 从 “没有响应” 说到哥德尔不完备定理\ndate: 2015-04-27 20:15:54\ntags: [数学,算法]\n---\n\n当你看到窗口的标题栏上出现了 “没有响应” (No Responding) 四个字，电脑陷入了莫名的卡顿的时候，你一拍脑袋，大喝一声 “又死机了！” ，点下结束进程的你是否想过，这玩意，真的死机了吗？有时莫名卡顿了几分钟后，程序又莫名其妙恢复正常了。这又是什么情况呢？\n\n<!--more-->\n\n首先，我们先来理解一下，什么是 “没有响应”，[微软](http://windows.microsoft.com/zh-cn/windows-vista/what-does-it-mean-when-a-program-is-not-responding) 的官方帮助告诉我们：表示该程序与 Windows 的连接速度比平常慢，一般原因是程序中出现问题。如果我们深入理解一下的话，我们可以先考虑一下带窗口界面的程序通常的运行形式。\n\n一个程序通常可以拥有很多线程，意味着它可以同时干很多事。然而通常只有主线程是可以用来更新窗口上显示的内容的，别的线程只能在背后默默进行计算、网络通讯等其它工作。对于同一个线程，一次只能干一件事。主线程虽然更新界面，但大多数情况下，它也会进行一些运算。但如果这个线程长达数秒都迟迟无法更新界面，也就是说这个线程在运行某些内容时阻塞了，系统就会认为这是程序 “没有响应” 了。没有响应通常有两种可能性，第一种是程序运行出现了死循环，怎么也跑不出来了，这就是我们常说的死机。为了帮助大家理解这种 “死循环”，大家可以思考一下下面这个程序：\n\n```\n第一步：运行 1+x\n第二步：如果上一步运行结果是2，那么重新运行第一步\n第三步：显示结果\n```\n\n非常显然，当 x=1 时，这个程序将无限在一二步中循环，这就是传说中的死循环。死循环会导致主线程阻塞（如果这个运算在主线程执行的话）。这就会出现 “没有响应” 的情况。\n\n当然造成 “没有响应” 并不止这一种可能，另一种可能那就是主线程真的在执行某个计算很费时的运算。比如运算小于 10000000000000 的所有素数，这由于算的时间太长也会阻塞主线程，导致 “没有响应”。不过这种阻塞是暂时的，并不是真正的死循环，稍等片刻也是可以解出来的。\n\n然而，为什么系统不能区分出这两种阻塞哪一种是真正的死循环而哪一种只是运算太慢了呢？因为。。。真的不能。。。区分。。。\n\n这种 “不能”，是数学意义上证明的，它就是不能。\n\n给出这个证明的是年仅24岁的计算机科学之父——艾伦·图灵，证明这个问题，这篇论文有近40页（[原文](http://www.cs.virginia.edu/~robins/Turing_Paper_1936.pdf)），不过实际上的证明过程，只需要一张纸就能说明了。\n\n还是以刚刚演示的会死循环的程序为例，显然这个程序在 x=1 时发生死循环，我们记这个程序为 F(x)，当 x=1 时死循环。我们假设存在一个程序能判定程序是不是会死循环，我发这个程序叫 G(f,x)，指该程序可以判定程序f是否在输入x时会死循环。如果判定为死循环就返回1，正常运行就返回0。所以显然 G(F,1) = 1，G(F,2)=0。\n\n我们现在再构造一个更恶心的函数，它叫 T(f,x)，它内部会先运行 G(f,x)，如果发现 G(f,x) = 1 就正常退出，而如果  G(f,x)=0 时就让自己死循环。\n\n那么问题来了，T(T,x) 会不会死机呢？\n\n我们可以假设 T(T,x) 是不死机的，那么意味着 G(T,x) 返回的是1，而 G(T,x) 返回1的前提是 T(T,x) 是死机的，相矛盾，反之同样矛盾。由此证明，一个判断程序是否可能死机的函数  G(f,x) 不存在。\n\n这就是著名的图灵停机问题，在80年前还没有计算机的时候，图灵就证明了这个问题。\n\n不过图灵的这个证明恰好证明了另一个问题，那就是希尔伯特的23个问题。这是德国数学家大卫·希尔伯特（David Hilbert）于1900年在巴黎举行的第二届国际数学家大会上所提出23道最重要的数学问题中的第2个问题 —— 算术公理之相容性。这个问题其本质是希望找到一个方法证明任意公理系统的内部是不矛盾的。\n\n但实际上是事与愿违的，许多公理系统都是自相矛盾的。图灵的停机问题就是这样一种自相矛盾的一个证明。当然，一些更熟悉更易理解的问题其实也可以证明这样的问题。\n\n比如最常见的是 罗素悖论 的一个通俗描述，那就是 理发师悖论。一个理发师给所有不给自己理发的人理发，那么他给不给自己理发？这时候无论理还是不理，都是相矛盾的。\n\n罗素悖论的相对深入的通俗描述可以这么理解：比如一个集合：世界上所有描述它字数少于100字的集合都是这个集合的子集。这个描述本身是完备的，但显然这个集合本身也是自己的子集，并且这个集合包含的还不止有自己集合本身，意味着这个集合本身是自己的真子集，这就是非常荒谬而矛盾的了。\n\n无论图灵还是罗素提出的悖论都证明了我们的计算系统存在不完备的漏洞，然而 1931 年数学家库尔特·哥德尔给出了更为完整的证明，这个证明直接把这种不完备提升到了一个巨大的前提下：任何相容的形式系统，只要蕴涵皮亚诺算术公理，就可以在其中构造在体系中不能被证明的真命题，因此通过推演不能得到所有真命题（即体系是不完备的）。\n\n也就是说，任何形式的数学系统，只要包含关于自然数最最基础的公理：皮亚诺公理，那么它就是不完备的，如此残念。\n\n```\n我看到了它，却不敢相信它。 —— 康托尔\n```\n\n","slug":"from-no-response-to-godels-incompleteness","published":1,"updated":"2016-04-23T12:57:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscy008s000dpp8ze0xqsfd2","content":"<p>当你看到窗口的标题栏上出现了 “没有响应” (No Responding) 四个字，电脑陷入了莫名的卡顿的时候，你一拍脑袋，大喝一声 “又死机了！” ，点下结束进程的你是否想过，这玩意，真的死机了吗？有时莫名卡顿了几分钟后，程序又莫名其妙恢复正常了。这又是什么情况呢？</p>\n<a id=\"more\"></a>\n<p>首先，我们先来理解一下，什么是 “没有响应”，<a href=\"http://windows.microsoft.com/zh-cn/windows-vista/what-does-it-mean-when-a-program-is-not-responding\" target=\"_blank\" rel=\"external\">微软</a> 的官方帮助告诉我们：表示该程序与 Windows 的连接速度比平常慢，一般原因是程序中出现问题。如果我们深入理解一下的话，我们可以先考虑一下带窗口界面的程序通常的运行形式。</p>\n<p>一个程序通常可以拥有很多线程，意味着它可以同时干很多事。然而通常只有主线程是可以用来更新窗口上显示的内容的，别的线程只能在背后默默进行计算、网络通讯等其它工作。对于同一个线程，一次只能干一件事。主线程虽然更新界面，但大多数情况下，它也会进行一些运算。但如果这个线程长达数秒都迟迟无法更新界面，也就是说这个线程在运行某些内容时阻塞了，系统就会认为这是程序 “没有响应” 了。没有响应通常有两种可能性，第一种是程序运行出现了死循环，怎么也跑不出来了，这就是我们常说的死机。为了帮助大家理解这种 “死循环”，大家可以思考一下下面这个程序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一步：运行 1+x</span><br><span class=\"line\">第二步：如果上一步运行结果是2，那么重新运行第一步</span><br><span class=\"line\">第三步：显示结果</span><br></pre></td></tr></table></figure>\n<p>非常显然，当 x=1 时，这个程序将无限在一二步中循环，这就是传说中的死循环。死循环会导致主线程阻塞（如果这个运算在主线程执行的话）。这就会出现 “没有响应” 的情况。</p>\n<p>当然造成 “没有响应” 并不止这一种可能，另一种可能那就是主线程真的在执行某个计算很费时的运算。比如运算小于 10000000000000 的所有素数，这由于算的时间太长也会阻塞主线程，导致 “没有响应”。不过这种阻塞是暂时的，并不是真正的死循环，稍等片刻也是可以解出来的。</p>\n<p>然而，为什么系统不能区分出这两种阻塞哪一种是真正的死循环而哪一种只是运算太慢了呢？因为。。。真的不能。。。区分。。。</p>\n<p>这种 “不能”，是数学意义上证明的，它就是不能。</p>\n<p>给出这个证明的是年仅24岁的计算机科学之父——艾伦·图灵，证明这个问题，这篇论文有近40页（<a href=\"http://www.cs.virginia.edu/~robins/Turing_Paper_1936.pdf\" target=\"_blank\" rel=\"external\">原文</a>），不过实际上的证明过程，只需要一张纸就能说明了。</p>\n<p>还是以刚刚演示的会死循环的程序为例，显然这个程序在 x=1 时发生死循环，我们记这个程序为 F(x)，当 x=1 时死循环。我们假设存在一个程序能判定程序是不是会死循环，我发这个程序叫 G(f,x)，指该程序可以判定程序f是否在输入x时会死循环。如果判定为死循环就返回1，正常运行就返回0。所以显然 G(F,1) = 1，G(F,2)=0。</p>\n<p>我们现在再构造一个更恶心的函数，它叫 T(f,x)，它内部会先运行 G(f,x)，如果发现 G(f,x) = 1 就正常退出，而如果  G(f,x)=0 时就让自己死循环。</p>\n<p>那么问题来了，T(T,x) 会不会死机呢？</p>\n<p>我们可以假设 T(T,x) 是不死机的，那么意味着 G(T,x) 返回的是1，而 G(T,x) 返回1的前提是 T(T,x) 是死机的，相矛盾，反之同样矛盾。由此证明，一个判断程序是否可能死机的函数  G(f,x) 不存在。</p>\n<p>这就是著名的图灵停机问题，在80年前还没有计算机的时候，图灵就证明了这个问题。</p>\n<p>不过图灵的这个证明恰好证明了另一个问题，那就是希尔伯特的23个问题。这是德国数学家大卫·希尔伯特（David Hilbert）于1900年在巴黎举行的第二届国际数学家大会上所提出23道最重要的数学问题中的第2个问题 —— 算术公理之相容性。这个问题其本质是希望找到一个方法证明任意公理系统的内部是不矛盾的。</p>\n<p>但实际上是事与愿违的，许多公理系统都是自相矛盾的。图灵的停机问题就是这样一种自相矛盾的一个证明。当然，一些更熟悉更易理解的问题其实也可以证明这样的问题。</p>\n<p>比如最常见的是 罗素悖论 的一个通俗描述，那就是 理发师悖论。一个理发师给所有不给自己理发的人理发，那么他给不给自己理发？这时候无论理还是不理，都是相矛盾的。</p>\n<p>罗素悖论的相对深入的通俗描述可以这么理解：比如一个集合：世界上所有描述它字数少于100字的集合都是这个集合的子集。这个描述本身是完备的，但显然这个集合本身也是自己的子集，并且这个集合包含的还不止有自己集合本身，意味着这个集合本身是自己的真子集，这就是非常荒谬而矛盾的了。</p>\n<p>无论图灵还是罗素提出的悖论都证明了我们的计算系统存在不完备的漏洞，然而 1931 年数学家库尔特·哥德尔给出了更为完整的证明，这个证明直接把这种不完备提升到了一个巨大的前提下：任何相容的形式系统，只要蕴涵皮亚诺算术公理，就可以在其中构造在体系中不能被证明的真命题，因此通过推演不能得到所有真命题（即体系是不完备的）。</p>\n<p>也就是说，任何形式的数学系统，只要包含关于自然数最最基础的公理：皮亚诺公理，那么它就是不完备的，如此残念。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我看到了它，却不敢相信它。 —— 康托尔</span><br></pre></td></tr></table></figure>\n","excerpt":"<p>当你看到窗口的标题栏上出现了 “没有响应” (No Responding) 四个字，电脑陷入了莫名的卡顿的时候，你一拍脑袋，大喝一声 “又死机了！” ，点下结束进程的你是否想过，这玩意，真的死机了吗？有时莫名卡顿了几分钟后，程序又莫名其妙恢复正常了。这又是什么情况呢？</p>","more":"<p>首先，我们先来理解一下，什么是 “没有响应”，<a href=\"http://windows.microsoft.com/zh-cn/windows-vista/what-does-it-mean-when-a-program-is-not-responding\">微软</a> 的官方帮助告诉我们：表示该程序与 Windows 的连接速度比平常慢，一般原因是程序中出现问题。如果我们深入理解一下的话，我们可以先考虑一下带窗口界面的程序通常的运行形式。</p>\n<p>一个程序通常可以拥有很多线程，意味着它可以同时干很多事。然而通常只有主线程是可以用来更新窗口上显示的内容的，别的线程只能在背后默默进行计算、网络通讯等其它工作。对于同一个线程，一次只能干一件事。主线程虽然更新界面，但大多数情况下，它也会进行一些运算。但如果这个线程长达数秒都迟迟无法更新界面，也就是说这个线程在运行某些内容时阻塞了，系统就会认为这是程序 “没有响应” 了。没有响应通常有两种可能性，第一种是程序运行出现了死循环，怎么也跑不出来了，这就是我们常说的死机。为了帮助大家理解这种 “死循环”，大家可以思考一下下面这个程序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一步：运行 1+x</span><br><span class=\"line\">第二步：如果上一步运行结果是2，那么重新运行第一步</span><br><span class=\"line\">第三步：显示结果</span><br></pre></td></tr></table></figure>\n<p>非常显然，当 x=1 时，这个程序将无限在一二步中循环，这就是传说中的死循环。死循环会导致主线程阻塞（如果这个运算在主线程执行的话）。这就会出现 “没有响应” 的情况。</p>\n<p>当然造成 “没有响应” 并不止这一种可能，另一种可能那就是主线程真的在执行某个计算很费时的运算。比如运算小于 10000000000000 的所有素数，这由于算的时间太长也会阻塞主线程，导致 “没有响应”。不过这种阻塞是暂时的，并不是真正的死循环，稍等片刻也是可以解出来的。</p>\n<p>然而，为什么系统不能区分出这两种阻塞哪一种是真正的死循环而哪一种只是运算太慢了呢？因为。。。真的不能。。。区分。。。</p>\n<p>这种 “不能”，是数学意义上证明的，它就是不能。</p>\n<p>给出这个证明的是年仅24岁的计算机科学之父——艾伦·图灵，证明这个问题，这篇论文有近40页（<a href=\"http://www.cs.virginia.edu/~robins/Turing_Paper_1936.pdf\">原文</a>），不过实际上的证明过程，只需要一张纸就能说明了。</p>\n<p>还是以刚刚演示的会死循环的程序为例，显然这个程序在 x=1 时发生死循环，我们记这个程序为 F(x)，当 x=1 时死循环。我们假设存在一个程序能判定程序是不是会死循环，我发这个程序叫 G(f,x)，指该程序可以判定程序f是否在输入x时会死循环。如果判定为死循环就返回1，正常运行就返回0。所以显然 G(F,1) = 1，G(F,2)=0。</p>\n<p>我们现在再构造一个更恶心的函数，它叫 T(f,x)，它内部会先运行 G(f,x)，如果发现 G(f,x) = 1 就正常退出，而如果  G(f,x)=0 时就让自己死循环。</p>\n<p>那么问题来了，T(T,x) 会不会死机呢？</p>\n<p>我们可以假设 T(T,x) 是不死机的，那么意味着 G(T,x) 返回的是1，而 G(T,x) 返回1的前提是 T(T,x) 是死机的，相矛盾，反之同样矛盾。由此证明，一个判断程序是否可能死机的函数  G(f,x) 不存在。</p>\n<p>这就是著名的图灵停机问题，在80年前还没有计算机的时候，图灵就证明了这个问题。</p>\n<p>不过图灵的这个证明恰好证明了另一个问题，那就是希尔伯特的23个问题。这是德国数学家大卫·希尔伯特（David Hilbert）于1900年在巴黎举行的第二届国际数学家大会上所提出23道最重要的数学问题中的第2个问题 —— 算术公理之相容性。这个问题其本质是希望找到一个方法证明任意公理系统的内部是不矛盾的。</p>\n<p>但实际上是事与愿违的，许多公理系统都是自相矛盾的。图灵的停机问题就是这样一种自相矛盾的一个证明。当然，一些更熟悉更易理解的问题其实也可以证明这样的问题。</p>\n<p>比如最常见的是 罗素悖论 的一个通俗描述，那就是 理发师悖论。一个理发师给所有不给自己理发的人理发，那么他给不给自己理发？这时候无论理还是不理，都是相矛盾的。</p>\n<p>罗素悖论的相对深入的通俗描述可以这么理解：比如一个集合：世界上所有描述它字数少于100字的集合都是这个集合的子集。这个描述本身是完备的，但显然这个集合本身也是自己的子集，并且这个集合包含的还不止有自己集合本身，意味着这个集合本身是自己的真子集，这就是非常荒谬而矛盾的了。</p>\n<p>无论图灵还是罗素提出的悖论都证明了我们的计算系统存在不完备的漏洞，然而 1931 年数学家库尔特·哥德尔给出了更为完整的证明，这个证明直接把这种不完备提升到了一个巨大的前提下：任何相容的形式系统，只要蕴涵皮亚诺算术公理，就可以在其中构造在体系中不能被证明的真命题，因此通过推演不能得到所有真命题（即体系是不完备的）。</p>\n<p>也就是说，任何形式的数学系统，只要包含关于自然数最最基础的公理：皮亚诺公理，那么它就是不完备的，如此残念。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我看到了它，却不敢相信它。 —— 康托尔</span><br></pre></td></tr></table></figure>"},{"title":"Nexus5 镜头进灰修复记","date":"2015-02-25T10:16:02.000Z","_content":"\n手上这台Nexus 5已经用了快要一年的时间了。大概三个月起摄像头画质出现了非常严重的问题。记得以前我们都说一个笑话：“Nexus 4的摄像头，哈哈哈哈哈哈哈哈”。 可是Nexus 5的摄像头还成啊，怎么突然画质变得这么糟糕呢。而且不是一般地糟糕，糟糕到几乎不能看的水平。我给大家上个图，大家感受一下。\n\n![](http://cdn.heckpsi.com/974_1.jpg)\n\n<!--more-->\n\n就算是前置摄像头也拍不成这雾蒙蒙的一片啊！对比度和锐度严重下降，画面糊成一团。如果画面内有光源，光源甚至还能拉出好几条线出来。一开始还没注意，越用越不对劲。显然不是软件上的问题，这一定是摄像头哪里出了事啊！\n\n于是默默看了一眼摄像头，保护玻璃上全部都是灰！理论上像这种一体式的手机进灰比起以前可开后盖的难度高了不少，进一两粒也可以理解，也不会影响画质，但是这大片大片的进灰就不对了。我打开闪光灯给大家看一下进灰有多严重。。。\n\n![](http://cdn.heckpsi.com/974_2.jpg)\n\n显然地，为了正常使用这块摄像头，必须要进行灰尘清理了。据之前 iFixit 做的 [拆机评测](https://www.ifixit.com/Teardown/Nexus+5+Teardown/19016)，显示只要不换屏幕，Nexus 5 的维修难度是极易的。那么我们就开始拆机维修吧。\n\n![](http://cdn.heckpsi.com/974_3.jpg)\n\n我并没有用塑料片打开后盖，因为找不到那么薄的塑料片......于是我用吸盘吸起了一个卡扣，然后用指甲一点点打开了后盖。使用吸盘是一个非常好用的拆机技巧。用来拆一体式后盖设计的机器非常方便。\n\n![](http://cdn.heckpsi.com/974_4.jpg)\n\n让人非常高兴的是，Nexus 5 的 NFC 天线并没有使用“飞线”来连接，而是使用了一组弹簧触片。这使得打开后盖后安装回去不需要用电烙铁焊回去，还是比较方便的。\n\n之前有人说用电吹风热档可以加热保护玻璃膨胀，然后直接从里面顶出来。答案是：不可以。事实上这样操作加热到 70°C 左右的时候玻璃依然不会掉出来，再加热上去可能会损坏其它元件，还是别这么干了。\n\n打开后盖后发现了，Nexus 5的保护玻璃并没有安装在后盖上，并不像 锤子 T1 那样后盖一开摄像元件就暴露在外面。同时，Nexus 5 的保护玻璃也没有单独安装在摄像元件的周围那么复杂。实际上保护玻璃是和散热中间件连在了一起，所以要想把保护玻璃取下，需要拆掉上半部分的中间件。\n\n不过这时候出现了一个问题，中间件是被一个 Y字螺丝 固定住的，而并不像下方扬声器是用 十字螺丝 固定的。我手上没有Y字螺丝刀，显然拆起来还挺费劲。\n\n![](http://cdn.heckpsi.com/974_5.jpg)\n\n不过发现我手上最小的 一字螺丝刀 正好能卡住这个 Y字螺丝的一条边，但转起来还是比较容易滑牙。一个比较方便的方法是按紧螺丝刀，然后旋转手机，就可以慢慢把螺丝卸下来。6个螺丝中有三个非常紧，而另外三个却很好拆，不知道是出于什么目的还是装配的问题弄成这样的。\n\n拆下所有螺丝后，用螺丝刀伸到中间件的背后，往外轻轻撬动，把卡扣撬开，中间件就连着保护玻璃一起下来了。\n\n![](http://cdn.heckpsi.com/974_6.jpg)\n\n拆下后用 气吹 分别清理摄像头元件上的细灰尘和表面玻璃背后的灰尘。清理完毕后安装回去。\n\n![](http://cdn.heckpsi.com/974_7.jpg)\n\n![](http://cdn.heckpsi.com/974_8.jpg)\n\n清理完后表面只能看到一些玻璃的划痕了，毕竟 Nexus 5 摄像头凸在外面，划痕不可避。把螺丝拧上背盖安装上开机完工。\n\n最后我们来看看清理灰尘前后拍出照片的对比吧。\n\n![](http://cdn.heckpsi.com/974_1.jpg)\n\n![](http://cdn.heckpsi.com/974_9.jpg) \n\n画质简直感人 QuQ\n\n至此，Nexus 5的摄像头恢复了正常的使用。Nexus 5的拆解还是比较容易的，但是这种易拆解的结构也确实导致了灰尘很容易进入，如果有遇到类似问题的同学，也不妨动动手，把这不能忍受的问题解决了吧。\n\n","source":"_posts/fix-nexus-5-lens.md","raw":"---\ntitle: Nexus5 镜头进灰修复记\ndate: 2015-02-25 18:16:02\ntags: [Nexus,硬件,维修]\n---\n\n手上这台Nexus 5已经用了快要一年的时间了。大概三个月起摄像头画质出现了非常严重的问题。记得以前我们都说一个笑话：“Nexus 4的摄像头，哈哈哈哈哈哈哈哈”。 可是Nexus 5的摄像头还成啊，怎么突然画质变得这么糟糕呢。而且不是一般地糟糕，糟糕到几乎不能看的水平。我给大家上个图，大家感受一下。\n\n![](http://cdn.heckpsi.com/974_1.jpg)\n\n<!--more-->\n\n就算是前置摄像头也拍不成这雾蒙蒙的一片啊！对比度和锐度严重下降，画面糊成一团。如果画面内有光源，光源甚至还能拉出好几条线出来。一开始还没注意，越用越不对劲。显然不是软件上的问题，这一定是摄像头哪里出了事啊！\n\n于是默默看了一眼摄像头，保护玻璃上全部都是灰！理论上像这种一体式的手机进灰比起以前可开后盖的难度高了不少，进一两粒也可以理解，也不会影响画质，但是这大片大片的进灰就不对了。我打开闪光灯给大家看一下进灰有多严重。。。\n\n![](http://cdn.heckpsi.com/974_2.jpg)\n\n显然地，为了正常使用这块摄像头，必须要进行灰尘清理了。据之前 iFixit 做的 [拆机评测](https://www.ifixit.com/Teardown/Nexus+5+Teardown/19016)，显示只要不换屏幕，Nexus 5 的维修难度是极易的。那么我们就开始拆机维修吧。\n\n![](http://cdn.heckpsi.com/974_3.jpg)\n\n我并没有用塑料片打开后盖，因为找不到那么薄的塑料片......于是我用吸盘吸起了一个卡扣，然后用指甲一点点打开了后盖。使用吸盘是一个非常好用的拆机技巧。用来拆一体式后盖设计的机器非常方便。\n\n![](http://cdn.heckpsi.com/974_4.jpg)\n\n让人非常高兴的是，Nexus 5 的 NFC 天线并没有使用“飞线”来连接，而是使用了一组弹簧触片。这使得打开后盖后安装回去不需要用电烙铁焊回去，还是比较方便的。\n\n之前有人说用电吹风热档可以加热保护玻璃膨胀，然后直接从里面顶出来。答案是：不可以。事实上这样操作加热到 70°C 左右的时候玻璃依然不会掉出来，再加热上去可能会损坏其它元件，还是别这么干了。\n\n打开后盖后发现了，Nexus 5的保护玻璃并没有安装在后盖上，并不像 锤子 T1 那样后盖一开摄像元件就暴露在外面。同时，Nexus 5 的保护玻璃也没有单独安装在摄像元件的周围那么复杂。实际上保护玻璃是和散热中间件连在了一起，所以要想把保护玻璃取下，需要拆掉上半部分的中间件。\n\n不过这时候出现了一个问题，中间件是被一个 Y字螺丝 固定住的，而并不像下方扬声器是用 十字螺丝 固定的。我手上没有Y字螺丝刀，显然拆起来还挺费劲。\n\n![](http://cdn.heckpsi.com/974_5.jpg)\n\n不过发现我手上最小的 一字螺丝刀 正好能卡住这个 Y字螺丝的一条边，但转起来还是比较容易滑牙。一个比较方便的方法是按紧螺丝刀，然后旋转手机，就可以慢慢把螺丝卸下来。6个螺丝中有三个非常紧，而另外三个却很好拆，不知道是出于什么目的还是装配的问题弄成这样的。\n\n拆下所有螺丝后，用螺丝刀伸到中间件的背后，往外轻轻撬动，把卡扣撬开，中间件就连着保护玻璃一起下来了。\n\n![](http://cdn.heckpsi.com/974_6.jpg)\n\n拆下后用 气吹 分别清理摄像头元件上的细灰尘和表面玻璃背后的灰尘。清理完毕后安装回去。\n\n![](http://cdn.heckpsi.com/974_7.jpg)\n\n![](http://cdn.heckpsi.com/974_8.jpg)\n\n清理完后表面只能看到一些玻璃的划痕了，毕竟 Nexus 5 摄像头凸在外面，划痕不可避。把螺丝拧上背盖安装上开机完工。\n\n最后我们来看看清理灰尘前后拍出照片的对比吧。\n\n![](http://cdn.heckpsi.com/974_1.jpg)\n\n![](http://cdn.heckpsi.com/974_9.jpg) \n\n画质简直感人 QuQ\n\n至此，Nexus 5的摄像头恢复了正常的使用。Nexus 5的拆解还是比较容易的，但是这种易拆解的结构也确实导致了灰尘很容易进入，如果有遇到类似问题的同学，也不妨动动手，把这不能忍受的问题解决了吧。\n\n","slug":"fix-nexus-5-lens","published":1,"updated":"2016-05-15T03:20:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscy008u000fpp8zadvwmnzo","content":"<p>手上这台Nexus 5已经用了快要一年的时间了。大概三个月起摄像头画质出现了非常严重的问题。记得以前我们都说一个笑话：“Nexus 4的摄像头，哈哈哈哈哈哈哈哈”。 可是Nexus 5的摄像头还成啊，怎么突然画质变得这么糟糕呢。而且不是一般地糟糕，糟糕到几乎不能看的水平。我给大家上个图，大家感受一下。</p>\n<p><img src=\"http://cdn.heckpsi.com/974_1.jpg\" alt=\"\"></p>\n<a id=\"more\"></a>\n<p>就算是前置摄像头也拍不成这雾蒙蒙的一片啊！对比度和锐度严重下降，画面糊成一团。如果画面内有光源，光源甚至还能拉出好几条线出来。一开始还没注意，越用越不对劲。显然不是软件上的问题，这一定是摄像头哪里出了事啊！</p>\n<p>于是默默看了一眼摄像头，保护玻璃上全部都是灰！理论上像这种一体式的手机进灰比起以前可开后盖的难度高了不少，进一两粒也可以理解，也不会影响画质，但是这大片大片的进灰就不对了。我打开闪光灯给大家看一下进灰有多严重。。。</p>\n<p><img src=\"http://cdn.heckpsi.com/974_2.jpg\" alt=\"\"></p>\n<p>显然地，为了正常使用这块摄像头，必须要进行灰尘清理了。据之前 iFixit 做的 <a href=\"https://www.ifixit.com/Teardown/Nexus+5+Teardown/19016\" target=\"_blank\" rel=\"external\">拆机评测</a>，显示只要不换屏幕，Nexus 5 的维修难度是极易的。那么我们就开始拆机维修吧。</p>\n<p><img src=\"http://cdn.heckpsi.com/974_3.jpg\" alt=\"\"></p>\n<p>我并没有用塑料片打开后盖，因为找不到那么薄的塑料片……于是我用吸盘吸起了一个卡扣，然后用指甲一点点打开了后盖。使用吸盘是一个非常好用的拆机技巧。用来拆一体式后盖设计的机器非常方便。</p>\n<p><img src=\"http://cdn.heckpsi.com/974_4.jpg\" alt=\"\"></p>\n<p>让人非常高兴的是，Nexus 5 的 NFC 天线并没有使用“飞线”来连接，而是使用了一组弹簧触片。这使得打开后盖后安装回去不需要用电烙铁焊回去，还是比较方便的。</p>\n<p>之前有人说用电吹风热档可以加热保护玻璃膨胀，然后直接从里面顶出来。答案是：不可以。事实上这样操作加热到 70°C 左右的时候玻璃依然不会掉出来，再加热上去可能会损坏其它元件，还是别这么干了。</p>\n<p>打开后盖后发现了，Nexus 5的保护玻璃并没有安装在后盖上，并不像 锤子 T1 那样后盖一开摄像元件就暴露在外面。同时，Nexus 5 的保护玻璃也没有单独安装在摄像元件的周围那么复杂。实际上保护玻璃是和散热中间件连在了一起，所以要想把保护玻璃取下，需要拆掉上半部分的中间件。</p>\n<p>不过这时候出现了一个问题，中间件是被一个 Y字螺丝 固定住的，而并不像下方扬声器是用 十字螺丝 固定的。我手上没有Y字螺丝刀，显然拆起来还挺费劲。</p>\n<p><img src=\"http://cdn.heckpsi.com/974_5.jpg\" alt=\"\"></p>\n<p>不过发现我手上最小的 一字螺丝刀 正好能卡住这个 Y字螺丝的一条边，但转起来还是比较容易滑牙。一个比较方便的方法是按紧螺丝刀，然后旋转手机，就可以慢慢把螺丝卸下来。6个螺丝中有三个非常紧，而另外三个却很好拆，不知道是出于什么目的还是装配的问题弄成这样的。</p>\n<p>拆下所有螺丝后，用螺丝刀伸到中间件的背后，往外轻轻撬动，把卡扣撬开，中间件就连着保护玻璃一起下来了。</p>\n<p><img src=\"http://cdn.heckpsi.com/974_6.jpg\" alt=\"\"></p>\n<p>拆下后用 气吹 分别清理摄像头元件上的细灰尘和表面玻璃背后的灰尘。清理完毕后安装回去。</p>\n<p><img src=\"http://cdn.heckpsi.com/974_7.jpg\" alt=\"\"></p>\n<p><img src=\"http://cdn.heckpsi.com/974_8.jpg\" alt=\"\"></p>\n<p>清理完后表面只能看到一些玻璃的划痕了，毕竟 Nexus 5 摄像头凸在外面，划痕不可避。把螺丝拧上背盖安装上开机完工。</p>\n<p>最后我们来看看清理灰尘前后拍出照片的对比吧。</p>\n<p><img src=\"http://cdn.heckpsi.com/974_1.jpg\" alt=\"\"></p>\n<p><img src=\"http://cdn.heckpsi.com/974_9.jpg\" alt=\"\"> </p>\n<p>画质简直感人 QuQ</p>\n<p>至此，Nexus 5的摄像头恢复了正常的使用。Nexus 5的拆解还是比较容易的，但是这种易拆解的结构也确实导致了灰尘很容易进入，如果有遇到类似问题的同学，也不妨动动手，把这不能忍受的问题解决了吧。</p>\n","excerpt":"<p>手上这台Nexus 5已经用了快要一年的时间了。大概三个月起摄像头画质出现了非常严重的问题。记得以前我们都说一个笑话：“Nexus 4的摄像头，哈哈哈哈哈哈哈哈”。 可是Nexus 5的摄像头还成啊，怎么突然画质变得这么糟糕呢。而且不是一般地糟糕，糟糕到几乎不能看的水平。我给大家上个图，大家感受一下。</p>\n<p><img src=\"http://cdn.heckpsi.com/974_1.jpg\" alt=\"\"></p>","more":"<p>就算是前置摄像头也拍不成这雾蒙蒙的一片啊！对比度和锐度严重下降，画面糊成一团。如果画面内有光源，光源甚至还能拉出好几条线出来。一开始还没注意，越用越不对劲。显然不是软件上的问题，这一定是摄像头哪里出了事啊！</p>\n<p>于是默默看了一眼摄像头，保护玻璃上全部都是灰！理论上像这种一体式的手机进灰比起以前可开后盖的难度高了不少，进一两粒也可以理解，也不会影响画质，但是这大片大片的进灰就不对了。我打开闪光灯给大家看一下进灰有多严重。。。</p>\n<p><img src=\"http://cdn.heckpsi.com/974_2.jpg\" alt=\"\"></p>\n<p>显然地，为了正常使用这块摄像头，必须要进行灰尘清理了。据之前 iFixit 做的 <a href=\"https://www.ifixit.com/Teardown/Nexus+5+Teardown/19016\">拆机评测</a>，显示只要不换屏幕，Nexus 5 的维修难度是极易的。那么我们就开始拆机维修吧。</p>\n<p><img src=\"http://cdn.heckpsi.com/974_3.jpg\" alt=\"\"></p>\n<p>我并没有用塑料片打开后盖，因为找不到那么薄的塑料片……于是我用吸盘吸起了一个卡扣，然后用指甲一点点打开了后盖。使用吸盘是一个非常好用的拆机技巧。用来拆一体式后盖设计的机器非常方便。</p>\n<p><img src=\"http://cdn.heckpsi.com/974_4.jpg\" alt=\"\"></p>\n<p>让人非常高兴的是，Nexus 5 的 NFC 天线并没有使用“飞线”来连接，而是使用了一组弹簧触片。这使得打开后盖后安装回去不需要用电烙铁焊回去，还是比较方便的。</p>\n<p>之前有人说用电吹风热档可以加热保护玻璃膨胀，然后直接从里面顶出来。答案是：不可以。事实上这样操作加热到 70°C 左右的时候玻璃依然不会掉出来，再加热上去可能会损坏其它元件，还是别这么干了。</p>\n<p>打开后盖后发现了，Nexus 5的保护玻璃并没有安装在后盖上，并不像 锤子 T1 那样后盖一开摄像元件就暴露在外面。同时，Nexus 5 的保护玻璃也没有单独安装在摄像元件的周围那么复杂。实际上保护玻璃是和散热中间件连在了一起，所以要想把保护玻璃取下，需要拆掉上半部分的中间件。</p>\n<p>不过这时候出现了一个问题，中间件是被一个 Y字螺丝 固定住的，而并不像下方扬声器是用 十字螺丝 固定的。我手上没有Y字螺丝刀，显然拆起来还挺费劲。</p>\n<p><img src=\"http://cdn.heckpsi.com/974_5.jpg\" alt=\"\"></p>\n<p>不过发现我手上最小的 一字螺丝刀 正好能卡住这个 Y字螺丝的一条边，但转起来还是比较容易滑牙。一个比较方便的方法是按紧螺丝刀，然后旋转手机，就可以慢慢把螺丝卸下来。6个螺丝中有三个非常紧，而另外三个却很好拆，不知道是出于什么目的还是装配的问题弄成这样的。</p>\n<p>拆下所有螺丝后，用螺丝刀伸到中间件的背后，往外轻轻撬动，把卡扣撬开，中间件就连着保护玻璃一起下来了。</p>\n<p><img src=\"http://cdn.heckpsi.com/974_6.jpg\" alt=\"\"></p>\n<p>拆下后用 气吹 分别清理摄像头元件上的细灰尘和表面玻璃背后的灰尘。清理完毕后安装回去。</p>\n<p><img src=\"http://cdn.heckpsi.com/974_7.jpg\" alt=\"\"></p>\n<p><img src=\"http://cdn.heckpsi.com/974_8.jpg\" alt=\"\"></p>\n<p>清理完后表面只能看到一些玻璃的划痕了，毕竟 Nexus 5 摄像头凸在外面，划痕不可避。把螺丝拧上背盖安装上开机完工。</p>\n<p>最后我们来看看清理灰尘前后拍出照片的对比吧。</p>\n<p><img src=\"http://cdn.heckpsi.com/974_1.jpg\" alt=\"\"></p>\n<p><img src=\"http://cdn.heckpsi.com/974_9.jpg\" alt=\"\"> </p>\n<p>画质简直感人 QuQ</p>\n<p>至此，Nexus 5的摄像头恢复了正常的使用。Nexus 5的拆解还是比较容易的，但是这种易拆解的结构也确实导致了灰尘很容易进入，如果有遇到类似问题的同学，也不妨动动手，把这不能忍受的问题解决了吧。</p>"},{"title":"情理之中，意料之外——简评Google I/O 2014","date":"2014-06-25T12:04:05.000Z","_content":"\n```\n本文所涉及的主要是太平洋时间 6 月 24 日早上 9 点到 11 点的 Keynote 活动，也就是大家最为关心的发布会的相关内容的评价。\n至于其他活动，我将就几个有转播的且有意思的活动额外写一些Review。\n```\n\n如果说今天凌晨对于许多人最大的纠结之处莫过于是看 Google I/O 大会还是世界杯了。显然，我开了两个屏幕都在看......不过，Youtube 作为谷歌的亲儿子承接了 Google I/O 的直播工作，虽然无论是清晰度还是流畅程度都非常的优秀，但是......对于中国大陆用户而言，恐怕看起来就比较困难了......\n\n<!--more-->\n\n作为这种发布会的传统，Google 开始用数据来喷竞争对手。毫无疑问，Android 设备的出货量是远大于 iOS 设备的，所以各种数据规模也不是 Apple 能比的。其实数据这东西本来就是在吹牛，拿来演示的数据永远是有利的。就像 Apple 和 Microsoft 比桌面设备的时候就喜欢比增长率（想想Windows的总量是你比得过？）。Apple 和 Google 比移动端的时候就喜欢比碎片化（Android 的出货量和增长率是你比得过？）。所以当 Google 拿数据说话的时候，恩就是出货量和增长率。但是 Google 在碎片化上这次举了一个有意思的数据。虽然 Kitkat 的市场占有率只有 15%，但是 93% 使用 Google 服务的用户，都已经把 Google Services 的套件更新到了最新。这意味着，虽然系统版本号没有完全跟上，但 Google 用应用的形式能尽力拉进各个版本之间的区别。这一点可以说是曲线救国的方法。不过大家别看这几家大公司嘴炮来嘴炮去的，其实一个都离不开，他们的业务是互相依赖的，这个真的就是打嘴炮而已。\n\n### 然后，发布会正式开始发布内容。\n\n第一个登场的是 Android One。这是一款硬件产品。其作用类似于 Nexus 的标杆作用，不过它是针对低端市场的。Android One 拥有一块4.5英寸的屏幕，双卡双待，支持 SD卡拓展和 FM 收音机。其针对的是发展中国家，售价低于 100 美元。希望能更好地规范安卓在低端市场的表现，而不是现在安卓机器低端市场乱成一锅粥的局面。这款手机最快将于今年秋天在印度发售。它的标杆意义确实能规范一些市场行为，希望能带来一些积极的作用。但和 Nexus 一样，这款手机在中国上市的可能性为 0，因为它还搭载完整的 Google 服务。\n\n接下来登场的是 L。什么是 L 呢？也就是之前疯传的 Android 5.0。至于是不是 5.0 呢，Google 也没承认，也没否认。它的开发代号是 L。全新的 UI 将扁平化和卡片式设计进一步贯彻了下去，并进一步柔化了界面的边缘。Google 向我们展示了一些应用，并且承诺，许多应用都会在不久之后就会发生这样的改变。开发人员在开发过程中通过一些简单的代码就能很好的创建这样的 UI，大大简化了设计成本。(除了设计上的变化，L 将把 ART 作为默认模式，并且进一步优化了 ART 的执行效率。加入了省电模式，更好处理续航。系统更新将由Play市场提供。（PS：昨天凌晨写稿的时候居然漏了......）但是L系统何时发布，并没有公布。\n\nGoogle 这时给出了一个数据，说 Chrome 的 30 天活跃用户的数量已经超过了 3 亿，加上之前说 Android 的 30 天活跃用户超过了 10 亿。下一步 Google 必然将整合这些资源，统一体验。接下来，Google 给我们演示了全新的 ChromeOS 在令人吃惊的整合能力。记得前不久 WWDC 2014 上苹果展示 Mac OS X 的整合能力已经很恐怖了。而 ChromeOS 的能力除了不能用电脑打电话外，简直是有过之而无不及。手机没电了电脑会提醒你这些已经是小事了。更可怕的是，ChromeOS上可以运行所有的Android应用（演示起来非常非常流畅）。你甚至可以在ChromeOS上刷Flipboard。手机内容可以随时投屏到电脑上，所有的，所有的信息都能得到同步。最后，Android将会在新版本中区分工作模式和家庭模式，两者应用和数据完全独立。可以确保你使用一个设备，管理好两者关系，又能保证安全性。\n\n### Android TV、Android Auto、Android Wear\n\n这三个安卓定制版本分别针对的是智能电视、汽车导航和可穿戴式设备。Android TV的最大亮点在于其背后强大的搜索支持。要找一个节目直接语音说出来就好了。Google的自然语义分析和知识图谱将自动将你语句中要找的内容分析出来，将结果搜索出来。非常方便。\n\nAndroid Auto基于最新的 Android L 系统，并且置入了Google Now，这使得它不仅支持语音命令，还可以根据你当前汽车行进的情况，将信息在你需要的时间呈现给你。同时，可以读取所有手机上的数据，让你在开车时不受到手机的束缚，安心驾驶。而且 Google 的 TTS 的发音还是比较接近人声的，比起 CarPlay 上那个机械一样的声音不知道高到哪里去。同时开放了 Android Auto SDK，第三方开发者可以进一步进行开发应用。\n\n而至于 Android Wear，由于早先已经公布了具体相关标准，并不是很惊喜。Android Wear 标准的出现，也使得可穿戴式设备在发展初期就有一定的规范，有利于 Google 的长期影响。相当有意思的是，Android Wear 可以控制 Android TV。比起什么找不到遥控器用手机控制，用手表这种拴在手上的东西才更靠谱吧。同时，两款 Android Wear设备 LG G Watch 和 Galaxy Gear (Android Wear 版) 将于今天再 Google Play 上开售，而 Moto 360 (圆形屏幕更像表而不像玩具) 将于夏天开售。\n\n### Google Cloud Platform\n\n接下来说的就是 Google Cloud Platform。新的云服务提供了一套更好的开发工具和调试环境，大大简化了工作难度。如果说 Swift 语言更像玩具的话，Google 提供的这些改变更像瑞士军刀。刀刀是完全的实用主义。对于大数据分析，数据的监控，云开发的在线修改，在线调试是拿来就能用的东西。其中非常有意思的是对世界杯大数据的分析。许多国内大数据团队也在做类似的东西。但大多需要网民的主观参与，比如投票。而 Google 做的 Example 确是主动收集整个互联网上的数据（比如 Twitter）来分析。这入手点的不同直接看出了 Google 的大数据的意识。所以我一直说，中国这些大数据部门，只不过是数据部门换了个招牌罢了。\n\n另外，Google 在健康领域开始测试 Google Fit Platform。许多人曾质疑它和 Apple Healthkit 的相似性不过还是有点区别的。Healthkit 的应用和设备是一一对应的。每个厂商开发设备为自己的应用服务。而 Google Fit 更像是一种共享模式。数据和处理分离了开来。这个设备能提供这样的数据，别的应用也可以来调用。看起来更为合理一些。但是考虑到健康应用尚处于萌芽状态，是不是真的有用，还是只是一句空头支票不得而知。\n\n最后，说说我看完后的总体感受。发布会里面的大多数的东西之前都是略有听闻了的。但是 Google 还是给我们带来了许多惊喜。比如大家都知道了 GCP 的大数据处理能力，但是 Google 却能在大数据上给我们一个不同的思路。比如我们都知道 Google 要发 Android Wear、TV，但却很难想象，他们能将其整合。同样是整合，我们又很难想象 ChromeOS 的整合能达到如此高的程度。\n\n对比 WWDC 来看，其实 WWDC2014 虽然不是很优秀，但也不差。不过因为提前泄露了很多内容，让人有些失望。这是因为苹果在乔布斯死后把每次发布会的重点往往在几个点上，一旦泄露了就什么也没有了。而 Google I/O 能把优势保持在思路上，这使得只言片语的泄露不能造成很大的影响。再加上 Google 能做的许多创新都基于其强大的搜索功底，这是别的厂商根本做不到的，是别人想都不敢想的。所以说，厚积而薄发，Google 这些创新看似轻描淡写的不断涌出，也确实给其他互联网公司一些启示。要做真正的互联网巨头，究竟是要把什么作为根本呢？\n\n```\n另外，Google 今天股票大涨，Apple 股票虽然没有大跌，但也没有跟上大盘的涨幅。\nWWDC 开完 Apple 股票跌，Google 股票涨，Google I/O 开完还是 Apple 股票跌，Google 股票涨的事也不是第一次发生了。\n```\n\n\n\n","source":"_posts/google-io-2014.md","raw":"---\ntitle: 情理之中，意料之外——简评Google I/O 2014\ndate: 2014-06-25 20:04:05\ntags: [Google]\n---\n\n```\n本文所涉及的主要是太平洋时间 6 月 24 日早上 9 点到 11 点的 Keynote 活动，也就是大家最为关心的发布会的相关内容的评价。\n至于其他活动，我将就几个有转播的且有意思的活动额外写一些Review。\n```\n\n如果说今天凌晨对于许多人最大的纠结之处莫过于是看 Google I/O 大会还是世界杯了。显然，我开了两个屏幕都在看......不过，Youtube 作为谷歌的亲儿子承接了 Google I/O 的直播工作，虽然无论是清晰度还是流畅程度都非常的优秀，但是......对于中国大陆用户而言，恐怕看起来就比较困难了......\n\n<!--more-->\n\n作为这种发布会的传统，Google 开始用数据来喷竞争对手。毫无疑问，Android 设备的出货量是远大于 iOS 设备的，所以各种数据规模也不是 Apple 能比的。其实数据这东西本来就是在吹牛，拿来演示的数据永远是有利的。就像 Apple 和 Microsoft 比桌面设备的时候就喜欢比增长率（想想Windows的总量是你比得过？）。Apple 和 Google 比移动端的时候就喜欢比碎片化（Android 的出货量和增长率是你比得过？）。所以当 Google 拿数据说话的时候，恩就是出货量和增长率。但是 Google 在碎片化上这次举了一个有意思的数据。虽然 Kitkat 的市场占有率只有 15%，但是 93% 使用 Google 服务的用户，都已经把 Google Services 的套件更新到了最新。这意味着，虽然系统版本号没有完全跟上，但 Google 用应用的形式能尽力拉进各个版本之间的区别。这一点可以说是曲线救国的方法。不过大家别看这几家大公司嘴炮来嘴炮去的，其实一个都离不开，他们的业务是互相依赖的，这个真的就是打嘴炮而已。\n\n### 然后，发布会正式开始发布内容。\n\n第一个登场的是 Android One。这是一款硬件产品。其作用类似于 Nexus 的标杆作用，不过它是针对低端市场的。Android One 拥有一块4.5英寸的屏幕，双卡双待，支持 SD卡拓展和 FM 收音机。其针对的是发展中国家，售价低于 100 美元。希望能更好地规范安卓在低端市场的表现，而不是现在安卓机器低端市场乱成一锅粥的局面。这款手机最快将于今年秋天在印度发售。它的标杆意义确实能规范一些市场行为，希望能带来一些积极的作用。但和 Nexus 一样，这款手机在中国上市的可能性为 0，因为它还搭载完整的 Google 服务。\n\n接下来登场的是 L。什么是 L 呢？也就是之前疯传的 Android 5.0。至于是不是 5.0 呢，Google 也没承认，也没否认。它的开发代号是 L。全新的 UI 将扁平化和卡片式设计进一步贯彻了下去，并进一步柔化了界面的边缘。Google 向我们展示了一些应用，并且承诺，许多应用都会在不久之后就会发生这样的改变。开发人员在开发过程中通过一些简单的代码就能很好的创建这样的 UI，大大简化了设计成本。(除了设计上的变化，L 将把 ART 作为默认模式，并且进一步优化了 ART 的执行效率。加入了省电模式，更好处理续航。系统更新将由Play市场提供。（PS：昨天凌晨写稿的时候居然漏了......）但是L系统何时发布，并没有公布。\n\nGoogle 这时给出了一个数据，说 Chrome 的 30 天活跃用户的数量已经超过了 3 亿，加上之前说 Android 的 30 天活跃用户超过了 10 亿。下一步 Google 必然将整合这些资源，统一体验。接下来，Google 给我们演示了全新的 ChromeOS 在令人吃惊的整合能力。记得前不久 WWDC 2014 上苹果展示 Mac OS X 的整合能力已经很恐怖了。而 ChromeOS 的能力除了不能用电脑打电话外，简直是有过之而无不及。手机没电了电脑会提醒你这些已经是小事了。更可怕的是，ChromeOS上可以运行所有的Android应用（演示起来非常非常流畅）。你甚至可以在ChromeOS上刷Flipboard。手机内容可以随时投屏到电脑上，所有的，所有的信息都能得到同步。最后，Android将会在新版本中区分工作模式和家庭模式，两者应用和数据完全独立。可以确保你使用一个设备，管理好两者关系，又能保证安全性。\n\n### Android TV、Android Auto、Android Wear\n\n这三个安卓定制版本分别针对的是智能电视、汽车导航和可穿戴式设备。Android TV的最大亮点在于其背后强大的搜索支持。要找一个节目直接语音说出来就好了。Google的自然语义分析和知识图谱将自动将你语句中要找的内容分析出来，将结果搜索出来。非常方便。\n\nAndroid Auto基于最新的 Android L 系统，并且置入了Google Now，这使得它不仅支持语音命令，还可以根据你当前汽车行进的情况，将信息在你需要的时间呈现给你。同时，可以读取所有手机上的数据，让你在开车时不受到手机的束缚，安心驾驶。而且 Google 的 TTS 的发音还是比较接近人声的，比起 CarPlay 上那个机械一样的声音不知道高到哪里去。同时开放了 Android Auto SDK，第三方开发者可以进一步进行开发应用。\n\n而至于 Android Wear，由于早先已经公布了具体相关标准，并不是很惊喜。Android Wear 标准的出现，也使得可穿戴式设备在发展初期就有一定的规范，有利于 Google 的长期影响。相当有意思的是，Android Wear 可以控制 Android TV。比起什么找不到遥控器用手机控制，用手表这种拴在手上的东西才更靠谱吧。同时，两款 Android Wear设备 LG G Watch 和 Galaxy Gear (Android Wear 版) 将于今天再 Google Play 上开售，而 Moto 360 (圆形屏幕更像表而不像玩具) 将于夏天开售。\n\n### Google Cloud Platform\n\n接下来说的就是 Google Cloud Platform。新的云服务提供了一套更好的开发工具和调试环境，大大简化了工作难度。如果说 Swift 语言更像玩具的话，Google 提供的这些改变更像瑞士军刀。刀刀是完全的实用主义。对于大数据分析，数据的监控，云开发的在线修改，在线调试是拿来就能用的东西。其中非常有意思的是对世界杯大数据的分析。许多国内大数据团队也在做类似的东西。但大多需要网民的主观参与，比如投票。而 Google 做的 Example 确是主动收集整个互联网上的数据（比如 Twitter）来分析。这入手点的不同直接看出了 Google 的大数据的意识。所以我一直说，中国这些大数据部门，只不过是数据部门换了个招牌罢了。\n\n另外，Google 在健康领域开始测试 Google Fit Platform。许多人曾质疑它和 Apple Healthkit 的相似性不过还是有点区别的。Healthkit 的应用和设备是一一对应的。每个厂商开发设备为自己的应用服务。而 Google Fit 更像是一种共享模式。数据和处理分离了开来。这个设备能提供这样的数据，别的应用也可以来调用。看起来更为合理一些。但是考虑到健康应用尚处于萌芽状态，是不是真的有用，还是只是一句空头支票不得而知。\n\n最后，说说我看完后的总体感受。发布会里面的大多数的东西之前都是略有听闻了的。但是 Google 还是给我们带来了许多惊喜。比如大家都知道了 GCP 的大数据处理能力，但是 Google 却能在大数据上给我们一个不同的思路。比如我们都知道 Google 要发 Android Wear、TV，但却很难想象，他们能将其整合。同样是整合，我们又很难想象 ChromeOS 的整合能达到如此高的程度。\n\n对比 WWDC 来看，其实 WWDC2014 虽然不是很优秀，但也不差。不过因为提前泄露了很多内容，让人有些失望。这是因为苹果在乔布斯死后把每次发布会的重点往往在几个点上，一旦泄露了就什么也没有了。而 Google I/O 能把优势保持在思路上，这使得只言片语的泄露不能造成很大的影响。再加上 Google 能做的许多创新都基于其强大的搜索功底，这是别的厂商根本做不到的，是别人想都不敢想的。所以说，厚积而薄发，Google 这些创新看似轻描淡写的不断涌出，也确实给其他互联网公司一些启示。要做真正的互联网巨头，究竟是要把什么作为根本呢？\n\n```\n另外，Google 今天股票大涨，Apple 股票虽然没有大跌，但也没有跟上大盘的涨幅。\nWWDC 开完 Apple 股票跌，Google 股票涨，Google I/O 开完还是 Apple 股票跌，Google 股票涨的事也不是第一次发生了。\n```\n\n\n\n","slug":"google-io-2014","published":1,"updated":"2016-04-22T07:00:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscy008v000gpp8zls8474cc","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">本文所涉及的主要是太平洋时间 6 月 24 日早上 9 点到 11 点的 Keynote 活动，也就是大家最为关心的发布会的相关内容的评价。</span><br><span class=\"line\">至于其他活动，我将就几个有转播的且有意思的活动额外写一些Review。</span><br></pre></td></tr></table></figure>\n<p>如果说今天凌晨对于许多人最大的纠结之处莫过于是看 Google I/O 大会还是世界杯了。显然，我开了两个屏幕都在看……不过，Youtube 作为谷歌的亲儿子承接了 Google I/O 的直播工作，虽然无论是清晰度还是流畅程度都非常的优秀，但是……对于中国大陆用户而言，恐怕看起来就比较困难了……</p>\n<a id=\"more\"></a>\n<p>作为这种发布会的传统，Google 开始用数据来喷竞争对手。毫无疑问，Android 设备的出货量是远大于 iOS 设备的，所以各种数据规模也不是 Apple 能比的。其实数据这东西本来就是在吹牛，拿来演示的数据永远是有利的。就像 Apple 和 Microsoft 比桌面设备的时候就喜欢比增长率（想想Windows的总量是你比得过？）。Apple 和 Google 比移动端的时候就喜欢比碎片化（Android 的出货量和增长率是你比得过？）。所以当 Google 拿数据说话的时候，恩就是出货量和增长率。但是 Google 在碎片化上这次举了一个有意思的数据。虽然 Kitkat 的市场占有率只有 15%，但是 93% 使用 Google 服务的用户，都已经把 Google Services 的套件更新到了最新。这意味着，虽然系统版本号没有完全跟上，但 Google 用应用的形式能尽力拉进各个版本之间的区别。这一点可以说是曲线救国的方法。不过大家别看这几家大公司嘴炮来嘴炮去的，其实一个都离不开，他们的业务是互相依赖的，这个真的就是打嘴炮而已。</p>\n<h3 id=\"然后，发布会正式开始发布内容。\"><a href=\"#然后，发布会正式开始发布内容。\" class=\"headerlink\" title=\"然后，发布会正式开始发布内容。\"></a>然后，发布会正式开始发布内容。</h3><p>第一个登场的是 Android One。这是一款硬件产品。其作用类似于 Nexus 的标杆作用，不过它是针对低端市场的。Android One 拥有一块4.5英寸的屏幕，双卡双待，支持 SD卡拓展和 FM 收音机。其针对的是发展中国家，售价低于 100 美元。希望能更好地规范安卓在低端市场的表现，而不是现在安卓机器低端市场乱成一锅粥的局面。这款手机最快将于今年秋天在印度发售。它的标杆意义确实能规范一些市场行为，希望能带来一些积极的作用。但和 Nexus 一样，这款手机在中国上市的可能性为 0，因为它还搭载完整的 Google 服务。</p>\n<p>接下来登场的是 L。什么是 L 呢？也就是之前疯传的 Android 5.0。至于是不是 5.0 呢，Google 也没承认，也没否认。它的开发代号是 L。全新的 UI 将扁平化和卡片式设计进一步贯彻了下去，并进一步柔化了界面的边缘。Google 向我们展示了一些应用，并且承诺，许多应用都会在不久之后就会发生这样的改变。开发人员在开发过程中通过一些简单的代码就能很好的创建这样的 UI，大大简化了设计成本。(除了设计上的变化，L 将把 ART 作为默认模式，并且进一步优化了 ART 的执行效率。加入了省电模式，更好处理续航。系统更新将由Play市场提供。（PS：昨天凌晨写稿的时候居然漏了……）但是L系统何时发布，并没有公布。</p>\n<p>Google 这时给出了一个数据，说 Chrome 的 30 天活跃用户的数量已经超过了 3 亿，加上之前说 Android 的 30 天活跃用户超过了 10 亿。下一步 Google 必然将整合这些资源，统一体验。接下来，Google 给我们演示了全新的 ChromeOS 在令人吃惊的整合能力。记得前不久 WWDC 2014 上苹果展示 Mac OS X 的整合能力已经很恐怖了。而 ChromeOS 的能力除了不能用电脑打电话外，简直是有过之而无不及。手机没电了电脑会提醒你这些已经是小事了。更可怕的是，ChromeOS上可以运行所有的Android应用（演示起来非常非常流畅）。你甚至可以在ChromeOS上刷Flipboard。手机内容可以随时投屏到电脑上，所有的，所有的信息都能得到同步。最后，Android将会在新版本中区分工作模式和家庭模式，两者应用和数据完全独立。可以确保你使用一个设备，管理好两者关系，又能保证安全性。</p>\n<h3 id=\"Android-TV、Android-Auto、Android-Wear\"><a href=\"#Android-TV、Android-Auto、Android-Wear\" class=\"headerlink\" title=\"Android TV、Android Auto、Android Wear\"></a>Android TV、Android Auto、Android Wear</h3><p>这三个安卓定制版本分别针对的是智能电视、汽车导航和可穿戴式设备。Android TV的最大亮点在于其背后强大的搜索支持。要找一个节目直接语音说出来就好了。Google的自然语义分析和知识图谱将自动将你语句中要找的内容分析出来，将结果搜索出来。非常方便。</p>\n<p>Android Auto基于最新的 Android L 系统，并且置入了Google Now，这使得它不仅支持语音命令，还可以根据你当前汽车行进的情况，将信息在你需要的时间呈现给你。同时，可以读取所有手机上的数据，让你在开车时不受到手机的束缚，安心驾驶。而且 Google 的 TTS 的发音还是比较接近人声的，比起 CarPlay 上那个机械一样的声音不知道高到哪里去。同时开放了 Android Auto SDK，第三方开发者可以进一步进行开发应用。</p>\n<p>而至于 Android Wear，由于早先已经公布了具体相关标准，并不是很惊喜。Android Wear 标准的出现，也使得可穿戴式设备在发展初期就有一定的规范，有利于 Google 的长期影响。相当有意思的是，Android Wear 可以控制 Android TV。比起什么找不到遥控器用手机控制，用手表这种拴在手上的东西才更靠谱吧。同时，两款 Android Wear设备 LG G Watch 和 Galaxy Gear (Android Wear 版) 将于今天再 Google Play 上开售，而 Moto 360 (圆形屏幕更像表而不像玩具) 将于夏天开售。</p>\n<h3 id=\"Google-Cloud-Platform\"><a href=\"#Google-Cloud-Platform\" class=\"headerlink\" title=\"Google Cloud Platform\"></a>Google Cloud Platform</h3><p>接下来说的就是 Google Cloud Platform。新的云服务提供了一套更好的开发工具和调试环境，大大简化了工作难度。如果说 Swift 语言更像玩具的话，Google 提供的这些改变更像瑞士军刀。刀刀是完全的实用主义。对于大数据分析，数据的监控，云开发的在线修改，在线调试是拿来就能用的东西。其中非常有意思的是对世界杯大数据的分析。许多国内大数据团队也在做类似的东西。但大多需要网民的主观参与，比如投票。而 Google 做的 Example 确是主动收集整个互联网上的数据（比如 Twitter）来分析。这入手点的不同直接看出了 Google 的大数据的意识。所以我一直说，中国这些大数据部门，只不过是数据部门换了个招牌罢了。</p>\n<p>另外，Google 在健康领域开始测试 Google Fit Platform。许多人曾质疑它和 Apple Healthkit 的相似性不过还是有点区别的。Healthkit 的应用和设备是一一对应的。每个厂商开发设备为自己的应用服务。而 Google Fit 更像是一种共享模式。数据和处理分离了开来。这个设备能提供这样的数据，别的应用也可以来调用。看起来更为合理一些。但是考虑到健康应用尚处于萌芽状态，是不是真的有用，还是只是一句空头支票不得而知。</p>\n<p>最后，说说我看完后的总体感受。发布会里面的大多数的东西之前都是略有听闻了的。但是 Google 还是给我们带来了许多惊喜。比如大家都知道了 GCP 的大数据处理能力，但是 Google 却能在大数据上给我们一个不同的思路。比如我们都知道 Google 要发 Android Wear、TV，但却很难想象，他们能将其整合。同样是整合，我们又很难想象 ChromeOS 的整合能达到如此高的程度。</p>\n<p>对比 WWDC 来看，其实 WWDC2014 虽然不是很优秀，但也不差。不过因为提前泄露了很多内容，让人有些失望。这是因为苹果在乔布斯死后把每次发布会的重点往往在几个点上，一旦泄露了就什么也没有了。而 Google I/O 能把优势保持在思路上，这使得只言片语的泄露不能造成很大的影响。再加上 Google 能做的许多创新都基于其强大的搜索功底，这是别的厂商根本做不到的，是别人想都不敢想的。所以说，厚积而薄发，Google 这些创新看似轻描淡写的不断涌出，也确实给其他互联网公司一些启示。要做真正的互联网巨头，究竟是要把什么作为根本呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">另外，Google 今天股票大涨，Apple 股票虽然没有大跌，但也没有跟上大盘的涨幅。</span><br><span class=\"line\">WWDC 开完 Apple 股票跌，Google 股票涨，Google I/O 开完还是 Apple 股票跌，Google 股票涨的事也不是第一次发生了。</span><br></pre></td></tr></table></figure>\n","excerpt":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">本文所涉及的主要是太平洋时间 6 月 24 日早上 9 点到 11 点的 Keynote 活动，也就是大家最为关心的发布会的相关内容的评价。</span><br><span class=\"line\">至于其他活动，我将就几个有转播的且有意思的活动额外写一些Review。</span><br></pre></td></tr></table></figure>\n<p>如果说今天凌晨对于许多人最大的纠结之处莫过于是看 Google I/O 大会还是世界杯了。显然，我开了两个屏幕都在看……不过，Youtube 作为谷歌的亲儿子承接了 Google I/O 的直播工作，虽然无论是清晰度还是流畅程度都非常的优秀，但是……对于中国大陆用户而言，恐怕看起来就比较困难了……</p>","more":"<p>作为这种发布会的传统，Google 开始用数据来喷竞争对手。毫无疑问，Android 设备的出货量是远大于 iOS 设备的，所以各种数据规模也不是 Apple 能比的。其实数据这东西本来就是在吹牛，拿来演示的数据永远是有利的。就像 Apple 和 Microsoft 比桌面设备的时候就喜欢比增长率（想想Windows的总量是你比得过？）。Apple 和 Google 比移动端的时候就喜欢比碎片化（Android 的出货量和增长率是你比得过？）。所以当 Google 拿数据说话的时候，恩就是出货量和增长率。但是 Google 在碎片化上这次举了一个有意思的数据。虽然 Kitkat 的市场占有率只有 15%，但是 93% 使用 Google 服务的用户，都已经把 Google Services 的套件更新到了最新。这意味着，虽然系统版本号没有完全跟上，但 Google 用应用的形式能尽力拉进各个版本之间的区别。这一点可以说是曲线救国的方法。不过大家别看这几家大公司嘴炮来嘴炮去的，其实一个都离不开，他们的业务是互相依赖的，这个真的就是打嘴炮而已。</p>\n<h3 id=\"然后，发布会正式开始发布内容。\"><a href=\"#然后，发布会正式开始发布内容。\" class=\"headerlink\" title=\"然后，发布会正式开始发布内容。\"></a>然后，发布会正式开始发布内容。</h3><p>第一个登场的是 Android One。这是一款硬件产品。其作用类似于 Nexus 的标杆作用，不过它是针对低端市场的。Android One 拥有一块4.5英寸的屏幕，双卡双待，支持 SD卡拓展和 FM 收音机。其针对的是发展中国家，售价低于 100 美元。希望能更好地规范安卓在低端市场的表现，而不是现在安卓机器低端市场乱成一锅粥的局面。这款手机最快将于今年秋天在印度发售。它的标杆意义确实能规范一些市场行为，希望能带来一些积极的作用。但和 Nexus 一样，这款手机在中国上市的可能性为 0，因为它还搭载完整的 Google 服务。</p>\n<p>接下来登场的是 L。什么是 L 呢？也就是之前疯传的 Android 5.0。至于是不是 5.0 呢，Google 也没承认，也没否认。它的开发代号是 L。全新的 UI 将扁平化和卡片式设计进一步贯彻了下去，并进一步柔化了界面的边缘。Google 向我们展示了一些应用，并且承诺，许多应用都会在不久之后就会发生这样的改变。开发人员在开发过程中通过一些简单的代码就能很好的创建这样的 UI，大大简化了设计成本。(除了设计上的变化，L 将把 ART 作为默认模式，并且进一步优化了 ART 的执行效率。加入了省电模式，更好处理续航。系统更新将由Play市场提供。（PS：昨天凌晨写稿的时候居然漏了……）但是L系统何时发布，并没有公布。</p>\n<p>Google 这时给出了一个数据，说 Chrome 的 30 天活跃用户的数量已经超过了 3 亿，加上之前说 Android 的 30 天活跃用户超过了 10 亿。下一步 Google 必然将整合这些资源，统一体验。接下来，Google 给我们演示了全新的 ChromeOS 在令人吃惊的整合能力。记得前不久 WWDC 2014 上苹果展示 Mac OS X 的整合能力已经很恐怖了。而 ChromeOS 的能力除了不能用电脑打电话外，简直是有过之而无不及。手机没电了电脑会提醒你这些已经是小事了。更可怕的是，ChromeOS上可以运行所有的Android应用（演示起来非常非常流畅）。你甚至可以在ChromeOS上刷Flipboard。手机内容可以随时投屏到电脑上，所有的，所有的信息都能得到同步。最后，Android将会在新版本中区分工作模式和家庭模式，两者应用和数据完全独立。可以确保你使用一个设备，管理好两者关系，又能保证安全性。</p>\n<h3 id=\"Android-TV、Android-Auto、Android-Wear\"><a href=\"#Android-TV、Android-Auto、Android-Wear\" class=\"headerlink\" title=\"Android TV、Android Auto、Android Wear\"></a>Android TV、Android Auto、Android Wear</h3><p>这三个安卓定制版本分别针对的是智能电视、汽车导航和可穿戴式设备。Android TV的最大亮点在于其背后强大的搜索支持。要找一个节目直接语音说出来就好了。Google的自然语义分析和知识图谱将自动将你语句中要找的内容分析出来，将结果搜索出来。非常方便。</p>\n<p>Android Auto基于最新的 Android L 系统，并且置入了Google Now，这使得它不仅支持语音命令，还可以根据你当前汽车行进的情况，将信息在你需要的时间呈现给你。同时，可以读取所有手机上的数据，让你在开车时不受到手机的束缚，安心驾驶。而且 Google 的 TTS 的发音还是比较接近人声的，比起 CarPlay 上那个机械一样的声音不知道高到哪里去。同时开放了 Android Auto SDK，第三方开发者可以进一步进行开发应用。</p>\n<p>而至于 Android Wear，由于早先已经公布了具体相关标准，并不是很惊喜。Android Wear 标准的出现，也使得可穿戴式设备在发展初期就有一定的规范，有利于 Google 的长期影响。相当有意思的是，Android Wear 可以控制 Android TV。比起什么找不到遥控器用手机控制，用手表这种拴在手上的东西才更靠谱吧。同时，两款 Android Wear设备 LG G Watch 和 Galaxy Gear (Android Wear 版) 将于今天再 Google Play 上开售，而 Moto 360 (圆形屏幕更像表而不像玩具) 将于夏天开售。</p>\n<h3 id=\"Google-Cloud-Platform\"><a href=\"#Google-Cloud-Platform\" class=\"headerlink\" title=\"Google Cloud Platform\"></a>Google Cloud Platform</h3><p>接下来说的就是 Google Cloud Platform。新的云服务提供了一套更好的开发工具和调试环境，大大简化了工作难度。如果说 Swift 语言更像玩具的话，Google 提供的这些改变更像瑞士军刀。刀刀是完全的实用主义。对于大数据分析，数据的监控，云开发的在线修改，在线调试是拿来就能用的东西。其中非常有意思的是对世界杯大数据的分析。许多国内大数据团队也在做类似的东西。但大多需要网民的主观参与，比如投票。而 Google 做的 Example 确是主动收集整个互联网上的数据（比如 Twitter）来分析。这入手点的不同直接看出了 Google 的大数据的意识。所以我一直说，中国这些大数据部门，只不过是数据部门换了个招牌罢了。</p>\n<p>另外，Google 在健康领域开始测试 Google Fit Platform。许多人曾质疑它和 Apple Healthkit 的相似性不过还是有点区别的。Healthkit 的应用和设备是一一对应的。每个厂商开发设备为自己的应用服务。而 Google Fit 更像是一种共享模式。数据和处理分离了开来。这个设备能提供这样的数据，别的应用也可以来调用。看起来更为合理一些。但是考虑到健康应用尚处于萌芽状态，是不是真的有用，还是只是一句空头支票不得而知。</p>\n<p>最后，说说我看完后的总体感受。发布会里面的大多数的东西之前都是略有听闻了的。但是 Google 还是给我们带来了许多惊喜。比如大家都知道了 GCP 的大数据处理能力，但是 Google 却能在大数据上给我们一个不同的思路。比如我们都知道 Google 要发 Android Wear、TV，但却很难想象，他们能将其整合。同样是整合，我们又很难想象 ChromeOS 的整合能达到如此高的程度。</p>\n<p>对比 WWDC 来看，其实 WWDC2014 虽然不是很优秀，但也不差。不过因为提前泄露了很多内容，让人有些失望。这是因为苹果在乔布斯死后把每次发布会的重点往往在几个点上，一旦泄露了就什么也没有了。而 Google I/O 能把优势保持在思路上，这使得只言片语的泄露不能造成很大的影响。再加上 Google 能做的许多创新都基于其强大的搜索功底，这是别的厂商根本做不到的，是别人想都不敢想的。所以说，厚积而薄发，Google 这些创新看似轻描淡写的不断涌出，也确实给其他互联网公司一些启示。要做真正的互联网巨头，究竟是要把什么作为根本呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">另外，Google 今天股票大涨，Apple 股票虽然没有大跌，但也没有跟上大盘的涨幅。</span><br><span class=\"line\">WWDC 开完 Apple 股票跌，Google 股票涨，Google I/O 开完还是 Apple 股票跌，Google 股票涨的事也不是第一次发生了。</span><br></pre></td></tr></table></figure>"},{"title":"Google 的终极目标是天网","date":"2016-05-19T13:19:17.000Z","_content":"\n### 引\n\nGoogle I/O 2016 的 Keynote 部分结束后，各大媒体总会开始进行报道。然而作为一项面向开发者的活动，一般媒体都将其当作产品发布会来报道，以至于通篇流水账，完全不知所云。我今年是在桂林路的 GDG Shanghai Launchpad 和许多人一起观看了 Google I/O 2016 的直播。报名人数远超预期，导致场馆拥挤不堪，说实话，我甚至只能看半个屏幕。好在我英语听力水平不次，回来又看了一遍重播，对于 Google 在这次 Keynote 中想表达的大概有了清晰的认识。\n\n<!--more-->\n\n### Google 的机器学习能力有多深？\n\nGoogle 在这次会议上确实是以「产品」作为支撑发布会结构的。但是 Google Home, Google Assistant, Allo 再到 SyntaxNet，Google 在试图表达的重要观点是他们在机器学习，特别是自然语义处理（Netural Language Processing, NLP）上绝对过人的天赋。\n\n要说人工智能，不得不提到 Allan Turing 在 1950 年发表的论文[「COMPUTING MACHINERY AND INTELLIGENCE」](http://loebner.net/Prizef/TuringArticle.html)，机器计算和智能。在这篇论文中，Allan Turing 革命性提出了 **人工智能** 的判断标准，也就是所谓 **图灵测试**。在这篇论文中，图灵特意举出了一些机器在做智能时需要克服的点，尤其是机器需要对上下文拥有智能。\n\nGoogle Now 的进化版本，Google Assistant 就拥有上下文的智能。你可以先问「这附近有什么好吃的意大利菜吗？」「能预定后天去这家餐厅吗？」「能告诉 Allen 一起来吗？」Google Assistant 具有理解上下文的能力，所以它知道你说的这家餐厅是上文中由 Google 推荐的意大利菜餐厅，以及你希望通知给 Allan 的是你想约他去这家餐厅在后天吃饭的事情。这就是不可多得的上下文理解能力，它并不是受限于实际规定好的语音助手对话的思路，而是完全基于其对自然语义的理解。\n\n拥有了对上下文理解的神奇能力，Google 自然可以做更多。除了终端形态的 Google Home 以外，Allo 其实是 Google Assistant 的进阶产品。有些国内媒体报道说 Allo 是 Google 向社交领域的又一次新的尝试，这绝对是无中生有的事情，Google 可从来没有这么说过。拥有了上下文理解的能力，Google 可以依据上下文为你的回复提出建议，从而使你处理消息的效率得到空前的提高。至于 Due 的视频聊天、可以变化的聊天框之类的，不过是丰富产品功能，而不是发布一个原型的点睛之笔而已。\n\n**Google Assistant 是 Siri 的竞品吗？你就胡扯吧，Google Assistant 是 Skynet 的竞品。**\n\nGoogle 今天拥有了任何其他互联网公司都难以匹敌的机器学习的能力，Google 现在所作的，就是将这种空前的智能，尽可能多地运用到 Google 的产品中。这是这场 I/O 大会上，花最大篇幅讲的事情。\n\n### VR 需要怎样的生态？\n\nGoogle Daydream 的提出不是孤立的，它是 Android N 的一部分，大可不能孤立来看。VR 设备对于渲染的要求是空前的，对于相同场景的渲染，其算力的要求几乎是数倍于传统 3D 应用的。所以我们见到 VR 设备通常需要一台性能强大的主机作为其算力的提供。手机能作为 VR 的运算显示设备吗？\n\n首先，为什么要用手机作 VR 的运算显示设备。在今天，VR 还没有广泛普及，更实际的情况是，大多数人都没有体验过 VR 的神奇。VR 设备昂贵的价格注定了它推广和铺货难度极高。在三年前的 Google I/O 大会上 Google 拿出的 Cardboard 将 VR 的成本一下子降低到了一个极低的程度，中国现在销售的大多数 VR 设备，无疑就是 Cardboard，以及基于 Cardboard 设计修改的延伸产品。\n\n但 Cardboard 的体验无疑是比较差的，受限于手机的算力，手机的 VR 场景过于简单。Google 所构想的手机 VR 是「可用于体验」的，而不是「存在于技术」的。作为一家软件公司，Google 所作的是支持 Vulkan API 大幅提高渲染性能、新的 JIT 编译器大幅提高运算性能、提出硬件标准给予参考。而这三者都囊括在了 Android N 的更新之中。\n\n硬件 -> API -> 应用 的完整生态由 Google 所构建。没有便于开发的 API，大多数开发者都没有足够的性能优化能力。没有合适的硬件标准，那么硬件厂商也只会随心所欲地设计而不能兼容。Google 所作的比起国内大多数 VR 公司想得都清楚和明白得多，而 Google 也有这个技术能力去实现它。\n\n### Android N\n\nAndroid N 还有一些其它关键的点。Google 这次 N Preview 提出得非常早，现在又放出给 N 的开发代号起名字的活动。以及这次放出的 Android Wear 2.0 的系统，我们可以看成 Android Wear N 的版本。其实际是希望开发者参与到 Android N 的开发中来，由开发者的实际使用来进化 Android N 的 API 设计。Android N 从某种角度就是微软的 Windows 10，一个由社区推动，不断更新的操作系统。不过好在 Google 似乎对于品控非常在意，就目前的测试版来看，也不至于存在那么多 bug。也避免新版本系统对应用适配存在问题。\n\n另一方面 Android N 与 Android Studio 的新更新结合非常紧密。Android Studio 所提出的 Instant Deploy，也就是在测试程序时，通过分析修改了的部分的代码，部分更新程序而不必整个重新运行，大大方便了软件开发过程中调试的过程。而利用这种部分更新的特性，Google 这次也带来了可以即时运行的程序，让 App 的体验省去了下载的步骤。虽然是细微的变化，但带来的用户体验的提升是非常好的，同时也证明了 Google Android Studio 的开发与 Android Platform 的开发步调一致。\n\n### 后\n\nGoogle 这次通过 Google I/O 所展示的，并不是一个个孤立的产品。其实所要展示的是 Google 产品之间的联系、生态，以及 Google 在这些产品背后的技术实力。这种贯穿始终的硬实力，是任何一家国内靠情怀、贬低友商、炒股票和耍猴为生的国内互联网厂商所根本无法达到的。看起来相似的演说、场地和产品发布，其背后的深度实在是大为不同。","source":"_posts/google-io-2016-review.md","raw":"---\ntitle: Google 的终极目标是天网\ndate: 2016-05-19 21:19:17\ntags: [Google,Google I/O]\n---\n\n### 引\n\nGoogle I/O 2016 的 Keynote 部分结束后，各大媒体总会开始进行报道。然而作为一项面向开发者的活动，一般媒体都将其当作产品发布会来报道，以至于通篇流水账，完全不知所云。我今年是在桂林路的 GDG Shanghai Launchpad 和许多人一起观看了 Google I/O 2016 的直播。报名人数远超预期，导致场馆拥挤不堪，说实话，我甚至只能看半个屏幕。好在我英语听力水平不次，回来又看了一遍重播，对于 Google 在这次 Keynote 中想表达的大概有了清晰的认识。\n\n<!--more-->\n\n### Google 的机器学习能力有多深？\n\nGoogle 在这次会议上确实是以「产品」作为支撑发布会结构的。但是 Google Home, Google Assistant, Allo 再到 SyntaxNet，Google 在试图表达的重要观点是他们在机器学习，特别是自然语义处理（Netural Language Processing, NLP）上绝对过人的天赋。\n\n要说人工智能，不得不提到 Allan Turing 在 1950 年发表的论文[「COMPUTING MACHINERY AND INTELLIGENCE」](http://loebner.net/Prizef/TuringArticle.html)，机器计算和智能。在这篇论文中，Allan Turing 革命性提出了 **人工智能** 的判断标准，也就是所谓 **图灵测试**。在这篇论文中，图灵特意举出了一些机器在做智能时需要克服的点，尤其是机器需要对上下文拥有智能。\n\nGoogle Now 的进化版本，Google Assistant 就拥有上下文的智能。你可以先问「这附近有什么好吃的意大利菜吗？」「能预定后天去这家餐厅吗？」「能告诉 Allen 一起来吗？」Google Assistant 具有理解上下文的能力，所以它知道你说的这家餐厅是上文中由 Google 推荐的意大利菜餐厅，以及你希望通知给 Allan 的是你想约他去这家餐厅在后天吃饭的事情。这就是不可多得的上下文理解能力，它并不是受限于实际规定好的语音助手对话的思路，而是完全基于其对自然语义的理解。\n\n拥有了对上下文理解的神奇能力，Google 自然可以做更多。除了终端形态的 Google Home 以外，Allo 其实是 Google Assistant 的进阶产品。有些国内媒体报道说 Allo 是 Google 向社交领域的又一次新的尝试，这绝对是无中生有的事情，Google 可从来没有这么说过。拥有了上下文理解的能力，Google 可以依据上下文为你的回复提出建议，从而使你处理消息的效率得到空前的提高。至于 Due 的视频聊天、可以变化的聊天框之类的，不过是丰富产品功能，而不是发布一个原型的点睛之笔而已。\n\n**Google Assistant 是 Siri 的竞品吗？你就胡扯吧，Google Assistant 是 Skynet 的竞品。**\n\nGoogle 今天拥有了任何其他互联网公司都难以匹敌的机器学习的能力，Google 现在所作的，就是将这种空前的智能，尽可能多地运用到 Google 的产品中。这是这场 I/O 大会上，花最大篇幅讲的事情。\n\n### VR 需要怎样的生态？\n\nGoogle Daydream 的提出不是孤立的，它是 Android N 的一部分，大可不能孤立来看。VR 设备对于渲染的要求是空前的，对于相同场景的渲染，其算力的要求几乎是数倍于传统 3D 应用的。所以我们见到 VR 设备通常需要一台性能强大的主机作为其算力的提供。手机能作为 VR 的运算显示设备吗？\n\n首先，为什么要用手机作 VR 的运算显示设备。在今天，VR 还没有广泛普及，更实际的情况是，大多数人都没有体验过 VR 的神奇。VR 设备昂贵的价格注定了它推广和铺货难度极高。在三年前的 Google I/O 大会上 Google 拿出的 Cardboard 将 VR 的成本一下子降低到了一个极低的程度，中国现在销售的大多数 VR 设备，无疑就是 Cardboard，以及基于 Cardboard 设计修改的延伸产品。\n\n但 Cardboard 的体验无疑是比较差的，受限于手机的算力，手机的 VR 场景过于简单。Google 所构想的手机 VR 是「可用于体验」的，而不是「存在于技术」的。作为一家软件公司，Google 所作的是支持 Vulkan API 大幅提高渲染性能、新的 JIT 编译器大幅提高运算性能、提出硬件标准给予参考。而这三者都囊括在了 Android N 的更新之中。\n\n硬件 -> API -> 应用 的完整生态由 Google 所构建。没有便于开发的 API，大多数开发者都没有足够的性能优化能力。没有合适的硬件标准，那么硬件厂商也只会随心所欲地设计而不能兼容。Google 所作的比起国内大多数 VR 公司想得都清楚和明白得多，而 Google 也有这个技术能力去实现它。\n\n### Android N\n\nAndroid N 还有一些其它关键的点。Google 这次 N Preview 提出得非常早，现在又放出给 N 的开发代号起名字的活动。以及这次放出的 Android Wear 2.0 的系统，我们可以看成 Android Wear N 的版本。其实际是希望开发者参与到 Android N 的开发中来，由开发者的实际使用来进化 Android N 的 API 设计。Android N 从某种角度就是微软的 Windows 10，一个由社区推动，不断更新的操作系统。不过好在 Google 似乎对于品控非常在意，就目前的测试版来看，也不至于存在那么多 bug。也避免新版本系统对应用适配存在问题。\n\n另一方面 Android N 与 Android Studio 的新更新结合非常紧密。Android Studio 所提出的 Instant Deploy，也就是在测试程序时，通过分析修改了的部分的代码，部分更新程序而不必整个重新运行，大大方便了软件开发过程中调试的过程。而利用这种部分更新的特性，Google 这次也带来了可以即时运行的程序，让 App 的体验省去了下载的步骤。虽然是细微的变化，但带来的用户体验的提升是非常好的，同时也证明了 Google Android Studio 的开发与 Android Platform 的开发步调一致。\n\n### 后\n\nGoogle 这次通过 Google I/O 所展示的，并不是一个个孤立的产品。其实所要展示的是 Google 产品之间的联系、生态，以及 Google 在这些产品背后的技术实力。这种贯穿始终的硬实力，是任何一家国内靠情怀、贬低友商、炒股票和耍猴为生的国内互联网厂商所根本无法达到的。看起来相似的演说、场地和产品发布，其背后的深度实在是大为不同。","slug":"google-io-2016-review","published":1,"updated":"2016-05-19T13:30:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscy008x000ipp8zlqn1u6qf","content":"<h3 id=\"引\"><a href=\"#引\" class=\"headerlink\" title=\"引\"></a>引</h3><p>Google I/O 2016 的 Keynote 部分结束后，各大媒体总会开始进行报道。然而作为一项面向开发者的活动，一般媒体都将其当作产品发布会来报道，以至于通篇流水账，完全不知所云。我今年是在桂林路的 GDG Shanghai Launchpad 和许多人一起观看了 Google I/O 2016 的直播。报名人数远超预期，导致场馆拥挤不堪，说实话，我甚至只能看半个屏幕。好在我英语听力水平不次，回来又看了一遍重播，对于 Google 在这次 Keynote 中想表达的大概有了清晰的认识。</p>\n<a id=\"more\"></a>\n<h3 id=\"Google-的机器学习能力有多深？\"><a href=\"#Google-的机器学习能力有多深？\" class=\"headerlink\" title=\"Google 的机器学习能力有多深？\"></a>Google 的机器学习能力有多深？</h3><p>Google 在这次会议上确实是以「产品」作为支撑发布会结构的。但是 Google Home, Google Assistant, Allo 再到 SyntaxNet，Google 在试图表达的重要观点是他们在机器学习，特别是自然语义处理（Netural Language Processing, NLP）上绝对过人的天赋。</p>\n<p>要说人工智能，不得不提到 Allan Turing 在 1950 年发表的论文<a href=\"http://loebner.net/Prizef/TuringArticle.html\" target=\"_blank\" rel=\"external\">「COMPUTING MACHINERY AND INTELLIGENCE」</a>，机器计算和智能。在这篇论文中，Allan Turing 革命性提出了 <strong>人工智能</strong> 的判断标准，也就是所谓 <strong>图灵测试</strong>。在这篇论文中，图灵特意举出了一些机器在做智能时需要克服的点，尤其是机器需要对上下文拥有智能。</p>\n<p>Google Now 的进化版本，Google Assistant 就拥有上下文的智能。你可以先问「这附近有什么好吃的意大利菜吗？」「能预定后天去这家餐厅吗？」「能告诉 Allen 一起来吗？」Google Assistant 具有理解上下文的能力，所以它知道你说的这家餐厅是上文中由 Google 推荐的意大利菜餐厅，以及你希望通知给 Allan 的是你想约他去这家餐厅在后天吃饭的事情。这就是不可多得的上下文理解能力，它并不是受限于实际规定好的语音助手对话的思路，而是完全基于其对自然语义的理解。</p>\n<p>拥有了对上下文理解的神奇能力，Google 自然可以做更多。除了终端形态的 Google Home 以外，Allo 其实是 Google Assistant 的进阶产品。有些国内媒体报道说 Allo 是 Google 向社交领域的又一次新的尝试，这绝对是无中生有的事情，Google 可从来没有这么说过。拥有了上下文理解的能力，Google 可以依据上下文为你的回复提出建议，从而使你处理消息的效率得到空前的提高。至于 Due 的视频聊天、可以变化的聊天框之类的，不过是丰富产品功能，而不是发布一个原型的点睛之笔而已。</p>\n<p><strong>Google Assistant 是 Siri 的竞品吗？你就胡扯吧，Google Assistant 是 Skynet 的竞品。</strong></p>\n<p>Google 今天拥有了任何其他互联网公司都难以匹敌的机器学习的能力，Google 现在所作的，就是将这种空前的智能，尽可能多地运用到 Google 的产品中。这是这场 I/O 大会上，花最大篇幅讲的事情。</p>\n<h3 id=\"VR-需要怎样的生态？\"><a href=\"#VR-需要怎样的生态？\" class=\"headerlink\" title=\"VR 需要怎样的生态？\"></a>VR 需要怎样的生态？</h3><p>Google Daydream 的提出不是孤立的，它是 Android N 的一部分，大可不能孤立来看。VR 设备对于渲染的要求是空前的，对于相同场景的渲染，其算力的要求几乎是数倍于传统 3D 应用的。所以我们见到 VR 设备通常需要一台性能强大的主机作为其算力的提供。手机能作为 VR 的运算显示设备吗？</p>\n<p>首先，为什么要用手机作 VR 的运算显示设备。在今天，VR 还没有广泛普及，更实际的情况是，大多数人都没有体验过 VR 的神奇。VR 设备昂贵的价格注定了它推广和铺货难度极高。在三年前的 Google I/O 大会上 Google 拿出的 Cardboard 将 VR 的成本一下子降低到了一个极低的程度，中国现在销售的大多数 VR 设备，无疑就是 Cardboard，以及基于 Cardboard 设计修改的延伸产品。</p>\n<p>但 Cardboard 的体验无疑是比较差的，受限于手机的算力，手机的 VR 场景过于简单。Google 所构想的手机 VR 是「可用于体验」的，而不是「存在于技术」的。作为一家软件公司，Google 所作的是支持 Vulkan API 大幅提高渲染性能、新的 JIT 编译器大幅提高运算性能、提出硬件标准给予参考。而这三者都囊括在了 Android N 的更新之中。</p>\n<p>硬件 -&gt; API -&gt; 应用 的完整生态由 Google 所构建。没有便于开发的 API，大多数开发者都没有足够的性能优化能力。没有合适的硬件标准，那么硬件厂商也只会随心所欲地设计而不能兼容。Google 所作的比起国内大多数 VR 公司想得都清楚和明白得多，而 Google 也有这个技术能力去实现它。</p>\n<h3 id=\"Android-N\"><a href=\"#Android-N\" class=\"headerlink\" title=\"Android N\"></a>Android N</h3><p>Android N 还有一些其它关键的点。Google 这次 N Preview 提出得非常早，现在又放出给 N 的开发代号起名字的活动。以及这次放出的 Android Wear 2.0 的系统，我们可以看成 Android Wear N 的版本。其实际是希望开发者参与到 Android N 的开发中来，由开发者的实际使用来进化 Android N 的 API 设计。Android N 从某种角度就是微软的 Windows 10，一个由社区推动，不断更新的操作系统。不过好在 Google 似乎对于品控非常在意，就目前的测试版来看，也不至于存在那么多 bug。也避免新版本系统对应用适配存在问题。</p>\n<p>另一方面 Android N 与 Android Studio 的新更新结合非常紧密。Android Studio 所提出的 Instant Deploy，也就是在测试程序时，通过分析修改了的部分的代码，部分更新程序而不必整个重新运行，大大方便了软件开发过程中调试的过程。而利用这种部分更新的特性，Google 这次也带来了可以即时运行的程序，让 App 的体验省去了下载的步骤。虽然是细微的变化，但带来的用户体验的提升是非常好的，同时也证明了 Google Android Studio 的开发与 Android Platform 的开发步调一致。</p>\n<h3 id=\"后\"><a href=\"#后\" class=\"headerlink\" title=\"后\"></a>后</h3><p>Google 这次通过 Google I/O 所展示的，并不是一个个孤立的产品。其实所要展示的是 Google 产品之间的联系、生态，以及 Google 在这些产品背后的技术实力。这种贯穿始终的硬实力，是任何一家国内靠情怀、贬低友商、炒股票和耍猴为生的国内互联网厂商所根本无法达到的。看起来相似的演说、场地和产品发布，其背后的深度实在是大为不同。</p>\n","excerpt":"<h3 id=\"引\"><a href=\"#引\" class=\"headerlink\" title=\"引\"></a>引</h3><p>Google I/O 2016 的 Keynote 部分结束后，各大媒体总会开始进行报道。然而作为一项面向开发者的活动，一般媒体都将其当作产品发布会来报道，以至于通篇流水账，完全不知所云。我今年是在桂林路的 GDG Shanghai Launchpad 和许多人一起观看了 Google I/O 2016 的直播。报名人数远超预期，导致场馆拥挤不堪，说实话，我甚至只能看半个屏幕。好在我英语听力水平不次，回来又看了一遍重播，对于 Google 在这次 Keynote 中想表达的大概有了清晰的认识。</p>","more":"<h3 id=\"Google-的机器学习能力有多深？\"><a href=\"#Google-的机器学习能力有多深？\" class=\"headerlink\" title=\"Google 的机器学习能力有多深？\"></a>Google 的机器学习能力有多深？</h3><p>Google 在这次会议上确实是以「产品」作为支撑发布会结构的。但是 Google Home, Google Assistant, Allo 再到 SyntaxNet，Google 在试图表达的重要观点是他们在机器学习，特别是自然语义处理（Netural Language Processing, NLP）上绝对过人的天赋。</p>\n<p>要说人工智能，不得不提到 Allan Turing 在 1950 年发表的论文<a href=\"http://loebner.net/Prizef/TuringArticle.html\">「COMPUTING MACHINERY AND INTELLIGENCE」</a>，机器计算和智能。在这篇论文中，Allan Turing 革命性提出了 <strong>人工智能</strong> 的判断标准，也就是所谓 <strong>图灵测试</strong>。在这篇论文中，图灵特意举出了一些机器在做智能时需要克服的点，尤其是机器需要对上下文拥有智能。</p>\n<p>Google Now 的进化版本，Google Assistant 就拥有上下文的智能。你可以先问「这附近有什么好吃的意大利菜吗？」「能预定后天去这家餐厅吗？」「能告诉 Allen 一起来吗？」Google Assistant 具有理解上下文的能力，所以它知道你说的这家餐厅是上文中由 Google 推荐的意大利菜餐厅，以及你希望通知给 Allan 的是你想约他去这家餐厅在后天吃饭的事情。这就是不可多得的上下文理解能力，它并不是受限于实际规定好的语音助手对话的思路，而是完全基于其对自然语义的理解。</p>\n<p>拥有了对上下文理解的神奇能力，Google 自然可以做更多。除了终端形态的 Google Home 以外，Allo 其实是 Google Assistant 的进阶产品。有些国内媒体报道说 Allo 是 Google 向社交领域的又一次新的尝试，这绝对是无中生有的事情，Google 可从来没有这么说过。拥有了上下文理解的能力，Google 可以依据上下文为你的回复提出建议，从而使你处理消息的效率得到空前的提高。至于 Due 的视频聊天、可以变化的聊天框之类的，不过是丰富产品功能，而不是发布一个原型的点睛之笔而已。</p>\n<p><strong>Google Assistant 是 Siri 的竞品吗？你就胡扯吧，Google Assistant 是 Skynet 的竞品。</strong></p>\n<p>Google 今天拥有了任何其他互联网公司都难以匹敌的机器学习的能力，Google 现在所作的，就是将这种空前的智能，尽可能多地运用到 Google 的产品中。这是这场 I/O 大会上，花最大篇幅讲的事情。</p>\n<h3 id=\"VR-需要怎样的生态？\"><a href=\"#VR-需要怎样的生态？\" class=\"headerlink\" title=\"VR 需要怎样的生态？\"></a>VR 需要怎样的生态？</h3><p>Google Daydream 的提出不是孤立的，它是 Android N 的一部分，大可不能孤立来看。VR 设备对于渲染的要求是空前的，对于相同场景的渲染，其算力的要求几乎是数倍于传统 3D 应用的。所以我们见到 VR 设备通常需要一台性能强大的主机作为其算力的提供。手机能作为 VR 的运算显示设备吗？</p>\n<p>首先，为什么要用手机作 VR 的运算显示设备。在今天，VR 还没有广泛普及，更实际的情况是，大多数人都没有体验过 VR 的神奇。VR 设备昂贵的价格注定了它推广和铺货难度极高。在三年前的 Google I/O 大会上 Google 拿出的 Cardboard 将 VR 的成本一下子降低到了一个极低的程度，中国现在销售的大多数 VR 设备，无疑就是 Cardboard，以及基于 Cardboard 设计修改的延伸产品。</p>\n<p>但 Cardboard 的体验无疑是比较差的，受限于手机的算力，手机的 VR 场景过于简单。Google 所构想的手机 VR 是「可用于体验」的，而不是「存在于技术」的。作为一家软件公司，Google 所作的是支持 Vulkan API 大幅提高渲染性能、新的 JIT 编译器大幅提高运算性能、提出硬件标准给予参考。而这三者都囊括在了 Android N 的更新之中。</p>\n<p>硬件 -&gt; API -&gt; 应用 的完整生态由 Google 所构建。没有便于开发的 API，大多数开发者都没有足够的性能优化能力。没有合适的硬件标准，那么硬件厂商也只会随心所欲地设计而不能兼容。Google 所作的比起国内大多数 VR 公司想得都清楚和明白得多，而 Google 也有这个技术能力去实现它。</p>\n<h3 id=\"Android-N\"><a href=\"#Android-N\" class=\"headerlink\" title=\"Android N\"></a>Android N</h3><p>Android N 还有一些其它关键的点。Google 这次 N Preview 提出得非常早，现在又放出给 N 的开发代号起名字的活动。以及这次放出的 Android Wear 2.0 的系统，我们可以看成 Android Wear N 的版本。其实际是希望开发者参与到 Android N 的开发中来，由开发者的实际使用来进化 Android N 的 API 设计。Android N 从某种角度就是微软的 Windows 10，一个由社区推动，不断更新的操作系统。不过好在 Google 似乎对于品控非常在意，就目前的测试版来看，也不至于存在那么多 bug。也避免新版本系统对应用适配存在问题。</p>\n<p>另一方面 Android N 与 Android Studio 的新更新结合非常紧密。Android Studio 所提出的 Instant Deploy，也就是在测试程序时，通过分析修改了的部分的代码，部分更新程序而不必整个重新运行，大大方便了软件开发过程中调试的过程。而利用这种部分更新的特性，Google 这次也带来了可以即时运行的程序，让 App 的体验省去了下载的步骤。虽然是细微的变化，但带来的用户体验的提升是非常好的，同时也证明了 Google Android Studio 的开发与 Android Platform 的开发步调一致。</p>\n<h3 id=\"后\"><a href=\"#后\" class=\"headerlink\" title=\"后\"></a>后</h3><p>Google 这次通过 Google I/O 所展示的，并不是一个个孤立的产品。其实所要展示的是 Google 产品之间的联系、生态，以及 Google 在这些产品背后的技术实力。这种贯穿始终的硬实力，是任何一家国内靠情怀、贬低友商、炒股票和耍猴为生的国内互联网厂商所根本无法达到的。看起来相似的演说、场地和产品发布，其背后的深度实在是大为不同。</p>"},{"title":"微软全新浏览器 Spartan 背后悲伤的故事","date":"2015-01-23T07:16:21.000Z","_content":"\n昨天凌晨在微软的产品发布会上大家知道搭载在 Windows 10 上的默认浏览器已经从 IE 变成了 Spartan —— 一个完全全新的产品。伴随我们日日夜夜，从当年最牛的主流浏览器最后走向用来安装其他浏览器的浏览器的IE终于走到了它人生的尾声。\n\n但是就我看来，Spartan 完全不是全新的产品，它其实就是IE 12。如果把它看成全新的产品，其实 IE 11 就已经焕然一新了，只不过大家早已经都忘了它。质疑 IE 显示各种不符合 W3C 的兼容性问题和吐槽性能差的同学我想有很多，但是我想问一个问题：“IE 11 的时候，真的还有这些问题吗？”\n\n我记得去年10月的时候我讲了一个笑话：\n\n```\n虽然现在微软的IE11浏览器相较之前版本已经有了很大的进步，但是用户的普遍接受度已经不高。主要是IE6之后微软对IE的放置play已经使得IE这个品牌给用户留下了一个很不好的印象。我觉得一个比较好的办法是微软换一个浏览器品牌的名字，开个发布会，说一段什么“重归创业，情怀浏览”之类的话其实就好了嘛。。。至于换什么名字逼格比较高的话。。。不如叫iE吧。。。\n```\n\n万万没想到的是，它应验了，IE真的改了名。而这背后，其实隐藏了一个历史悠久却又非常悲伤的故事......\n\n~~闹了半天你们不就是喜欢听故事嘛，我讲，我讲还不行嘛。~~\n\n<!--more-->\n\nIE 是作为 Netscape 的绝对竞争对手而出现的，其目的就是为了抢占 Netscape 在浏览器市场上的份额，使得微软能自己掌控互联网的入口。等到 Netscape 退出历史舞台后基本上很难有大竞争对手了。（当时继承了 Netscape 衣钵的 Firefox 还很小众，而 Chrome 根本没出现）**尤其是IE6之后，微软已经占据了几乎全部的市场份额，**已经没有更大的商业价值可以挖掘了。你现在可能认为 IE 6 是一个很烂的产品，但是那是因为你以现在的眼光在看问题。如果你以当时的眼光来看，以当时的电脑性能并和其他浏览器相比，IE6是那个时代最棒的浏览器了。IE 已经不再是微软要解决的棘手问题了，原先IE团队中的大牛也基本走得差不多，他们接下来要做的是不过是来维持这个产品的统治地位。\n\n```\n入则无法家拂士，出则无敌国外患者，国恒亡。然后知生于忧患而死于安乐者也。——《孟子·告子下》\n```\n\n微软用血与泪的教训向我们验证了这句话。IE 7、IE 8 的 IE 几乎就是一个完全的消极防守的状态。却不知道，世界格局正在发生悄悄的变化。苹果与 KHTML 的矛盾激化严重，使得苹果彻底与 KHTML 决裂不再合并代码，从而开启了另一分支，这一分支就是后来的 Webkit。这个内核随着 KDE 开发者的加入逐渐壮大，而 KHTML 逐渐衰落。之后，在 2005 年左右，Webkit 宣布了全面开源，之后 Google 发布的Google Chrome 浏览器更是使用了这一内核。随着 Google 的加入，竞争进入了白热化的境地。Google 之后推出了 V8 Javascript 渲染引擎更是将浏览器速度提升到了一个新的高度。从 2009 年到 2014 年，IE 的市场份额从 70% 降低到了接近 20%。微软丢失的市场被 Chrome、Firefox、Opera、Safari 一同吃得干干净净。\n同时微软不义的举动再次成为千夫所指，所谓的不义就是浏览器没有按照 W3C 的开发标准来，对开发人员设计网页造成了很大的影响。根据标准设计的网页无法在 IE 上正常显示，不得不做出修改从而使得其他按照标准来的浏览器显示出错。但是请问了，对于一个市场占用超过 70% 的浏览器而言，谁才是真正的标准？在 IE 最红火的年代，W3C 的标准更像是装饰，而当微软份额丢尽时成为了推倒 IE 大山的罪证。并且，随着 HTML5 标准的进一步完善，各家都抢先在支持 HTML5 的新特性。因为 HTML4 标准已经很久远，不能满足日常所需。网页显示个视频都要依靠 Flash，浏览器不能掌握性能的生杀大权，HTML5 标准的提出显然是被各家所支持和推荐的。\n到了 IE 9 的时候，微软终于意识到了事态的严重。微软已经从一个领头者成为了落后者。于是 IE 9 开始微软重振旗鼓要搞浏览器。在 IE 9 发布时，微软也提出了要跟进 HTML5，并且展示了许多 IE 9 兼容的 HTML5 新特性。但是除了这些新特性外，旧特性依然没有按照标准在走，所以没有得到市场的肯定。到了 IE 10，微软则进一步完善了自己浏览器的渲染，使得 IE 也紧跟上了标准的步伐，以求得市场的认同。\n但是 IE 10 之后，微软发现了新的问题。\n大量网页依然无法在 IE 10 上良好渲染。其问题并不是 IE 10 没跟着标准走，而是网页大量调用了 Webkit 内核支持的私有功能。因为如今除了 IE 和 Firefox，市面上几乎其它所有浏览器都是 Webkit 内核的。而 Firefox 也支持了一部分 Webkit 的私有功能。跟着标准走的 IE 再次吃了大亏。其实根本没有什么标准，谁有市场的主导权，谁就是标准。如今Chrome、Safari、Opera（当时 Opera 也转投了 Webkit 阵营）都在使用的 Webkit 内核成为了真正的市场主导者。他们功能中不符合 W3C 标准的地方却丝毫没人提出。\n市场不会允许一次一次再一次的失败。IE 11 在技术上已经被微软孤注一掷，其核心团队几乎都是微软最顶尖的大牛。IE 11 不但要符合了 W3C 的标准，甚至在 IE 中实现了大量 Webkit 内核中才有的私有功能，全新的 Javascript 渲染引擎，速度已经走到了大家的平均水平，在开发人员工具等细节功能上更是做得非常到位。但这一代的 IE 恰恰安排在了让人理不清操作逻辑的 Windows 8 上。这一代 Windows 是让人失望的，而 IE 则更是被人遗忘在了不知道哪个角落里。纵使 IE 11 的速度已经不再慢、兼容性不再差、甚至有些地方做得还更好，甚至和 Chrome 那一卡一顿的滚动时的帧率问题比起来，IE 的滚动已经能和 Safari 一样流畅了。但生在被命运捉弄的 Windows 8 上，生在一个已经不属于它的世界上，IE 11 已经什么都没有了。很多人连 IE 都没怎么好好用过就把 IE 当作了慢、卡、不兼容的代名词。纵使在技术上下了大工夫，却还是失败了。\n既然今天的 IE 已经和昨天有了翻天覆地的变化成为了完全不同的产品，但还是已经被人下了这样的定义，那么只有一条路可以走——改名。所以搭载在 Windows 10 上的浏览器不再是 IE 而是 Spartan，至少一个新名字可以告诉别人，它真的不是原来那个样子了。\n\n\n不过我倒是觉得微软要做的可能不止这点。\n\n```\nIE9：我错了。\n\n用户：知道错哪了吗？\n\nIE9：我应该支持更多新功能的。\n\n用户：还有呢？\n\nIE9：还有？\n\n用户：你果然不知道自己错哪，哼╭(╯^╰)╮\n\nIE10：我错了。\n\n用户：知道错哪了吗？\n\nIE10：我应该更多兼容标准的。\n\n用户：还有呢？\n\nIE10：还有？\n\n用户：你果然不知道自己错哪，哼╭(╯^╰)╮\n\nIE11：我错了。\n\n用户：知道错哪了吗？\n\nIE11：我应该变得更快更好用，多学学 Webkit 的特性。还要支持更多人性化的小功能。\n\n用户：还有呢？\n\nIE11：还有？\n\n用户：你果然不知道自己错哪，哼╭(╯^╰)╮\n\nIE11：你听我解释。\n\n用户：我不听我不听我不听。你肯定是仗着店大欺客，哼。\n\nIE11：。。。\n\n用户：我信你一回。\n\n（5分钟后）\n\n用户：怎么提示我没 Flash？我装了啊！然后下载最新版竟然提示我只能在 Windows Update 更新！好麻烦！不用了！\n\nIE11：。。。\n\nIE11：试图减轻用户负担预装 Flash 并集成到 Windows Update 里了，谁知 道Adobe 家几天一更新坑我。。。玩脱了。。。\n\n用户：果然不行，哼╭(╯^╰)╮\n```\n\n其实这个才是微软急需解决的问题吧。。。\n","source":"_posts/gossip-of-spartan.md","raw":"---\ntitle: 微软全新浏览器 Spartan 背后悲伤的故事\ndate: 2015-01-23 15:16:21\ntags: [Microsoft,Spartan,Edge,浏览器]\n---\n\n昨天凌晨在微软的产品发布会上大家知道搭载在 Windows 10 上的默认浏览器已经从 IE 变成了 Spartan —— 一个完全全新的产品。伴随我们日日夜夜，从当年最牛的主流浏览器最后走向用来安装其他浏览器的浏览器的IE终于走到了它人生的尾声。\n\n但是就我看来，Spartan 完全不是全新的产品，它其实就是IE 12。如果把它看成全新的产品，其实 IE 11 就已经焕然一新了，只不过大家早已经都忘了它。质疑 IE 显示各种不符合 W3C 的兼容性问题和吐槽性能差的同学我想有很多，但是我想问一个问题：“IE 11 的时候，真的还有这些问题吗？”\n\n我记得去年10月的时候我讲了一个笑话：\n\n```\n虽然现在微软的IE11浏览器相较之前版本已经有了很大的进步，但是用户的普遍接受度已经不高。主要是IE6之后微软对IE的放置play已经使得IE这个品牌给用户留下了一个很不好的印象。我觉得一个比较好的办法是微软换一个浏览器品牌的名字，开个发布会，说一段什么“重归创业，情怀浏览”之类的话其实就好了嘛。。。至于换什么名字逼格比较高的话。。。不如叫iE吧。。。\n```\n\n万万没想到的是，它应验了，IE真的改了名。而这背后，其实隐藏了一个历史悠久却又非常悲伤的故事......\n\n~~闹了半天你们不就是喜欢听故事嘛，我讲，我讲还不行嘛。~~\n\n<!--more-->\n\nIE 是作为 Netscape 的绝对竞争对手而出现的，其目的就是为了抢占 Netscape 在浏览器市场上的份额，使得微软能自己掌控互联网的入口。等到 Netscape 退出历史舞台后基本上很难有大竞争对手了。（当时继承了 Netscape 衣钵的 Firefox 还很小众，而 Chrome 根本没出现）**尤其是IE6之后，微软已经占据了几乎全部的市场份额，**已经没有更大的商业价值可以挖掘了。你现在可能认为 IE 6 是一个很烂的产品，但是那是因为你以现在的眼光在看问题。如果你以当时的眼光来看，以当时的电脑性能并和其他浏览器相比，IE6是那个时代最棒的浏览器了。IE 已经不再是微软要解决的棘手问题了，原先IE团队中的大牛也基本走得差不多，他们接下来要做的是不过是来维持这个产品的统治地位。\n\n```\n入则无法家拂士，出则无敌国外患者，国恒亡。然后知生于忧患而死于安乐者也。——《孟子·告子下》\n```\n\n微软用血与泪的教训向我们验证了这句话。IE 7、IE 8 的 IE 几乎就是一个完全的消极防守的状态。却不知道，世界格局正在发生悄悄的变化。苹果与 KHTML 的矛盾激化严重，使得苹果彻底与 KHTML 决裂不再合并代码，从而开启了另一分支，这一分支就是后来的 Webkit。这个内核随着 KDE 开发者的加入逐渐壮大，而 KHTML 逐渐衰落。之后，在 2005 年左右，Webkit 宣布了全面开源，之后 Google 发布的Google Chrome 浏览器更是使用了这一内核。随着 Google 的加入，竞争进入了白热化的境地。Google 之后推出了 V8 Javascript 渲染引擎更是将浏览器速度提升到了一个新的高度。从 2009 年到 2014 年，IE 的市场份额从 70% 降低到了接近 20%。微软丢失的市场被 Chrome、Firefox、Opera、Safari 一同吃得干干净净。\n同时微软不义的举动再次成为千夫所指，所谓的不义就是浏览器没有按照 W3C 的开发标准来，对开发人员设计网页造成了很大的影响。根据标准设计的网页无法在 IE 上正常显示，不得不做出修改从而使得其他按照标准来的浏览器显示出错。但是请问了，对于一个市场占用超过 70% 的浏览器而言，谁才是真正的标准？在 IE 最红火的年代，W3C 的标准更像是装饰，而当微软份额丢尽时成为了推倒 IE 大山的罪证。并且，随着 HTML5 标准的进一步完善，各家都抢先在支持 HTML5 的新特性。因为 HTML4 标准已经很久远，不能满足日常所需。网页显示个视频都要依靠 Flash，浏览器不能掌握性能的生杀大权，HTML5 标准的提出显然是被各家所支持和推荐的。\n到了 IE 9 的时候，微软终于意识到了事态的严重。微软已经从一个领头者成为了落后者。于是 IE 9 开始微软重振旗鼓要搞浏览器。在 IE 9 发布时，微软也提出了要跟进 HTML5，并且展示了许多 IE 9 兼容的 HTML5 新特性。但是除了这些新特性外，旧特性依然没有按照标准在走，所以没有得到市场的肯定。到了 IE 10，微软则进一步完善了自己浏览器的渲染，使得 IE 也紧跟上了标准的步伐，以求得市场的认同。\n但是 IE 10 之后，微软发现了新的问题。\n大量网页依然无法在 IE 10 上良好渲染。其问题并不是 IE 10 没跟着标准走，而是网页大量调用了 Webkit 内核支持的私有功能。因为如今除了 IE 和 Firefox，市面上几乎其它所有浏览器都是 Webkit 内核的。而 Firefox 也支持了一部分 Webkit 的私有功能。跟着标准走的 IE 再次吃了大亏。其实根本没有什么标准，谁有市场的主导权，谁就是标准。如今Chrome、Safari、Opera（当时 Opera 也转投了 Webkit 阵营）都在使用的 Webkit 内核成为了真正的市场主导者。他们功能中不符合 W3C 标准的地方却丝毫没人提出。\n市场不会允许一次一次再一次的失败。IE 11 在技术上已经被微软孤注一掷，其核心团队几乎都是微软最顶尖的大牛。IE 11 不但要符合了 W3C 的标准，甚至在 IE 中实现了大量 Webkit 内核中才有的私有功能，全新的 Javascript 渲染引擎，速度已经走到了大家的平均水平，在开发人员工具等细节功能上更是做得非常到位。但这一代的 IE 恰恰安排在了让人理不清操作逻辑的 Windows 8 上。这一代 Windows 是让人失望的，而 IE 则更是被人遗忘在了不知道哪个角落里。纵使 IE 11 的速度已经不再慢、兼容性不再差、甚至有些地方做得还更好，甚至和 Chrome 那一卡一顿的滚动时的帧率问题比起来，IE 的滚动已经能和 Safari 一样流畅了。但生在被命运捉弄的 Windows 8 上，生在一个已经不属于它的世界上，IE 11 已经什么都没有了。很多人连 IE 都没怎么好好用过就把 IE 当作了慢、卡、不兼容的代名词。纵使在技术上下了大工夫，却还是失败了。\n既然今天的 IE 已经和昨天有了翻天覆地的变化成为了完全不同的产品，但还是已经被人下了这样的定义，那么只有一条路可以走——改名。所以搭载在 Windows 10 上的浏览器不再是 IE 而是 Spartan，至少一个新名字可以告诉别人，它真的不是原来那个样子了。\n\n\n不过我倒是觉得微软要做的可能不止这点。\n\n```\nIE9：我错了。\n\n用户：知道错哪了吗？\n\nIE9：我应该支持更多新功能的。\n\n用户：还有呢？\n\nIE9：还有？\n\n用户：你果然不知道自己错哪，哼╭(╯^╰)╮\n\nIE10：我错了。\n\n用户：知道错哪了吗？\n\nIE10：我应该更多兼容标准的。\n\n用户：还有呢？\n\nIE10：还有？\n\n用户：你果然不知道自己错哪，哼╭(╯^╰)╮\n\nIE11：我错了。\n\n用户：知道错哪了吗？\n\nIE11：我应该变得更快更好用，多学学 Webkit 的特性。还要支持更多人性化的小功能。\n\n用户：还有呢？\n\nIE11：还有？\n\n用户：你果然不知道自己错哪，哼╭(╯^╰)╮\n\nIE11：你听我解释。\n\n用户：我不听我不听我不听。你肯定是仗着店大欺客，哼。\n\nIE11：。。。\n\n用户：我信你一回。\n\n（5分钟后）\n\n用户：怎么提示我没 Flash？我装了啊！然后下载最新版竟然提示我只能在 Windows Update 更新！好麻烦！不用了！\n\nIE11：。。。\n\nIE11：试图减轻用户负担预装 Flash 并集成到 Windows Update 里了，谁知 道Adobe 家几天一更新坑我。。。玩脱了。。。\n\n用户：果然不行，哼╭(╯^╰)╮\n```\n\n其实这个才是微软急需解决的问题吧。。。\n","slug":"gossip-of-spartan","published":1,"updated":"2016-04-21T17:31:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscy008z000kpp8zgto2q1it","content":"<p>昨天凌晨在微软的产品发布会上大家知道搭载在 Windows 10 上的默认浏览器已经从 IE 变成了 Spartan —— 一个完全全新的产品。伴随我们日日夜夜，从当年最牛的主流浏览器最后走向用来安装其他浏览器的浏览器的IE终于走到了它人生的尾声。</p>\n<p>但是就我看来，Spartan 完全不是全新的产品，它其实就是IE 12。如果把它看成全新的产品，其实 IE 11 就已经焕然一新了，只不过大家早已经都忘了它。质疑 IE 显示各种不符合 W3C 的兼容性问题和吐槽性能差的同学我想有很多，但是我想问一个问题：“IE 11 的时候，真的还有这些问题吗？”</p>\n<p>我记得去年10月的时候我讲了一个笑话：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">虽然现在微软的IE11浏览器相较之前版本已经有了很大的进步，但是用户的普遍接受度已经不高。主要是IE6之后微软对IE的放置play已经使得IE这个品牌给用户留下了一个很不好的印象。我觉得一个比较好的办法是微软换一个浏览器品牌的名字，开个发布会，说一段什么“重归创业，情怀浏览”之类的话其实就好了嘛。。。至于换什么名字逼格比较高的话。。。不如叫iE吧。。。</span><br></pre></td></tr></table></figure>\n<p>万万没想到的是，它应验了，IE真的改了名。而这背后，其实隐藏了一个历史悠久却又非常悲伤的故事……</p>\n<p><del>闹了半天你们不就是喜欢听故事嘛，我讲，我讲还不行嘛。</del></p>\n<a id=\"more\"></a>\n<p>IE 是作为 Netscape 的绝对竞争对手而出现的，其目的就是为了抢占 Netscape 在浏览器市场上的份额，使得微软能自己掌控互联网的入口。等到 Netscape 退出历史舞台后基本上很难有大竞争对手了。（当时继承了 Netscape 衣钵的 Firefox 还很小众，而 Chrome 根本没出现）<strong>尤其是IE6之后，微软已经占据了几乎全部的市场份额，</strong>已经没有更大的商业价值可以挖掘了。你现在可能认为 IE 6 是一个很烂的产品，但是那是因为你以现在的眼光在看问题。如果你以当时的眼光来看，以当时的电脑性能并和其他浏览器相比，IE6是那个时代最棒的浏览器了。IE 已经不再是微软要解决的棘手问题了，原先IE团队中的大牛也基本走得差不多，他们接下来要做的是不过是来维持这个产品的统治地位。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">入则无法家拂士，出则无敌国外患者，国恒亡。然后知生于忧患而死于安乐者也。——《孟子·告子下》</span><br></pre></td></tr></table></figure>\n<p>微软用血与泪的教训向我们验证了这句话。IE 7、IE 8 的 IE 几乎就是一个完全的消极防守的状态。却不知道，世界格局正在发生悄悄的变化。苹果与 KHTML 的矛盾激化严重，使得苹果彻底与 KHTML 决裂不再合并代码，从而开启了另一分支，这一分支就是后来的 Webkit。这个内核随着 KDE 开发者的加入逐渐壮大，而 KHTML 逐渐衰落。之后，在 2005 年左右，Webkit 宣布了全面开源，之后 Google 发布的Google Chrome 浏览器更是使用了这一内核。随着 Google 的加入，竞争进入了白热化的境地。Google 之后推出了 V8 Javascript 渲染引擎更是将浏览器速度提升到了一个新的高度。从 2009 年到 2014 年，IE 的市场份额从 70% 降低到了接近 20%。微软丢失的市场被 Chrome、Firefox、Opera、Safari 一同吃得干干净净。<br>同时微软不义的举动再次成为千夫所指，所谓的不义就是浏览器没有按照 W3C 的开发标准来，对开发人员设计网页造成了很大的影响。根据标准设计的网页无法在 IE 上正常显示，不得不做出修改从而使得其他按照标准来的浏览器显示出错。但是请问了，对于一个市场占用超过 70% 的浏览器而言，谁才是真正的标准？在 IE 最红火的年代，W3C 的标准更像是装饰，而当微软份额丢尽时成为了推倒 IE 大山的罪证。并且，随着 HTML5 标准的进一步完善，各家都抢先在支持 HTML5 的新特性。因为 HTML4 标准已经很久远，不能满足日常所需。网页显示个视频都要依靠 Flash，浏览器不能掌握性能的生杀大权，HTML5 标准的提出显然是被各家所支持和推荐的。<br>到了 IE 9 的时候，微软终于意识到了事态的严重。微软已经从一个领头者成为了落后者。于是 IE 9 开始微软重振旗鼓要搞浏览器。在 IE 9 发布时，微软也提出了要跟进 HTML5，并且展示了许多 IE 9 兼容的 HTML5 新特性。但是除了这些新特性外，旧特性依然没有按照标准在走，所以没有得到市场的肯定。到了 IE 10，微软则进一步完善了自己浏览器的渲染，使得 IE 也紧跟上了标准的步伐，以求得市场的认同。<br>但是 IE 10 之后，微软发现了新的问题。<br>大量网页依然无法在 IE 10 上良好渲染。其问题并不是 IE 10 没跟着标准走，而是网页大量调用了 Webkit 内核支持的私有功能。因为如今除了 IE 和 Firefox，市面上几乎其它所有浏览器都是 Webkit 内核的。而 Firefox 也支持了一部分 Webkit 的私有功能。跟着标准走的 IE 再次吃了大亏。其实根本没有什么标准，谁有市场的主导权，谁就是标准。如今Chrome、Safari、Opera（当时 Opera 也转投了 Webkit 阵营）都在使用的 Webkit 内核成为了真正的市场主导者。他们功能中不符合 W3C 标准的地方却丝毫没人提出。<br>市场不会允许一次一次再一次的失败。IE 11 在技术上已经被微软孤注一掷，其核心团队几乎都是微软最顶尖的大牛。IE 11 不但要符合了 W3C 的标准，甚至在 IE 中实现了大量 Webkit 内核中才有的私有功能，全新的 Javascript 渲染引擎，速度已经走到了大家的平均水平，在开发人员工具等细节功能上更是做得非常到位。但这一代的 IE 恰恰安排在了让人理不清操作逻辑的 Windows 8 上。这一代 Windows 是让人失望的，而 IE 则更是被人遗忘在了不知道哪个角落里。纵使 IE 11 的速度已经不再慢、兼容性不再差、甚至有些地方做得还更好，甚至和 Chrome 那一卡一顿的滚动时的帧率问题比起来，IE 的滚动已经能和 Safari 一样流畅了。但生在被命运捉弄的 Windows 8 上，生在一个已经不属于它的世界上，IE 11 已经什么都没有了。很多人连 IE 都没怎么好好用过就把 IE 当作了慢、卡、不兼容的代名词。纵使在技术上下了大工夫，却还是失败了。<br>既然今天的 IE 已经和昨天有了翻天覆地的变化成为了完全不同的产品，但还是已经被人下了这样的定义，那么只有一条路可以走——改名。所以搭载在 Windows 10 上的浏览器不再是 IE 而是 Spartan，至少一个新名字可以告诉别人，它真的不是原来那个样子了。</p>\n<p>不过我倒是觉得微软要做的可能不止这点。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IE9：我错了。</span><br><span class=\"line\"></span><br><span class=\"line\">用户：知道错哪了吗？</span><br><span class=\"line\"></span><br><span class=\"line\">IE9：我应该支持更多新功能的。</span><br><span class=\"line\"></span><br><span class=\"line\">用户：还有呢？</span><br><span class=\"line\"></span><br><span class=\"line\">IE9：还有？</span><br><span class=\"line\"></span><br><span class=\"line\">用户：你果然不知道自己错哪，哼╭(╯^╰)╮</span><br><span class=\"line\"></span><br><span class=\"line\">IE10：我错了。</span><br><span class=\"line\"></span><br><span class=\"line\">用户：知道错哪了吗？</span><br><span class=\"line\"></span><br><span class=\"line\">IE10：我应该更多兼容标准的。</span><br><span class=\"line\"></span><br><span class=\"line\">用户：还有呢？</span><br><span class=\"line\"></span><br><span class=\"line\">IE10：还有？</span><br><span class=\"line\"></span><br><span class=\"line\">用户：你果然不知道自己错哪，哼╭(╯^╰)╮</span><br><span class=\"line\"></span><br><span class=\"line\">IE11：我错了。</span><br><span class=\"line\"></span><br><span class=\"line\">用户：知道错哪了吗？</span><br><span class=\"line\"></span><br><span class=\"line\">IE11：我应该变得更快更好用，多学学 Webkit 的特性。还要支持更多人性化的小功能。</span><br><span class=\"line\"></span><br><span class=\"line\">用户：还有呢？</span><br><span class=\"line\"></span><br><span class=\"line\">IE11：还有？</span><br><span class=\"line\"></span><br><span class=\"line\">用户：你果然不知道自己错哪，哼╭(╯^╰)╮</span><br><span class=\"line\"></span><br><span class=\"line\">IE11：你听我解释。</span><br><span class=\"line\"></span><br><span class=\"line\">用户：我不听我不听我不听。你肯定是仗着店大欺客，哼。</span><br><span class=\"line\"></span><br><span class=\"line\">IE11：。。。</span><br><span class=\"line\"></span><br><span class=\"line\">用户：我信你一回。</span><br><span class=\"line\"></span><br><span class=\"line\">（5分钟后）</span><br><span class=\"line\"></span><br><span class=\"line\">用户：怎么提示我没 Flash？我装了啊！然后下载最新版竟然提示我只能在 Windows Update 更新！好麻烦！不用了！</span><br><span class=\"line\"></span><br><span class=\"line\">IE11：。。。</span><br><span class=\"line\"></span><br><span class=\"line\">IE11：试图减轻用户负担预装 Flash 并集成到 Windows Update 里了，谁知 道Adobe 家几天一更新坑我。。。玩脱了。。。</span><br><span class=\"line\"></span><br><span class=\"line\">用户：果然不行，哼╭(╯^╰)╮</span><br></pre></td></tr></table></figure>\n<p>其实这个才是微软急需解决的问题吧。。。</p>\n","excerpt":"<p>昨天凌晨在微软的产品发布会上大家知道搭载在 Windows 10 上的默认浏览器已经从 IE 变成了 Spartan —— 一个完全全新的产品。伴随我们日日夜夜，从当年最牛的主流浏览器最后走向用来安装其他浏览器的浏览器的IE终于走到了它人生的尾声。</p>\n<p>但是就我看来，Spartan 完全不是全新的产品，它其实就是IE 12。如果把它看成全新的产品，其实 IE 11 就已经焕然一新了，只不过大家早已经都忘了它。质疑 IE 显示各种不符合 W3C 的兼容性问题和吐槽性能差的同学我想有很多，但是我想问一个问题：“IE 11 的时候，真的还有这些问题吗？”</p>\n<p>我记得去年10月的时候我讲了一个笑话：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">虽然现在微软的IE11浏览器相较之前版本已经有了很大的进步，但是用户的普遍接受度已经不高。主要是IE6之后微软对IE的放置play已经使得IE这个品牌给用户留下了一个很不好的印象。我觉得一个比较好的办法是微软换一个浏览器品牌的名字，开个发布会，说一段什么“重归创业，情怀浏览”之类的话其实就好了嘛。。。至于换什么名字逼格比较高的话。。。不如叫iE吧。。。</span><br></pre></td></tr></table></figure>\n<p>万万没想到的是，它应验了，IE真的改了名。而这背后，其实隐藏了一个历史悠久却又非常悲伤的故事……</p>\n<p><del>闹了半天你们不就是喜欢听故事嘛，我讲，我讲还不行嘛。</del></p>","more":"<p>IE 是作为 Netscape 的绝对竞争对手而出现的，其目的就是为了抢占 Netscape 在浏览器市场上的份额，使得微软能自己掌控互联网的入口。等到 Netscape 退出历史舞台后基本上很难有大竞争对手了。（当时继承了 Netscape 衣钵的 Firefox 还很小众，而 Chrome 根本没出现）<strong>尤其是IE6之后，微软已经占据了几乎全部的市场份额，</strong>已经没有更大的商业价值可以挖掘了。你现在可能认为 IE 6 是一个很烂的产品，但是那是因为你以现在的眼光在看问题。如果你以当时的眼光来看，以当时的电脑性能并和其他浏览器相比，IE6是那个时代最棒的浏览器了。IE 已经不再是微软要解决的棘手问题了，原先IE团队中的大牛也基本走得差不多，他们接下来要做的是不过是来维持这个产品的统治地位。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">入则无法家拂士，出则无敌国外患者，国恒亡。然后知生于忧患而死于安乐者也。——《孟子·告子下》</span><br></pre></td></tr></table></figure>\n<p>微软用血与泪的教训向我们验证了这句话。IE 7、IE 8 的 IE 几乎就是一个完全的消极防守的状态。却不知道，世界格局正在发生悄悄的变化。苹果与 KHTML 的矛盾激化严重，使得苹果彻底与 KHTML 决裂不再合并代码，从而开启了另一分支，这一分支就是后来的 Webkit。这个内核随着 KDE 开发者的加入逐渐壮大，而 KHTML 逐渐衰落。之后，在 2005 年左右，Webkit 宣布了全面开源，之后 Google 发布的Google Chrome 浏览器更是使用了这一内核。随着 Google 的加入，竞争进入了白热化的境地。Google 之后推出了 V8 Javascript 渲染引擎更是将浏览器速度提升到了一个新的高度。从 2009 年到 2014 年，IE 的市场份额从 70% 降低到了接近 20%。微软丢失的市场被 Chrome、Firefox、Opera、Safari 一同吃得干干净净。<br>同时微软不义的举动再次成为千夫所指，所谓的不义就是浏览器没有按照 W3C 的开发标准来，对开发人员设计网页造成了很大的影响。根据标准设计的网页无法在 IE 上正常显示，不得不做出修改从而使得其他按照标准来的浏览器显示出错。但是请问了，对于一个市场占用超过 70% 的浏览器而言，谁才是真正的标准？在 IE 最红火的年代，W3C 的标准更像是装饰，而当微软份额丢尽时成为了推倒 IE 大山的罪证。并且，随着 HTML5 标准的进一步完善，各家都抢先在支持 HTML5 的新特性。因为 HTML4 标准已经很久远，不能满足日常所需。网页显示个视频都要依靠 Flash，浏览器不能掌握性能的生杀大权，HTML5 标准的提出显然是被各家所支持和推荐的。<br>到了 IE 9 的时候，微软终于意识到了事态的严重。微软已经从一个领头者成为了落后者。于是 IE 9 开始微软重振旗鼓要搞浏览器。在 IE 9 发布时，微软也提出了要跟进 HTML5，并且展示了许多 IE 9 兼容的 HTML5 新特性。但是除了这些新特性外，旧特性依然没有按照标准在走，所以没有得到市场的肯定。到了 IE 10，微软则进一步完善了自己浏览器的渲染，使得 IE 也紧跟上了标准的步伐，以求得市场的认同。<br>但是 IE 10 之后，微软发现了新的问题。<br>大量网页依然无法在 IE 10 上良好渲染。其问题并不是 IE 10 没跟着标准走，而是网页大量调用了 Webkit 内核支持的私有功能。因为如今除了 IE 和 Firefox，市面上几乎其它所有浏览器都是 Webkit 内核的。而 Firefox 也支持了一部分 Webkit 的私有功能。跟着标准走的 IE 再次吃了大亏。其实根本没有什么标准，谁有市场的主导权，谁就是标准。如今Chrome、Safari、Opera（当时 Opera 也转投了 Webkit 阵营）都在使用的 Webkit 内核成为了真正的市场主导者。他们功能中不符合 W3C 标准的地方却丝毫没人提出。<br>市场不会允许一次一次再一次的失败。IE 11 在技术上已经被微软孤注一掷，其核心团队几乎都是微软最顶尖的大牛。IE 11 不但要符合了 W3C 的标准，甚至在 IE 中实现了大量 Webkit 内核中才有的私有功能，全新的 Javascript 渲染引擎，速度已经走到了大家的平均水平，在开发人员工具等细节功能上更是做得非常到位。但这一代的 IE 恰恰安排在了让人理不清操作逻辑的 Windows 8 上。这一代 Windows 是让人失望的，而 IE 则更是被人遗忘在了不知道哪个角落里。纵使 IE 11 的速度已经不再慢、兼容性不再差、甚至有些地方做得还更好，甚至和 Chrome 那一卡一顿的滚动时的帧率问题比起来，IE 的滚动已经能和 Safari 一样流畅了。但生在被命运捉弄的 Windows 8 上，生在一个已经不属于它的世界上，IE 11 已经什么都没有了。很多人连 IE 都没怎么好好用过就把 IE 当作了慢、卡、不兼容的代名词。纵使在技术上下了大工夫，却还是失败了。<br>既然今天的 IE 已经和昨天有了翻天覆地的变化成为了完全不同的产品，但还是已经被人下了这样的定义，那么只有一条路可以走——改名。所以搭载在 Windows 10 上的浏览器不再是 IE 而是 Spartan，至少一个新名字可以告诉别人，它真的不是原来那个样子了。</p>\n<p>不过我倒是觉得微软要做的可能不止这点。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IE9：我错了。</span><br><span class=\"line\"></span><br><span class=\"line\">用户：知道错哪了吗？</span><br><span class=\"line\"></span><br><span class=\"line\">IE9：我应该支持更多新功能的。</span><br><span class=\"line\"></span><br><span class=\"line\">用户：还有呢？</span><br><span class=\"line\"></span><br><span class=\"line\">IE9：还有？</span><br><span class=\"line\"></span><br><span class=\"line\">用户：你果然不知道自己错哪，哼╭(╯^╰)╮</span><br><span class=\"line\"></span><br><span class=\"line\">IE10：我错了。</span><br><span class=\"line\"></span><br><span class=\"line\">用户：知道错哪了吗？</span><br><span class=\"line\"></span><br><span class=\"line\">IE10：我应该更多兼容标准的。</span><br><span class=\"line\"></span><br><span class=\"line\">用户：还有呢？</span><br><span class=\"line\"></span><br><span class=\"line\">IE10：还有？</span><br><span class=\"line\"></span><br><span class=\"line\">用户：你果然不知道自己错哪，哼╭(╯^╰)╮</span><br><span class=\"line\"></span><br><span class=\"line\">IE11：我错了。</span><br><span class=\"line\"></span><br><span class=\"line\">用户：知道错哪了吗？</span><br><span class=\"line\"></span><br><span class=\"line\">IE11：我应该变得更快更好用，多学学 Webkit 的特性。还要支持更多人性化的小功能。</span><br><span class=\"line\"></span><br><span class=\"line\">用户：还有呢？</span><br><span class=\"line\"></span><br><span class=\"line\">IE11：还有？</span><br><span class=\"line\"></span><br><span class=\"line\">用户：你果然不知道自己错哪，哼╭(╯^╰)╮</span><br><span class=\"line\"></span><br><span class=\"line\">IE11：你听我解释。</span><br><span class=\"line\"></span><br><span class=\"line\">用户：我不听我不听我不听。你肯定是仗着店大欺客，哼。</span><br><span class=\"line\"></span><br><span class=\"line\">IE11：。。。</span><br><span class=\"line\"></span><br><span class=\"line\">用户：我信你一回。</span><br><span class=\"line\"></span><br><span class=\"line\">（5分钟后）</span><br><span class=\"line\"></span><br><span class=\"line\">用户：怎么提示我没 Flash？我装了啊！然后下载最新版竟然提示我只能在 Windows Update 更新！好麻烦！不用了！</span><br><span class=\"line\"></span><br><span class=\"line\">IE11：。。。</span><br><span class=\"line\"></span><br><span class=\"line\">IE11：试图减轻用户负担预装 Flash 并集成到 Windows Update 里了，谁知 道Adobe 家几天一更新坑我。。。玩脱了。。。</span><br><span class=\"line\"></span><br><span class=\"line\">用户：果然不行，哼╭(╯^╰)╮</span><br></pre></td></tr></table></figure>\n<p>其实这个才是微软急需解决的问题吧。。。</p>"},{"title":"HeckPsi 2016 全新博客系统","date":"2016-04-21T14:56:14.000Z","dsc":"HeckPsi 博客 2016 迎来了巨大的改版！","_content":"\n***HeckPsi 博客 2016 迎来了巨大的改版！***\n\n<!--more-->\n\n### 这是个啥？\n\n正如你所见，HeckPsi 的全新博客系统变得非常地 *清新* 。在深思熟虑之后，我们发现，以前的主页，看似非常炫酷，实则净是废话。于是借由 HeckPsi 主页改版的机会，HeckPsi 博客系统也迎来了巨大的更新！\n\n#### 这个博客用来干什么？\n\n1. 发布对于业内见闻的评论\n2. 发布对科技相关的科普\n3. 发布我们所坚持的价值观\n4. ~~瞎搞~~ 实验性内容\n\n#### 所以，我们的博客需要什么\n\n1. 清晰高效的排版\n2. 便于快速编辑（Markdown 什么的最好，可视化编辑器太累）\n3. 静态化的页面\n\n于是就有了现在你所看到的博客系统。它使用了 [hexo](https://github.com/hexojs/hexo) 项目生成静态页面，以及使用了 [hexo-theme-apolo](https://github.com/pinggod/hexo-theme-apollo) 项目的主题，并进行了一定地定制开发。\n\n相比之下，我们拥有了更加强大地对网站的控制权利，可以做更多地功能模块的定制，以进一步满足我们未来的要求。至于为什么没有使用 [Jekyll](https://jekyllrb.com/) ，单纯是因为 hexo 更适合做博客，而 Jekyll 什么都适合做，有些无从下手。\n\n### 停更的几个月发生了啥？\n\n首先，HeckPsi 成立了在国内注册的公司，并以此申请了备案。所以我们的服务器现在可以运行在中华人民共和国境内，以提供更快的服务。\n\n其次，我们深刻考虑了我们未来的业务形态。最近也将会有比较大的动向，开出某个全新的板块，以及某些神秘的产品，尽请期待。\n\n最后就是旧博客的数据之前放在 AWS Japan 上，出了一些小问题，差点丢失。幸好已经通过完备的日志系统还原了大部分数据，并且将于近期还原。未来我们的博客数据都会实现多点异地备份，保证其安全性。\n\n\n\n**承蒙各位厚爱，HeckPsi 会坚持做下去。**","source":"_posts/heckpsi-blog-2016.md","raw":"---\ntitle: HeckPsi 2016 全新博客系统\ndate: 2016-04-21 22:56:14\ndsc: HeckPsi 博客 2016 迎来了巨大的改版！\ntags: 站务\n---\n\n***HeckPsi 博客 2016 迎来了巨大的改版！***\n\n<!--more-->\n\n### 这是个啥？\n\n正如你所见，HeckPsi 的全新博客系统变得非常地 *清新* 。在深思熟虑之后，我们发现，以前的主页，看似非常炫酷，实则净是废话。于是借由 HeckPsi 主页改版的机会，HeckPsi 博客系统也迎来了巨大的更新！\n\n#### 这个博客用来干什么？\n\n1. 发布对于业内见闻的评论\n2. 发布对科技相关的科普\n3. 发布我们所坚持的价值观\n4. ~~瞎搞~~ 实验性内容\n\n#### 所以，我们的博客需要什么\n\n1. 清晰高效的排版\n2. 便于快速编辑（Markdown 什么的最好，可视化编辑器太累）\n3. 静态化的页面\n\n于是就有了现在你所看到的博客系统。它使用了 [hexo](https://github.com/hexojs/hexo) 项目生成静态页面，以及使用了 [hexo-theme-apolo](https://github.com/pinggod/hexo-theme-apollo) 项目的主题，并进行了一定地定制开发。\n\n相比之下，我们拥有了更加强大地对网站的控制权利，可以做更多地功能模块的定制，以进一步满足我们未来的要求。至于为什么没有使用 [Jekyll](https://jekyllrb.com/) ，单纯是因为 hexo 更适合做博客，而 Jekyll 什么都适合做，有些无从下手。\n\n### 停更的几个月发生了啥？\n\n首先，HeckPsi 成立了在国内注册的公司，并以此申请了备案。所以我们的服务器现在可以运行在中华人民共和国境内，以提供更快的服务。\n\n其次，我们深刻考虑了我们未来的业务形态。最近也将会有比较大的动向，开出某个全新的板块，以及某些神秘的产品，尽请期待。\n\n最后就是旧博客的数据之前放在 AWS Japan 上，出了一些小问题，差点丢失。幸好已经通过完备的日志系统还原了大部分数据，并且将于近期还原。未来我们的博客数据都会实现多点异地备份，保证其安全性。\n\n\n\n**承蒙各位厚爱，HeckPsi 会坚持做下去。**","slug":"heckpsi-blog-2016","published":1,"updated":"2016-04-21T15:36:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscy0090000npp8zl7r36npw","content":"<p><strong><em>HeckPsi 博客 2016 迎来了巨大的改版！</em></strong></p>\n<a id=\"more\"></a>\n<h3 id=\"这是个啥？\"><a href=\"#这是个啥？\" class=\"headerlink\" title=\"这是个啥？\"></a>这是个啥？</h3><p>正如你所见，HeckPsi 的全新博客系统变得非常地 <em>清新</em> 。在深思熟虑之后，我们发现，以前的主页，看似非常炫酷，实则净是废话。于是借由 HeckPsi 主页改版的机会，HeckPsi 博客系统也迎来了巨大的更新！</p>\n<h4 id=\"这个博客用来干什么？\"><a href=\"#这个博客用来干什么？\" class=\"headerlink\" title=\"这个博客用来干什么？\"></a>这个博客用来干什么？</h4><ol>\n<li>发布对于业内见闻的评论</li>\n<li>发布对科技相关的科普</li>\n<li>发布我们所坚持的价值观</li>\n<li><del>瞎搞</del> 实验性内容</li>\n</ol>\n<h4 id=\"所以，我们的博客需要什么\"><a href=\"#所以，我们的博客需要什么\" class=\"headerlink\" title=\"所以，我们的博客需要什么\"></a>所以，我们的博客需要什么</h4><ol>\n<li>清晰高效的排版</li>\n<li>便于快速编辑（Markdown 什么的最好，可视化编辑器太累）</li>\n<li>静态化的页面</li>\n</ol>\n<p>于是就有了现在你所看到的博客系统。它使用了 <a href=\"https://github.com/hexojs/hexo\" target=\"_blank\" rel=\"external\">hexo</a> 项目生成静态页面，以及使用了 <a href=\"https://github.com/pinggod/hexo-theme-apollo\" target=\"_blank\" rel=\"external\">hexo-theme-apolo</a> 项目的主题，并进行了一定地定制开发。</p>\n<p>相比之下，我们拥有了更加强大地对网站的控制权利，可以做更多地功能模块的定制，以进一步满足我们未来的要求。至于为什么没有使用 <a href=\"https://jekyllrb.com/\" target=\"_blank\" rel=\"external\">Jekyll</a> ，单纯是因为 hexo 更适合做博客，而 Jekyll 什么都适合做，有些无从下手。</p>\n<h3 id=\"停更的几个月发生了啥？\"><a href=\"#停更的几个月发生了啥？\" class=\"headerlink\" title=\"停更的几个月发生了啥？\"></a>停更的几个月发生了啥？</h3><p>首先，HeckPsi 成立了在国内注册的公司，并以此申请了备案。所以我们的服务器现在可以运行在中华人民共和国境内，以提供更快的服务。</p>\n<p>其次，我们深刻考虑了我们未来的业务形态。最近也将会有比较大的动向，开出某个全新的板块，以及某些神秘的产品，尽请期待。</p>\n<p>最后就是旧博客的数据之前放在 AWS Japan 上，出了一些小问题，差点丢失。幸好已经通过完备的日志系统还原了大部分数据，并且将于近期还原。未来我们的博客数据都会实现多点异地备份，保证其安全性。</p>\n<p><strong>承蒙各位厚爱，HeckPsi 会坚持做下去。</strong></p>\n","excerpt":"<p><strong><em>HeckPsi 博客 2016 迎来了巨大的改版！</em></strong></p>","more":"<h3 id=\"这是个啥？\"><a href=\"#这是个啥？\" class=\"headerlink\" title=\"这是个啥？\"></a>这是个啥？</h3><p>正如你所见，HeckPsi 的全新博客系统变得非常地 <em>清新</em> 。在深思熟虑之后，我们发现，以前的主页，看似非常炫酷，实则净是废话。于是借由 HeckPsi 主页改版的机会，HeckPsi 博客系统也迎来了巨大的更新！</p>\n<h4 id=\"这个博客用来干什么？\"><a href=\"#这个博客用来干什么？\" class=\"headerlink\" title=\"这个博客用来干什么？\"></a>这个博客用来干什么？</h4><ol>\n<li>发布对于业内见闻的评论</li>\n<li>发布对科技相关的科普</li>\n<li>发布我们所坚持的价值观</li>\n<li><del>瞎搞</del> 实验性内容</li>\n</ol>\n<h4 id=\"所以，我们的博客需要什么\"><a href=\"#所以，我们的博客需要什么\" class=\"headerlink\" title=\"所以，我们的博客需要什么\"></a>所以，我们的博客需要什么</h4><ol>\n<li>清晰高效的排版</li>\n<li>便于快速编辑（Markdown 什么的最好，可视化编辑器太累）</li>\n<li>静态化的页面</li>\n</ol>\n<p>于是就有了现在你所看到的博客系统。它使用了 <a href=\"https://github.com/hexojs/hexo\">hexo</a> 项目生成静态页面，以及使用了 <a href=\"https://github.com/pinggod/hexo-theme-apollo\">hexo-theme-apolo</a> 项目的主题，并进行了一定地定制开发。</p>\n<p>相比之下，我们拥有了更加强大地对网站的控制权利，可以做更多地功能模块的定制，以进一步满足我们未来的要求。至于为什么没有使用 <a href=\"https://jekyllrb.com/\">Jekyll</a> ，单纯是因为 hexo 更适合做博客，而 Jekyll 什么都适合做，有些无从下手。</p>\n<h3 id=\"停更的几个月发生了啥？\"><a href=\"#停更的几个月发生了啥？\" class=\"headerlink\" title=\"停更的几个月发生了啥？\"></a>停更的几个月发生了啥？</h3><p>首先，HeckPsi 成立了在国内注册的公司，并以此申请了备案。所以我们的服务器现在可以运行在中华人民共和国境内，以提供更快的服务。</p>\n<p>其次，我们深刻考虑了我们未来的业务形态。最近也将会有比较大的动向，开出某个全新的板块，以及某些神秘的产品，尽请期待。</p>\n<p>最后就是旧博客的数据之前放在 AWS Japan 上，出了一些小问题，差点丢失。幸好已经通过完备的日志系统还原了大部分数据，并且将于近期还原。未来我们的博客数据都会实现多点异地备份，保证其安全性。</p>\n<p><strong>承蒙各位厚爱，HeckPsi 会坚持做下去。</strong></p>"},{"title":"AlphaGo 是怎么下棋的？","date":"2016-03-18T15:09:00.000Z","dsc":"看到很多网友以及一些围棋职业选手提出了一些疑问，比如「Google 没有顶尖的棋手为什么能开发出顶尖的围棋机器人？」还有「机械为什么可以在如此直觉主导的游戏中战胜人类？」。这些问题事实上在人工智能领域已经有很多理论来做解释。","_content":"\n## 前言\n\n本来其实不想写这个的，但是看到很多网友以及一些围棋职业选手提出了一些疑问，比如「Google 没有顶尖的棋手为什么能开发出顶尖的围棋机器人？」还有「机械为什么可以在如此直觉主导的游戏中战胜人类？」。这些问题事实上在人工智能领域已经有很多理论来做解释。而且这些理论也并不是 Google 提出的。AlphaGo 所使用的理论大多还是十余年前左右的论文的一些成果。在此之前，使用了这些理论开发出来的人工智能其实已经在 2006 年就已经在 9x9 的小棋盘上战胜周俊勋九段，之后在 2013 年 CrazyStone 程序就已经在让四子前提下战胜过石田芳夫九段，而就在去年，Facebook 的围棋机器人在不让子的前提下，胜过职业选手。至于之前「前百度深度学习研究院」的吴韧所开发的异构神机也使用的是类似的理论，也在前几天战胜过职业棋手。\n\n这些方法上，AlphaGo 并无太大创新，很大程度上是 Google 团队实现得相对完善以及训练程度更好，以及人工智能算法的实现和调参存在很大的偶然因素。那么究竟是什么方法让机械拥有了和人一样直觉，而不是简单的机械化的思考。这事我们还是要从头讲起。\n\n<!--more-->\n\n## 无法计算的数据量\n\n早在 1996 年，IBM 的深蓝计算机就战胜了国际象棋世界名将加里·卡斯帕罗夫。但象棋有一个特点，那就是每一步下的选择是相对非常有限的，最多也就十几种可能。哪怕是通过最最暴力的搜索方法，把每种都跑一遍，搜索几十步内的最优解。虽然这个方法随着搜索深度是指数级增长的，但事实上由于底数比饺小，依靠强大的算力还是可以解决的。而深蓝计算机正是这么一台拥有强大算力的超级计算机。\n\n然而在围棋上，这样就不行了，因为围棋每一步都有上百种选择，如此大的底数纯粹的暴力就显然无法满足了。至少硬件的发展并非每年成百倍成百倍地快速增长的。同样的方法，显然是不适合使用在围棋上的。\n\n在 2002 年之前，人们长期研究一个可以通过计算静态地分析出每一子的价值出来。然而这个方法的发展一直很慢。直到人们试图尝试一种动态评估一个博弈的一种方法，这就是靠**猜**。这个方法被称为蒙特卡洛搜索树，其前身是非常著名的上世纪曼哈顿计划期间由乌拉姆和冯·诺依曼提出的**蒙特卡洛方法**。\n\n如果我们想知道圆周率的值，我们如何利用猜的方法来猜出圆周率呢？我们只需要在一个方形中随机而均匀地扔飞镖，数一下，多少个飞镖扔在了以方形边长为直径的圆里，多少扔在了外面，根据圆的面积公式和方形的面积公式就能把 π 算出来。而蒙特卡洛搜索树就是利用蒙特卡洛方法来优化搜索树。简单来说，就是，我们认为这一步下在一个地方是最优的，而我们不知道这地方在哪里。我们先通过一系列随机的采样，从而去猜测一个值，这个值可能是最优解，也可能是一个接近最优解的解。但至少，这可以用来估算像围棋这样大的棋盘的东西了，而不需要把每个细枝末节都同等对待地来暴力搜索。\n\n## ⑨神的大局观\n\n解决完计算量的问题，我们还要来解决人类在围棋上最大的优势——直觉，或者说「大局观」。那么如何才能拥有大局观呢？我们想一下，人们在下围棋的时候，通常会先考虑下在哪个片区，以获得什么样的目的。而这就是所谓的大局观。\n\nAlphaGo 的另一部分重要思想，得益于神经科学的发展，即人类认识人大脑神经的发展。人类愈发了解了大脑内神经元的工作模式，包括人类学习、认知的神经模型。这样的非常基础的模型，极大地方便了利用计算机来模拟人类进行学习的过程。\n\n蒙特卡洛方法只是简化了计算，并不具备学习的能力。无论是单纯的蒙特卡洛搜索还是与 α-β 搜索结合的还是和置信区间结合一些版本，都与人类能越学越强的围棋技巧相比差上太多。至少，人脑是一个极其复杂的计算模型，哪怕是现在最好的计算机，其算力和整个大脑比起来还是差很多的。\n\n在 2007 年，一些科学家试图提出一个新的机器学习模型，即所谓的深度学习。所谓深度学习，你可以看做模拟许多许多人脑中的神经元构成的一个网络。网络的每一层，针对一个特性进行识别。网络的每一层，都是一个单纯分类的无监督学习模型。你可以想像一下，人眼看到一个图像。经过一系列神经元，首先识别出了里面的眼睛、然后识别了里面的鼻子、嘴，再根据这些特性，发现这是一个人。这样依次发现的机制。而学习是通过一个有监督的反向传播进行。即告诉你这张图像里有一条狗，然后反向的一步步调整网络，让网络适应符合怎么样鼻子、嘴、眼睛的是一条狗。通过不断地数据的训练，即可以让模型越来越优。这个模型在图像识别领域已经达到甚至有时超越了人的识别能力。\n\n而 AlphaGo 使用的就是深度学习来优化蒙特卡洛搜索树。在 AlphaGo 中有两个网络，一个是策略网络，一个是价值网络。策略网络即是一个大局观的网络，机器会先通过其经验，找出其应该做出进攻的反应还是防守的反应，表现在下在哪个片区是最为合适的，是不是应该跟棋之类的大问题。然后再通过蒙特卡洛搜索树去算出具体下在哪里是最合适的。\n\n而我们说到，深度学习模型是真的和人一样可以学习的。每下一次棋，它就可以进一步调优自己的策略网络。首先 AlphaGo 导入了上千个职业选手对弈的棋谱，使得自己有了一个基础的下棋策略。这时候的 AlphaGo 就和一个受过系统训练的围棋少年一样了。然而这和职业选手的区别还是很大。这也就是所谓的「Google 没有顶尖的棋手为什么能开发出顶尖的围棋机器人？」按照一般常理，AlphaGo 应该一段一段地和人挑战，越发提高自己能力。然而 AlphaGo 不是这么做的，它选择和自己对弈。两台 AlphaGo 来对弈，将对弈的结果调优自己的网络。这个听起来很奇怪，为什么两个下得都不怎么样的棋手一起下棋，棋艺能那么快提升呢？因为它一天能和自己下上百万盘棋，它可以把自己分身成几万份跑在几万台电脑上，以及可以昼夜不停也不会过劳死，而这是任何一个人类都做不到的。AlphaGo 的开发人员说，他曾在早期能下赢 AlphaGo，而很快，AlphaGo 的水平就远超了他。所以 AlphaGo 得到了飞速的提升。仅仅五六个月，AlphaGo 就能从战胜欧洲棋王挑战到世界顶尖选手的水平了。\n\n## 人工智能的基本法\n\n当然搞人工智能也要有基本法。这个基本法就是算力或者说是资源。虽然做了很大的优化，计算下围棋的计算量还是很大的。比起深蓝时依靠超级计算机来解决问题。AlphaGo 选择了一条适合 Google 的路径来解决算力问题。那就是分布式计算。使用分布式计算的 AlphaGo 版本比起不使用的版本其智能程度也是有相当大的提升。即使最简单，它也可以有更多时间来做随机的尝试，以找出更优的价值解。\n\n同样利用深度学习优化蒙特卡洛搜索的 Facebook 围棋团队，相比 Google 就没有那么壕力冲天了。无论是开发资源还是人员来说也是远少于 Google。Facebook 的围棋机器人之前也取得了相当好的成绩，大概可以击败职业二段选手的水平。但是比起 AlphaGo，还是差上许多。\n\n所以说，做这么一个人智能，背后的投入程度、重视程度也起到了很大的作用。这也是为什么深度学习目前做得很好的公司大多是一些顶尖的 IT 企业里的研发团队。\n\n## 后记\n\n比起 AlphaGo 在围棋上的成就，其实大多数人很好奇人工智能未来的何去何从。从这次中，我们看到计算机已经具备了人类大局判断能力，其本质是类似于人类的学习能力，即不告诉电脑应该怎么做，而让电脑看人类是怎么做的。这项的应用其实相当广泛，尤其在非常复杂的问题上。\n\n比如说，无人驾驶汽车之前发展很困难，是因为人们总是试图去把驾驶规则完全讲给电脑，而这点太过复杂，难以用纯逻辑说清。而今天 Google 的无人驾驶汽车也是使用的类似的深度学习的技术，让计算机观察人类开车并学习，从而模仿人类的判断。最终依靠计算机强大的算力和不会疲劳等特点，甚至超越人类的判断。\n\n短期来看，利用深度学习的人工智能在未来数年内将会得到很大的应用。而这也是 Google 热衷于下围棋的原因。醉翁之意不在酒，在乎山水之间也。Google 只是想利用围棋来显示他们在深度学习应用上的先进水平。\n\n就人工智能的最终目的来看，我们已经跨出了很大的一步。之前而言，我们很大程度局限于人类强大的抽象的思考能力，而模仿人类神经系统的模型已经很好地模拟了这种思考是怎么产生的了。进一步说，如果一个机器，拥有和人完全一样的眼睛、耳朵、鼻子、触觉等作为它的输入，以及类似于人类肌肉和关节的机械部件作为它的输出。并且模拟一个和人脑一样复杂程度的神经网络，并让它观察人类进行学习。是不是在某个未来，我们可以拥有和人类功能非常接近甚至超越人类的智能的出现。深度学习都为这样的强人工智能提出了理论上的基础。","source":"_posts/how-alphago-works.md","raw":"---\ntitle: AlphaGo 是怎么下棋的？\ndate: 2016-03-18 23:09:00\ndsc: 看到很多网友以及一些围棋职业选手提出了一些疑问，比如「Google 没有顶尖的棋手为什么能开发出顶尖的围棋机器人？」还有「机械为什么可以在如此直觉主导的游戏中战胜人类？」。这些问题事实上在人工智能领域已经有很多理论来做解释。\ntags: [AlphaGo,AI,Google,机器学习,科普]\n---\n\n## 前言\n\n本来其实不想写这个的，但是看到很多网友以及一些围棋职业选手提出了一些疑问，比如「Google 没有顶尖的棋手为什么能开发出顶尖的围棋机器人？」还有「机械为什么可以在如此直觉主导的游戏中战胜人类？」。这些问题事实上在人工智能领域已经有很多理论来做解释。而且这些理论也并不是 Google 提出的。AlphaGo 所使用的理论大多还是十余年前左右的论文的一些成果。在此之前，使用了这些理论开发出来的人工智能其实已经在 2006 年就已经在 9x9 的小棋盘上战胜周俊勋九段，之后在 2013 年 CrazyStone 程序就已经在让四子前提下战胜过石田芳夫九段，而就在去年，Facebook 的围棋机器人在不让子的前提下，胜过职业选手。至于之前「前百度深度学习研究院」的吴韧所开发的异构神机也使用的是类似的理论，也在前几天战胜过职业棋手。\n\n这些方法上，AlphaGo 并无太大创新，很大程度上是 Google 团队实现得相对完善以及训练程度更好，以及人工智能算法的实现和调参存在很大的偶然因素。那么究竟是什么方法让机械拥有了和人一样直觉，而不是简单的机械化的思考。这事我们还是要从头讲起。\n\n<!--more-->\n\n## 无法计算的数据量\n\n早在 1996 年，IBM 的深蓝计算机就战胜了国际象棋世界名将加里·卡斯帕罗夫。但象棋有一个特点，那就是每一步下的选择是相对非常有限的，最多也就十几种可能。哪怕是通过最最暴力的搜索方法，把每种都跑一遍，搜索几十步内的最优解。虽然这个方法随着搜索深度是指数级增长的，但事实上由于底数比饺小，依靠强大的算力还是可以解决的。而深蓝计算机正是这么一台拥有强大算力的超级计算机。\n\n然而在围棋上，这样就不行了，因为围棋每一步都有上百种选择，如此大的底数纯粹的暴力就显然无法满足了。至少硬件的发展并非每年成百倍成百倍地快速增长的。同样的方法，显然是不适合使用在围棋上的。\n\n在 2002 年之前，人们长期研究一个可以通过计算静态地分析出每一子的价值出来。然而这个方法的发展一直很慢。直到人们试图尝试一种动态评估一个博弈的一种方法，这就是靠**猜**。这个方法被称为蒙特卡洛搜索树，其前身是非常著名的上世纪曼哈顿计划期间由乌拉姆和冯·诺依曼提出的**蒙特卡洛方法**。\n\n如果我们想知道圆周率的值，我们如何利用猜的方法来猜出圆周率呢？我们只需要在一个方形中随机而均匀地扔飞镖，数一下，多少个飞镖扔在了以方形边长为直径的圆里，多少扔在了外面，根据圆的面积公式和方形的面积公式就能把 π 算出来。而蒙特卡洛搜索树就是利用蒙特卡洛方法来优化搜索树。简单来说，就是，我们认为这一步下在一个地方是最优的，而我们不知道这地方在哪里。我们先通过一系列随机的采样，从而去猜测一个值，这个值可能是最优解，也可能是一个接近最优解的解。但至少，这可以用来估算像围棋这样大的棋盘的东西了，而不需要把每个细枝末节都同等对待地来暴力搜索。\n\n## ⑨神的大局观\n\n解决完计算量的问题，我们还要来解决人类在围棋上最大的优势——直觉，或者说「大局观」。那么如何才能拥有大局观呢？我们想一下，人们在下围棋的时候，通常会先考虑下在哪个片区，以获得什么样的目的。而这就是所谓的大局观。\n\nAlphaGo 的另一部分重要思想，得益于神经科学的发展，即人类认识人大脑神经的发展。人类愈发了解了大脑内神经元的工作模式，包括人类学习、认知的神经模型。这样的非常基础的模型，极大地方便了利用计算机来模拟人类进行学习的过程。\n\n蒙特卡洛方法只是简化了计算，并不具备学习的能力。无论是单纯的蒙特卡洛搜索还是与 α-β 搜索结合的还是和置信区间结合一些版本，都与人类能越学越强的围棋技巧相比差上太多。至少，人脑是一个极其复杂的计算模型，哪怕是现在最好的计算机，其算力和整个大脑比起来还是差很多的。\n\n在 2007 年，一些科学家试图提出一个新的机器学习模型，即所谓的深度学习。所谓深度学习，你可以看做模拟许多许多人脑中的神经元构成的一个网络。网络的每一层，针对一个特性进行识别。网络的每一层，都是一个单纯分类的无监督学习模型。你可以想像一下，人眼看到一个图像。经过一系列神经元，首先识别出了里面的眼睛、然后识别了里面的鼻子、嘴，再根据这些特性，发现这是一个人。这样依次发现的机制。而学习是通过一个有监督的反向传播进行。即告诉你这张图像里有一条狗，然后反向的一步步调整网络，让网络适应符合怎么样鼻子、嘴、眼睛的是一条狗。通过不断地数据的训练，即可以让模型越来越优。这个模型在图像识别领域已经达到甚至有时超越了人的识别能力。\n\n而 AlphaGo 使用的就是深度学习来优化蒙特卡洛搜索树。在 AlphaGo 中有两个网络，一个是策略网络，一个是价值网络。策略网络即是一个大局观的网络，机器会先通过其经验，找出其应该做出进攻的反应还是防守的反应，表现在下在哪个片区是最为合适的，是不是应该跟棋之类的大问题。然后再通过蒙特卡洛搜索树去算出具体下在哪里是最合适的。\n\n而我们说到，深度学习模型是真的和人一样可以学习的。每下一次棋，它就可以进一步调优自己的策略网络。首先 AlphaGo 导入了上千个职业选手对弈的棋谱，使得自己有了一个基础的下棋策略。这时候的 AlphaGo 就和一个受过系统训练的围棋少年一样了。然而这和职业选手的区别还是很大。这也就是所谓的「Google 没有顶尖的棋手为什么能开发出顶尖的围棋机器人？」按照一般常理，AlphaGo 应该一段一段地和人挑战，越发提高自己能力。然而 AlphaGo 不是这么做的，它选择和自己对弈。两台 AlphaGo 来对弈，将对弈的结果调优自己的网络。这个听起来很奇怪，为什么两个下得都不怎么样的棋手一起下棋，棋艺能那么快提升呢？因为它一天能和自己下上百万盘棋，它可以把自己分身成几万份跑在几万台电脑上，以及可以昼夜不停也不会过劳死，而这是任何一个人类都做不到的。AlphaGo 的开发人员说，他曾在早期能下赢 AlphaGo，而很快，AlphaGo 的水平就远超了他。所以 AlphaGo 得到了飞速的提升。仅仅五六个月，AlphaGo 就能从战胜欧洲棋王挑战到世界顶尖选手的水平了。\n\n## 人工智能的基本法\n\n当然搞人工智能也要有基本法。这个基本法就是算力或者说是资源。虽然做了很大的优化，计算下围棋的计算量还是很大的。比起深蓝时依靠超级计算机来解决问题。AlphaGo 选择了一条适合 Google 的路径来解决算力问题。那就是分布式计算。使用分布式计算的 AlphaGo 版本比起不使用的版本其智能程度也是有相当大的提升。即使最简单，它也可以有更多时间来做随机的尝试，以找出更优的价值解。\n\n同样利用深度学习优化蒙特卡洛搜索的 Facebook 围棋团队，相比 Google 就没有那么壕力冲天了。无论是开发资源还是人员来说也是远少于 Google。Facebook 的围棋机器人之前也取得了相当好的成绩，大概可以击败职业二段选手的水平。但是比起 AlphaGo，还是差上许多。\n\n所以说，做这么一个人智能，背后的投入程度、重视程度也起到了很大的作用。这也是为什么深度学习目前做得很好的公司大多是一些顶尖的 IT 企业里的研发团队。\n\n## 后记\n\n比起 AlphaGo 在围棋上的成就，其实大多数人很好奇人工智能未来的何去何从。从这次中，我们看到计算机已经具备了人类大局判断能力，其本质是类似于人类的学习能力，即不告诉电脑应该怎么做，而让电脑看人类是怎么做的。这项的应用其实相当广泛，尤其在非常复杂的问题上。\n\n比如说，无人驾驶汽车之前发展很困难，是因为人们总是试图去把驾驶规则完全讲给电脑，而这点太过复杂，难以用纯逻辑说清。而今天 Google 的无人驾驶汽车也是使用的类似的深度学习的技术，让计算机观察人类开车并学习，从而模仿人类的判断。最终依靠计算机强大的算力和不会疲劳等特点，甚至超越人类的判断。\n\n短期来看，利用深度学习的人工智能在未来数年内将会得到很大的应用。而这也是 Google 热衷于下围棋的原因。醉翁之意不在酒，在乎山水之间也。Google 只是想利用围棋来显示他们在深度学习应用上的先进水平。\n\n就人工智能的最终目的来看，我们已经跨出了很大的一步。之前而言，我们很大程度局限于人类强大的抽象的思考能力，而模仿人类神经系统的模型已经很好地模拟了这种思考是怎么产生的了。进一步说，如果一个机器，拥有和人完全一样的眼睛、耳朵、鼻子、触觉等作为它的输入，以及类似于人类肌肉和关节的机械部件作为它的输出。并且模拟一个和人脑一样复杂程度的神经网络，并让它观察人类进行学习。是不是在某个未来，我们可以拥有和人类功能非常接近甚至超越人类的智能的出现。深度学习都为这样的强人工智能提出了理论上的基础。","slug":"how-alphago-works","published":1,"updated":"2016-04-21T17:15:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscy0092000opp8z4rs0lln5","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本来其实不想写这个的，但是看到很多网友以及一些围棋职业选手提出了一些疑问，比如「Google 没有顶尖的棋手为什么能开发出顶尖的围棋机器人？」还有「机械为什么可以在如此直觉主导的游戏中战胜人类？」。这些问题事实上在人工智能领域已经有很多理论来做解释。而且这些理论也并不是 Google 提出的。AlphaGo 所使用的理论大多还是十余年前左右的论文的一些成果。在此之前，使用了这些理论开发出来的人工智能其实已经在 2006 年就已经在 9x9 的小棋盘上战胜周俊勋九段，之后在 2013 年 CrazyStone 程序就已经在让四子前提下战胜过石田芳夫九段，而就在去年，Facebook 的围棋机器人在不让子的前提下，胜过职业选手。至于之前「前百度深度学习研究院」的吴韧所开发的异构神机也使用的是类似的理论，也在前几天战胜过职业棋手。</p>\n<p>这些方法上，AlphaGo 并无太大创新，很大程度上是 Google 团队实现得相对完善以及训练程度更好，以及人工智能算法的实现和调参存在很大的偶然因素。那么究竟是什么方法让机械拥有了和人一样直觉，而不是简单的机械化的思考。这事我们还是要从头讲起。</p>\n<a id=\"more\"></a>\n<h2 id=\"无法计算的数据量\"><a href=\"#无法计算的数据量\" class=\"headerlink\" title=\"无法计算的数据量\"></a>无法计算的数据量</h2><p>早在 1996 年，IBM 的深蓝计算机就战胜了国际象棋世界名将加里·卡斯帕罗夫。但象棋有一个特点，那就是每一步下的选择是相对非常有限的，最多也就十几种可能。哪怕是通过最最暴力的搜索方法，把每种都跑一遍，搜索几十步内的最优解。虽然这个方法随着搜索深度是指数级增长的，但事实上由于底数比饺小，依靠强大的算力还是可以解决的。而深蓝计算机正是这么一台拥有强大算力的超级计算机。</p>\n<p>然而在围棋上，这样就不行了，因为围棋每一步都有上百种选择，如此大的底数纯粹的暴力就显然无法满足了。至少硬件的发展并非每年成百倍成百倍地快速增长的。同样的方法，显然是不适合使用在围棋上的。</p>\n<p>在 2002 年之前，人们长期研究一个可以通过计算静态地分析出每一子的价值出来。然而这个方法的发展一直很慢。直到人们试图尝试一种动态评估一个博弈的一种方法，这就是靠<strong>猜</strong>。这个方法被称为蒙特卡洛搜索树，其前身是非常著名的上世纪曼哈顿计划期间由乌拉姆和冯·诺依曼提出的<strong>蒙特卡洛方法</strong>。</p>\n<p>如果我们想知道圆周率的值，我们如何利用猜的方法来猜出圆周率呢？我们只需要在一个方形中随机而均匀地扔飞镖，数一下，多少个飞镖扔在了以方形边长为直径的圆里，多少扔在了外面，根据圆的面积公式和方形的面积公式就能把 π 算出来。而蒙特卡洛搜索树就是利用蒙特卡洛方法来优化搜索树。简单来说，就是，我们认为这一步下在一个地方是最优的，而我们不知道这地方在哪里。我们先通过一系列随机的采样，从而去猜测一个值，这个值可能是最优解，也可能是一个接近最优解的解。但至少，这可以用来估算像围棋这样大的棋盘的东西了，而不需要把每个细枝末节都同等对待地来暴力搜索。</p>\n<h2 id=\"⑨神的大局观\"><a href=\"#⑨神的大局观\" class=\"headerlink\" title=\"⑨神的大局观\"></a>⑨神的大局观</h2><p>解决完计算量的问题，我们还要来解决人类在围棋上最大的优势——直觉，或者说「大局观」。那么如何才能拥有大局观呢？我们想一下，人们在下围棋的时候，通常会先考虑下在哪个片区，以获得什么样的目的。而这就是所谓的大局观。</p>\n<p>AlphaGo 的另一部分重要思想，得益于神经科学的发展，即人类认识人大脑神经的发展。人类愈发了解了大脑内神经元的工作模式，包括人类学习、认知的神经模型。这样的非常基础的模型，极大地方便了利用计算机来模拟人类进行学习的过程。</p>\n<p>蒙特卡洛方法只是简化了计算，并不具备学习的能力。无论是单纯的蒙特卡洛搜索还是与 α-β 搜索结合的还是和置信区间结合一些版本，都与人类能越学越强的围棋技巧相比差上太多。至少，人脑是一个极其复杂的计算模型，哪怕是现在最好的计算机，其算力和整个大脑比起来还是差很多的。</p>\n<p>在 2007 年，一些科学家试图提出一个新的机器学习模型，即所谓的深度学习。所谓深度学习，你可以看做模拟许多许多人脑中的神经元构成的一个网络。网络的每一层，针对一个特性进行识别。网络的每一层，都是一个单纯分类的无监督学习模型。你可以想像一下，人眼看到一个图像。经过一系列神经元，首先识别出了里面的眼睛、然后识别了里面的鼻子、嘴，再根据这些特性，发现这是一个人。这样依次发现的机制。而学习是通过一个有监督的反向传播进行。即告诉你这张图像里有一条狗，然后反向的一步步调整网络，让网络适应符合怎么样鼻子、嘴、眼睛的是一条狗。通过不断地数据的训练，即可以让模型越来越优。这个模型在图像识别领域已经达到甚至有时超越了人的识别能力。</p>\n<p>而 AlphaGo 使用的就是深度学习来优化蒙特卡洛搜索树。在 AlphaGo 中有两个网络，一个是策略网络，一个是价值网络。策略网络即是一个大局观的网络，机器会先通过其经验，找出其应该做出进攻的反应还是防守的反应，表现在下在哪个片区是最为合适的，是不是应该跟棋之类的大问题。然后再通过蒙特卡洛搜索树去算出具体下在哪里是最合适的。</p>\n<p>而我们说到，深度学习模型是真的和人一样可以学习的。每下一次棋，它就可以进一步调优自己的策略网络。首先 AlphaGo 导入了上千个职业选手对弈的棋谱，使得自己有了一个基础的下棋策略。这时候的 AlphaGo 就和一个受过系统训练的围棋少年一样了。然而这和职业选手的区别还是很大。这也就是所谓的「Google 没有顶尖的棋手为什么能开发出顶尖的围棋机器人？」按照一般常理，AlphaGo 应该一段一段地和人挑战，越发提高自己能力。然而 AlphaGo 不是这么做的，它选择和自己对弈。两台 AlphaGo 来对弈，将对弈的结果调优自己的网络。这个听起来很奇怪，为什么两个下得都不怎么样的棋手一起下棋，棋艺能那么快提升呢？因为它一天能和自己下上百万盘棋，它可以把自己分身成几万份跑在几万台电脑上，以及可以昼夜不停也不会过劳死，而这是任何一个人类都做不到的。AlphaGo 的开发人员说，他曾在早期能下赢 AlphaGo，而很快，AlphaGo 的水平就远超了他。所以 AlphaGo 得到了飞速的提升。仅仅五六个月，AlphaGo 就能从战胜欧洲棋王挑战到世界顶尖选手的水平了。</p>\n<h2 id=\"人工智能的基本法\"><a href=\"#人工智能的基本法\" class=\"headerlink\" title=\"人工智能的基本法\"></a>人工智能的基本法</h2><p>当然搞人工智能也要有基本法。这个基本法就是算力或者说是资源。虽然做了很大的优化，计算下围棋的计算量还是很大的。比起深蓝时依靠超级计算机来解决问题。AlphaGo 选择了一条适合 Google 的路径来解决算力问题。那就是分布式计算。使用分布式计算的 AlphaGo 版本比起不使用的版本其智能程度也是有相当大的提升。即使最简单，它也可以有更多时间来做随机的尝试，以找出更优的价值解。</p>\n<p>同样利用深度学习优化蒙特卡洛搜索的 Facebook 围棋团队，相比 Google 就没有那么壕力冲天了。无论是开发资源还是人员来说也是远少于 Google。Facebook 的围棋机器人之前也取得了相当好的成绩，大概可以击败职业二段选手的水平。但是比起 AlphaGo，还是差上许多。</p>\n<p>所以说，做这么一个人智能，背后的投入程度、重视程度也起到了很大的作用。这也是为什么深度学习目前做得很好的公司大多是一些顶尖的 IT 企业里的研发团队。</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>比起 AlphaGo 在围棋上的成就，其实大多数人很好奇人工智能未来的何去何从。从这次中，我们看到计算机已经具备了人类大局判断能力，其本质是类似于人类的学习能力，即不告诉电脑应该怎么做，而让电脑看人类是怎么做的。这项的应用其实相当广泛，尤其在非常复杂的问题上。</p>\n<p>比如说，无人驾驶汽车之前发展很困难，是因为人们总是试图去把驾驶规则完全讲给电脑，而这点太过复杂，难以用纯逻辑说清。而今天 Google 的无人驾驶汽车也是使用的类似的深度学习的技术，让计算机观察人类开车并学习，从而模仿人类的判断。最终依靠计算机强大的算力和不会疲劳等特点，甚至超越人类的判断。</p>\n<p>短期来看，利用深度学习的人工智能在未来数年内将会得到很大的应用。而这也是 Google 热衷于下围棋的原因。醉翁之意不在酒，在乎山水之间也。Google 只是想利用围棋来显示他们在深度学习应用上的先进水平。</p>\n<p>就人工智能的最终目的来看，我们已经跨出了很大的一步。之前而言，我们很大程度局限于人类强大的抽象的思考能力，而模仿人类神经系统的模型已经很好地模拟了这种思考是怎么产生的了。进一步说，如果一个机器，拥有和人完全一样的眼睛、耳朵、鼻子、触觉等作为它的输入，以及类似于人类肌肉和关节的机械部件作为它的输出。并且模拟一个和人脑一样复杂程度的神经网络，并让它观察人类进行学习。是不是在某个未来，我们可以拥有和人类功能非常接近甚至超越人类的智能的出现。深度学习都为这样的强人工智能提出了理论上的基础。</p>\n","excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本来其实不想写这个的，但是看到很多网友以及一些围棋职业选手提出了一些疑问，比如「Google 没有顶尖的棋手为什么能开发出顶尖的围棋机器人？」还有「机械为什么可以在如此直觉主导的游戏中战胜人类？」。这些问题事实上在人工智能领域已经有很多理论来做解释。而且这些理论也并不是 Google 提出的。AlphaGo 所使用的理论大多还是十余年前左右的论文的一些成果。在此之前，使用了这些理论开发出来的人工智能其实已经在 2006 年就已经在 9x9 的小棋盘上战胜周俊勋九段，之后在 2013 年 CrazyStone 程序就已经在让四子前提下战胜过石田芳夫九段，而就在去年，Facebook 的围棋机器人在不让子的前提下，胜过职业选手。至于之前「前百度深度学习研究院」的吴韧所开发的异构神机也使用的是类似的理论，也在前几天战胜过职业棋手。</p>\n<p>这些方法上，AlphaGo 并无太大创新，很大程度上是 Google 团队实现得相对完善以及训练程度更好，以及人工智能算法的实现和调参存在很大的偶然因素。那么究竟是什么方法让机械拥有了和人一样直觉，而不是简单的机械化的思考。这事我们还是要从头讲起。</p>","more":"<h2 id=\"无法计算的数据量\"><a href=\"#无法计算的数据量\" class=\"headerlink\" title=\"无法计算的数据量\"></a>无法计算的数据量</h2><p>早在 1996 年，IBM 的深蓝计算机就战胜了国际象棋世界名将加里·卡斯帕罗夫。但象棋有一个特点，那就是每一步下的选择是相对非常有限的，最多也就十几种可能。哪怕是通过最最暴力的搜索方法，把每种都跑一遍，搜索几十步内的最优解。虽然这个方法随着搜索深度是指数级增长的，但事实上由于底数比饺小，依靠强大的算力还是可以解决的。而深蓝计算机正是这么一台拥有强大算力的超级计算机。</p>\n<p>然而在围棋上，这样就不行了，因为围棋每一步都有上百种选择，如此大的底数纯粹的暴力就显然无法满足了。至少硬件的发展并非每年成百倍成百倍地快速增长的。同样的方法，显然是不适合使用在围棋上的。</p>\n<p>在 2002 年之前，人们长期研究一个可以通过计算静态地分析出每一子的价值出来。然而这个方法的发展一直很慢。直到人们试图尝试一种动态评估一个博弈的一种方法，这就是靠<strong>猜</strong>。这个方法被称为蒙特卡洛搜索树，其前身是非常著名的上世纪曼哈顿计划期间由乌拉姆和冯·诺依曼提出的<strong>蒙特卡洛方法</strong>。</p>\n<p>如果我们想知道圆周率的值，我们如何利用猜的方法来猜出圆周率呢？我们只需要在一个方形中随机而均匀地扔飞镖，数一下，多少个飞镖扔在了以方形边长为直径的圆里，多少扔在了外面，根据圆的面积公式和方形的面积公式就能把 π 算出来。而蒙特卡洛搜索树就是利用蒙特卡洛方法来优化搜索树。简单来说，就是，我们认为这一步下在一个地方是最优的，而我们不知道这地方在哪里。我们先通过一系列随机的采样，从而去猜测一个值，这个值可能是最优解，也可能是一个接近最优解的解。但至少，这可以用来估算像围棋这样大的棋盘的东西了，而不需要把每个细枝末节都同等对待地来暴力搜索。</p>\n<h2 id=\"⑨神的大局观\"><a href=\"#⑨神的大局观\" class=\"headerlink\" title=\"⑨神的大局观\"></a>⑨神的大局观</h2><p>解决完计算量的问题，我们还要来解决人类在围棋上最大的优势——直觉，或者说「大局观」。那么如何才能拥有大局观呢？我们想一下，人们在下围棋的时候，通常会先考虑下在哪个片区，以获得什么样的目的。而这就是所谓的大局观。</p>\n<p>AlphaGo 的另一部分重要思想，得益于神经科学的发展，即人类认识人大脑神经的发展。人类愈发了解了大脑内神经元的工作模式，包括人类学习、认知的神经模型。这样的非常基础的模型，极大地方便了利用计算机来模拟人类进行学习的过程。</p>\n<p>蒙特卡洛方法只是简化了计算，并不具备学习的能力。无论是单纯的蒙特卡洛搜索还是与 α-β 搜索结合的还是和置信区间结合一些版本，都与人类能越学越强的围棋技巧相比差上太多。至少，人脑是一个极其复杂的计算模型，哪怕是现在最好的计算机，其算力和整个大脑比起来还是差很多的。</p>\n<p>在 2007 年，一些科学家试图提出一个新的机器学习模型，即所谓的深度学习。所谓深度学习，你可以看做模拟许多许多人脑中的神经元构成的一个网络。网络的每一层，针对一个特性进行识别。网络的每一层，都是一个单纯分类的无监督学习模型。你可以想像一下，人眼看到一个图像。经过一系列神经元，首先识别出了里面的眼睛、然后识别了里面的鼻子、嘴，再根据这些特性，发现这是一个人。这样依次发现的机制。而学习是通过一个有监督的反向传播进行。即告诉你这张图像里有一条狗，然后反向的一步步调整网络，让网络适应符合怎么样鼻子、嘴、眼睛的是一条狗。通过不断地数据的训练，即可以让模型越来越优。这个模型在图像识别领域已经达到甚至有时超越了人的识别能力。</p>\n<p>而 AlphaGo 使用的就是深度学习来优化蒙特卡洛搜索树。在 AlphaGo 中有两个网络，一个是策略网络，一个是价值网络。策略网络即是一个大局观的网络，机器会先通过其经验，找出其应该做出进攻的反应还是防守的反应，表现在下在哪个片区是最为合适的，是不是应该跟棋之类的大问题。然后再通过蒙特卡洛搜索树去算出具体下在哪里是最合适的。</p>\n<p>而我们说到，深度学习模型是真的和人一样可以学习的。每下一次棋，它就可以进一步调优自己的策略网络。首先 AlphaGo 导入了上千个职业选手对弈的棋谱，使得自己有了一个基础的下棋策略。这时候的 AlphaGo 就和一个受过系统训练的围棋少年一样了。然而这和职业选手的区别还是很大。这也就是所谓的「Google 没有顶尖的棋手为什么能开发出顶尖的围棋机器人？」按照一般常理，AlphaGo 应该一段一段地和人挑战，越发提高自己能力。然而 AlphaGo 不是这么做的，它选择和自己对弈。两台 AlphaGo 来对弈，将对弈的结果调优自己的网络。这个听起来很奇怪，为什么两个下得都不怎么样的棋手一起下棋，棋艺能那么快提升呢？因为它一天能和自己下上百万盘棋，它可以把自己分身成几万份跑在几万台电脑上，以及可以昼夜不停也不会过劳死，而这是任何一个人类都做不到的。AlphaGo 的开发人员说，他曾在早期能下赢 AlphaGo，而很快，AlphaGo 的水平就远超了他。所以 AlphaGo 得到了飞速的提升。仅仅五六个月，AlphaGo 就能从战胜欧洲棋王挑战到世界顶尖选手的水平了。</p>\n<h2 id=\"人工智能的基本法\"><a href=\"#人工智能的基本法\" class=\"headerlink\" title=\"人工智能的基本法\"></a>人工智能的基本法</h2><p>当然搞人工智能也要有基本法。这个基本法就是算力或者说是资源。虽然做了很大的优化，计算下围棋的计算量还是很大的。比起深蓝时依靠超级计算机来解决问题。AlphaGo 选择了一条适合 Google 的路径来解决算力问题。那就是分布式计算。使用分布式计算的 AlphaGo 版本比起不使用的版本其智能程度也是有相当大的提升。即使最简单，它也可以有更多时间来做随机的尝试，以找出更优的价值解。</p>\n<p>同样利用深度学习优化蒙特卡洛搜索的 Facebook 围棋团队，相比 Google 就没有那么壕力冲天了。无论是开发资源还是人员来说也是远少于 Google。Facebook 的围棋机器人之前也取得了相当好的成绩，大概可以击败职业二段选手的水平。但是比起 AlphaGo，还是差上许多。</p>\n<p>所以说，做这么一个人智能，背后的投入程度、重视程度也起到了很大的作用。这也是为什么深度学习目前做得很好的公司大多是一些顶尖的 IT 企业里的研发团队。</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>比起 AlphaGo 在围棋上的成就，其实大多数人很好奇人工智能未来的何去何从。从这次中，我们看到计算机已经具备了人类大局判断能力，其本质是类似于人类的学习能力，即不告诉电脑应该怎么做，而让电脑看人类是怎么做的。这项的应用其实相当广泛，尤其在非常复杂的问题上。</p>\n<p>比如说，无人驾驶汽车之前发展很困难，是因为人们总是试图去把驾驶规则完全讲给电脑，而这点太过复杂，难以用纯逻辑说清。而今天 Google 的无人驾驶汽车也是使用的类似的深度学习的技术，让计算机观察人类开车并学习，从而模仿人类的判断。最终依靠计算机强大的算力和不会疲劳等特点，甚至超越人类的判断。</p>\n<p>短期来看，利用深度学习的人工智能在未来数年内将会得到很大的应用。而这也是 Google 热衷于下围棋的原因。醉翁之意不在酒，在乎山水之间也。Google 只是想利用围棋来显示他们在深度学习应用上的先进水平。</p>\n<p>就人工智能的最终目的来看，我们已经跨出了很大的一步。之前而言，我们很大程度局限于人类强大的抽象的思考能力，而模仿人类神经系统的模型已经很好地模拟了这种思考是怎么产生的了。进一步说，如果一个机器，拥有和人完全一样的眼睛、耳朵、鼻子、触觉等作为它的输入，以及类似于人类肌肉和关节的机械部件作为它的输出。并且模拟一个和人脑一样复杂程度的神经网络，并让它观察人类进行学习。是不是在某个未来，我们可以拥有和人类功能非常接近甚至超越人类的智能的出现。深度学习都为这样的强人工智能提出了理论上的基础。</p>"},{"title":"数码相机是如何对各种颜色分别感光的？","date":"2015-01-20T05:55:08.000Z","_content":"\n说到数码相机，我们已经很不陌生这个名字了。它的核心是用图像传感器取代了胶片相机的胶片，而这种传感器，如今已经被应用于各种设备上，比如你的单反、微单、卡片机，甚至是手机上。\n\n图像传感器的感光元件的原理也从 CCD 发展到了 CMOS。并且随着制造技术和工艺的提升，像素数量也逐渐提高。从最早的 1 万像素（柯达于 1975 年研制成功），到现在的800万、1300万、2400万、4100万、甚至有 6000万 (哈苏H5D-60) 有效感光像素。但是对于任何一个彩色发光/感光的东西而言，我们知道，是需要将像素分为更细腻的子像素——也就是红、绿、蓝三个单色的感光像素来考虑的。既然感光的原理和发光类似，只要将光线分离成单色的子像素，最后再合成成一个像素，我们很容易地拿屏幕作类比，数码相机的每一个像素都是由一个红、一个绿、一个蓝色子像素组成的。可是事实是这样的吗？\n\n<!--more-->\n\n我们来考虑一下显示器发光和相机感光有没有什么其他的区别。我们常用的背光式液晶屏幕使用一整个统一亮度的白色光源，用液晶分子的旋光性和偏振片搭配来遮掉一部分光，从而控制透光率。每个红绿蓝的子像素的形状一般是可以自行选择的。一般是长方形的，这样三个长方形的子像素组成一个正方形的像素。\n\n![传统的液晶屏幕工作原理](http://cdn.heckpsi.com/889_LCD.jpg)\n\n传统的液晶屏幕工作原理\n\n![常见的RGB子像素排列在放大镜下观察](http://cdn.heckpsi.com/889_RGB.png)\n（常见的RGB子像素排列在放大镜下观察）\n\n\n然而各个颜色的感光元件的尺寸通常是不同的。这就带来了很大的问题。如果三个子像素拍成一个像素的话，这个像素是一样大小的长方形的，显然不符合实际要求。当然，我们可以拉大子像素的间距，使得它大致成一个正方形，不过这样的话，总的像素数就实在少得可怜。\n\n这样的情况我们似乎在另一种屏幕上遇到过，就是在三星的旗舰手机上常见的OLED屏幕，因为LED灯光是一个个单独控制每个颜色的发光亮度的，这样就很像一个个颜色单独感光的感光元件。而且发不同光使用材料不同，尺寸也不同，如果硬是要RGB排列，并要达到相同的亮度一定会导致子像素的寿命缩短。不过，你还记得三星是怎么优化这项技术的吗？Pentile排列。\n\n![三星在Galaxy S3中最早引入了Pentile排列](http://cdn.heckpsi.com/889_Pentile.png)\n\n（三星在Galaxy S3中最早引入了Pentile排列）\n实际上，我们相机感光片的子像素分布采用了一种叫做拜耳阵列的方式进行排列。他是以现代彩色数码摄影的开创者，柯达的科学家Bryce Bayer的名字命名，而且这项技术比Pentile不知道早多少年了。相机的彩色数码感光元件自开始以来就是这么排列的。这种排列被称为拜耳阵列。一个阵列包含四个子像素红、绿、绿、蓝，组成一个正方形。\n\n![拜耳阵列示意图](http://cdn.heckpsi.com/889_Bayer.jpg)\n\n（拜耳阵列示意图）\n拍摄后利用差值算法，算出一张每个像素都是RGB的图。听起来很不错吧。不过，熟悉手机的朋友都知道Pentile排列有什么问题吗？边缘处理会出现有色边缘，同样像素下会给人很强的锯齿感。恩，拜耳阵列也有类似的问题，不过这问题叫做，摩尔纹。\n\n![摩尔纹](http://cdn.heckpsi.com/889_Mole.jpg)\n\n（采用拜耳阵列的相机拍摄拥有重复纹理的西装时产生的摩尔纹）\n在拍摄具有重复细节（如纺织品）的画面时，容易产生彩色干扰信息。该问题是由于其规则的分布方式而造成的。其具体表现为在画面中产生难看的色带，而解决该问题的方法是在传感器其安装一块会将画面细节模糊化的AA（或称低通）滤镜。不过，这块滤镜虽然消除了摩尔纹，但是这种细节模糊化的方式，同时也降低了相机分辨率。\n\n当然，试图解决这样的问题的公司其实不少，给大家举两个例子，常见的比如富士的X-trans传感器。这块传感器的方案是，将2 x 2的阵列改成 6 x 6。，大大增加了子像素的无序性。由于摩尔纹从物理本质上说是波的干涉，那么无序性的增加，在运算过程中更不容易出现摩尔纹。这样确实大大避免了摩尔纹的产生，但是相应地，由于阵列单元的增加，单位面积下容纳的像素就变少了。目前搭载这款感光片的机器也是非常少的。\n\n![X-Trans排列示例](http://cdn.heckpsi.com/889_Xtrans.jpg)\n\n（X-Trans排列示例）\n而适马提出的Foveon X3感光片则更是解决得彻底，既然，我们所纠结的是一个平面无法将三个子像素排成正方形，那么我们就立体地解决。适马的X3感光片其实有三块，每一块只感应一种颜色，从平面上看，就是个正方形。以适马SD1为例，官方号称是4600万像素，其实是4600万子像素，实际照片是1500万像素的。由于从理论上完全杜绝了摩尔纹的存在，线条还原能力强，和同样1500万像素采用拜耳阵列的机器比起来细节上的表现简直令人感到恐怖。\n\n![Foveon X3](http://cdn.heckpsi.com/889_X3.jpg)\n\n（Foveon X3工作原理）\n不过，上面这两块感光片仍属于一种比较初级的研发阶段，各自存在一些奇奇怪怪的问题，而且产量也比饺小，价钱也是贵得可怕，短时间内几乎没有普及的可能性。\n\n","source":"_posts/how-cmos-works.md","raw":"---\ntitle: 数码相机是如何对各种颜色分别感光的？\ndate: 2015-01-20 13:55:08\ntags: [科普,影像]\n---\n\n说到数码相机，我们已经很不陌生这个名字了。它的核心是用图像传感器取代了胶片相机的胶片，而这种传感器，如今已经被应用于各种设备上，比如你的单反、微单、卡片机，甚至是手机上。\n\n图像传感器的感光元件的原理也从 CCD 发展到了 CMOS。并且随着制造技术和工艺的提升，像素数量也逐渐提高。从最早的 1 万像素（柯达于 1975 年研制成功），到现在的800万、1300万、2400万、4100万、甚至有 6000万 (哈苏H5D-60) 有效感光像素。但是对于任何一个彩色发光/感光的东西而言，我们知道，是需要将像素分为更细腻的子像素——也就是红、绿、蓝三个单色的感光像素来考虑的。既然感光的原理和发光类似，只要将光线分离成单色的子像素，最后再合成成一个像素，我们很容易地拿屏幕作类比，数码相机的每一个像素都是由一个红、一个绿、一个蓝色子像素组成的。可是事实是这样的吗？\n\n<!--more-->\n\n我们来考虑一下显示器发光和相机感光有没有什么其他的区别。我们常用的背光式液晶屏幕使用一整个统一亮度的白色光源，用液晶分子的旋光性和偏振片搭配来遮掉一部分光，从而控制透光率。每个红绿蓝的子像素的形状一般是可以自行选择的。一般是长方形的，这样三个长方形的子像素组成一个正方形的像素。\n\n![传统的液晶屏幕工作原理](http://cdn.heckpsi.com/889_LCD.jpg)\n\n传统的液晶屏幕工作原理\n\n![常见的RGB子像素排列在放大镜下观察](http://cdn.heckpsi.com/889_RGB.png)\n（常见的RGB子像素排列在放大镜下观察）\n\n\n然而各个颜色的感光元件的尺寸通常是不同的。这就带来了很大的问题。如果三个子像素拍成一个像素的话，这个像素是一样大小的长方形的，显然不符合实际要求。当然，我们可以拉大子像素的间距，使得它大致成一个正方形，不过这样的话，总的像素数就实在少得可怜。\n\n这样的情况我们似乎在另一种屏幕上遇到过，就是在三星的旗舰手机上常见的OLED屏幕，因为LED灯光是一个个单独控制每个颜色的发光亮度的，这样就很像一个个颜色单独感光的感光元件。而且发不同光使用材料不同，尺寸也不同，如果硬是要RGB排列，并要达到相同的亮度一定会导致子像素的寿命缩短。不过，你还记得三星是怎么优化这项技术的吗？Pentile排列。\n\n![三星在Galaxy S3中最早引入了Pentile排列](http://cdn.heckpsi.com/889_Pentile.png)\n\n（三星在Galaxy S3中最早引入了Pentile排列）\n实际上，我们相机感光片的子像素分布采用了一种叫做拜耳阵列的方式进行排列。他是以现代彩色数码摄影的开创者，柯达的科学家Bryce Bayer的名字命名，而且这项技术比Pentile不知道早多少年了。相机的彩色数码感光元件自开始以来就是这么排列的。这种排列被称为拜耳阵列。一个阵列包含四个子像素红、绿、绿、蓝，组成一个正方形。\n\n![拜耳阵列示意图](http://cdn.heckpsi.com/889_Bayer.jpg)\n\n（拜耳阵列示意图）\n拍摄后利用差值算法，算出一张每个像素都是RGB的图。听起来很不错吧。不过，熟悉手机的朋友都知道Pentile排列有什么问题吗？边缘处理会出现有色边缘，同样像素下会给人很强的锯齿感。恩，拜耳阵列也有类似的问题，不过这问题叫做，摩尔纹。\n\n![摩尔纹](http://cdn.heckpsi.com/889_Mole.jpg)\n\n（采用拜耳阵列的相机拍摄拥有重复纹理的西装时产生的摩尔纹）\n在拍摄具有重复细节（如纺织品）的画面时，容易产生彩色干扰信息。该问题是由于其规则的分布方式而造成的。其具体表现为在画面中产生难看的色带，而解决该问题的方法是在传感器其安装一块会将画面细节模糊化的AA（或称低通）滤镜。不过，这块滤镜虽然消除了摩尔纹，但是这种细节模糊化的方式，同时也降低了相机分辨率。\n\n当然，试图解决这样的问题的公司其实不少，给大家举两个例子，常见的比如富士的X-trans传感器。这块传感器的方案是，将2 x 2的阵列改成 6 x 6。，大大增加了子像素的无序性。由于摩尔纹从物理本质上说是波的干涉，那么无序性的增加，在运算过程中更不容易出现摩尔纹。这样确实大大避免了摩尔纹的产生，但是相应地，由于阵列单元的增加，单位面积下容纳的像素就变少了。目前搭载这款感光片的机器也是非常少的。\n\n![X-Trans排列示例](http://cdn.heckpsi.com/889_Xtrans.jpg)\n\n（X-Trans排列示例）\n而适马提出的Foveon X3感光片则更是解决得彻底，既然，我们所纠结的是一个平面无法将三个子像素排成正方形，那么我们就立体地解决。适马的X3感光片其实有三块，每一块只感应一种颜色，从平面上看，就是个正方形。以适马SD1为例，官方号称是4600万像素，其实是4600万子像素，实际照片是1500万像素的。由于从理论上完全杜绝了摩尔纹的存在，线条还原能力强，和同样1500万像素采用拜耳阵列的机器比起来细节上的表现简直令人感到恐怖。\n\n![Foveon X3](http://cdn.heckpsi.com/889_X3.jpg)\n\n（Foveon X3工作原理）\n不过，上面这两块感光片仍属于一种比较初级的研发阶段，各自存在一些奇奇怪怪的问题，而且产量也比饺小，价钱也是贵得可怕，短时间内几乎没有普及的可能性。\n\n","slug":"how-cmos-works","published":1,"updated":"2016-05-15T03:20:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscy0093000ppp8z33djx77p","content":"<p>说到数码相机，我们已经很不陌生这个名字了。它的核心是用图像传感器取代了胶片相机的胶片，而这种传感器，如今已经被应用于各种设备上，比如你的单反、微单、卡片机，甚至是手机上。</p>\n<p>图像传感器的感光元件的原理也从 CCD 发展到了 CMOS。并且随着制造技术和工艺的提升，像素数量也逐渐提高。从最早的 1 万像素（柯达于 1975 年研制成功），到现在的800万、1300万、2400万、4100万、甚至有 6000万 (哈苏H5D-60) 有效感光像素。但是对于任何一个彩色发光/感光的东西而言，我们知道，是需要将像素分为更细腻的子像素——也就是红、绿、蓝三个单色的感光像素来考虑的。既然感光的原理和发光类似，只要将光线分离成单色的子像素，最后再合成成一个像素，我们很容易地拿屏幕作类比，数码相机的每一个像素都是由一个红、一个绿、一个蓝色子像素组成的。可是事实是这样的吗？</p>\n<a id=\"more\"></a>\n<p>我们来考虑一下显示器发光和相机感光有没有什么其他的区别。我们常用的背光式液晶屏幕使用一整个统一亮度的白色光源，用液晶分子的旋光性和偏振片搭配来遮掉一部分光，从而控制透光率。每个红绿蓝的子像素的形状一般是可以自行选择的。一般是长方形的，这样三个长方形的子像素组成一个正方形的像素。</p>\n<p><img src=\"http://cdn.heckpsi.com/889_LCD.jpg\" alt=\"传统的液晶屏幕工作原理\"></p>\n<p>传统的液晶屏幕工作原理</p>\n<p><img src=\"http://cdn.heckpsi.com/889_RGB.png\" alt=\"常见的RGB子像素排列在放大镜下观察\"><br>（常见的RGB子像素排列在放大镜下观察）</p>\n<p>然而各个颜色的感光元件的尺寸通常是不同的。这就带来了很大的问题。如果三个子像素拍成一个像素的话，这个像素是一样大小的长方形的，显然不符合实际要求。当然，我们可以拉大子像素的间距，使得它大致成一个正方形，不过这样的话，总的像素数就实在少得可怜。</p>\n<p>这样的情况我们似乎在另一种屏幕上遇到过，就是在三星的旗舰手机上常见的OLED屏幕，因为LED灯光是一个个单独控制每个颜色的发光亮度的，这样就很像一个个颜色单独感光的感光元件。而且发不同光使用材料不同，尺寸也不同，如果硬是要RGB排列，并要达到相同的亮度一定会导致子像素的寿命缩短。不过，你还记得三星是怎么优化这项技术的吗？Pentile排列。</p>\n<p><img src=\"http://cdn.heckpsi.com/889_Pentile.png\" alt=\"三星在Galaxy S3中最早引入了Pentile排列\"></p>\n<p>（三星在Galaxy S3中最早引入了Pentile排列）<br>实际上，我们相机感光片的子像素分布采用了一种叫做拜耳阵列的方式进行排列。他是以现代彩色数码摄影的开创者，柯达的科学家Bryce Bayer的名字命名，而且这项技术比Pentile不知道早多少年了。相机的彩色数码感光元件自开始以来就是这么排列的。这种排列被称为拜耳阵列。一个阵列包含四个子像素红、绿、绿、蓝，组成一个正方形。</p>\n<p><img src=\"http://cdn.heckpsi.com/889_Bayer.jpg\" alt=\"拜耳阵列示意图\"></p>\n<p>（拜耳阵列示意图）<br>拍摄后利用差值算法，算出一张每个像素都是RGB的图。听起来很不错吧。不过，熟悉手机的朋友都知道Pentile排列有什么问题吗？边缘处理会出现有色边缘，同样像素下会给人很强的锯齿感。恩，拜耳阵列也有类似的问题，不过这问题叫做，摩尔纹。</p>\n<p><img src=\"http://cdn.heckpsi.com/889_Mole.jpg\" alt=\"摩尔纹\"></p>\n<p>（采用拜耳阵列的相机拍摄拥有重复纹理的西装时产生的摩尔纹）<br>在拍摄具有重复细节（如纺织品）的画面时，容易产生彩色干扰信息。该问题是由于其规则的分布方式而造成的。其具体表现为在画面中产生难看的色带，而解决该问题的方法是在传感器其安装一块会将画面细节模糊化的AA（或称低通）滤镜。不过，这块滤镜虽然消除了摩尔纹，但是这种细节模糊化的方式，同时也降低了相机分辨率。</p>\n<p>当然，试图解决这样的问题的公司其实不少，给大家举两个例子，常见的比如富士的X-trans传感器。这块传感器的方案是，将2 x 2的阵列改成 6 x 6。，大大增加了子像素的无序性。由于摩尔纹从物理本质上说是波的干涉，那么无序性的增加，在运算过程中更不容易出现摩尔纹。这样确实大大避免了摩尔纹的产生，但是相应地，由于阵列单元的增加，单位面积下容纳的像素就变少了。目前搭载这款感光片的机器也是非常少的。</p>\n<p><img src=\"http://cdn.heckpsi.com/889_Xtrans.jpg\" alt=\"X-Trans排列示例\"></p>\n<p>（X-Trans排列示例）<br>而适马提出的Foveon X3感光片则更是解决得彻底，既然，我们所纠结的是一个平面无法将三个子像素排成正方形，那么我们就立体地解决。适马的X3感光片其实有三块，每一块只感应一种颜色，从平面上看，就是个正方形。以适马SD1为例，官方号称是4600万像素，其实是4600万子像素，实际照片是1500万像素的。由于从理论上完全杜绝了摩尔纹的存在，线条还原能力强，和同样1500万像素采用拜耳阵列的机器比起来细节上的表现简直令人感到恐怖。</p>\n<p><img src=\"http://cdn.heckpsi.com/889_X3.jpg\" alt=\"Foveon X3\"></p>\n<p>（Foveon X3工作原理）<br>不过，上面这两块感光片仍属于一种比较初级的研发阶段，各自存在一些奇奇怪怪的问题，而且产量也比饺小，价钱也是贵得可怕，短时间内几乎没有普及的可能性。</p>\n","excerpt":"<p>说到数码相机，我们已经很不陌生这个名字了。它的核心是用图像传感器取代了胶片相机的胶片，而这种传感器，如今已经被应用于各种设备上，比如你的单反、微单、卡片机，甚至是手机上。</p>\n<p>图像传感器的感光元件的原理也从 CCD 发展到了 CMOS。并且随着制造技术和工艺的提升，像素数量也逐渐提高。从最早的 1 万像素（柯达于 1975 年研制成功），到现在的800万、1300万、2400万、4100万、甚至有 6000万 (哈苏H5D-60) 有效感光像素。但是对于任何一个彩色发光/感光的东西而言，我们知道，是需要将像素分为更细腻的子像素——也就是红、绿、蓝三个单色的感光像素来考虑的。既然感光的原理和发光类似，只要将光线分离成单色的子像素，最后再合成成一个像素，我们很容易地拿屏幕作类比，数码相机的每一个像素都是由一个红、一个绿、一个蓝色子像素组成的。可是事实是这样的吗？</p>","more":"<p>我们来考虑一下显示器发光和相机感光有没有什么其他的区别。我们常用的背光式液晶屏幕使用一整个统一亮度的白色光源，用液晶分子的旋光性和偏振片搭配来遮掉一部分光，从而控制透光率。每个红绿蓝的子像素的形状一般是可以自行选择的。一般是长方形的，这样三个长方形的子像素组成一个正方形的像素。</p>\n<p><img src=\"http://cdn.heckpsi.com/889_LCD.jpg\" alt=\"传统的液晶屏幕工作原理\"></p>\n<p>传统的液晶屏幕工作原理</p>\n<p><img src=\"http://cdn.heckpsi.com/889_RGB.png\" alt=\"常见的RGB子像素排列在放大镜下观察\"><br>（常见的RGB子像素排列在放大镜下观察）</p>\n<p>然而各个颜色的感光元件的尺寸通常是不同的。这就带来了很大的问题。如果三个子像素拍成一个像素的话，这个像素是一样大小的长方形的，显然不符合实际要求。当然，我们可以拉大子像素的间距，使得它大致成一个正方形，不过这样的话，总的像素数就实在少得可怜。</p>\n<p>这样的情况我们似乎在另一种屏幕上遇到过，就是在三星的旗舰手机上常见的OLED屏幕，因为LED灯光是一个个单独控制每个颜色的发光亮度的，这样就很像一个个颜色单独感光的感光元件。而且发不同光使用材料不同，尺寸也不同，如果硬是要RGB排列，并要达到相同的亮度一定会导致子像素的寿命缩短。不过，你还记得三星是怎么优化这项技术的吗？Pentile排列。</p>\n<p><img src=\"http://cdn.heckpsi.com/889_Pentile.png\" alt=\"三星在Galaxy S3中最早引入了Pentile排列\"></p>\n<p>（三星在Galaxy S3中最早引入了Pentile排列）<br>实际上，我们相机感光片的子像素分布采用了一种叫做拜耳阵列的方式进行排列。他是以现代彩色数码摄影的开创者，柯达的科学家Bryce Bayer的名字命名，而且这项技术比Pentile不知道早多少年了。相机的彩色数码感光元件自开始以来就是这么排列的。这种排列被称为拜耳阵列。一个阵列包含四个子像素红、绿、绿、蓝，组成一个正方形。</p>\n<p><img src=\"http://cdn.heckpsi.com/889_Bayer.jpg\" alt=\"拜耳阵列示意图\"></p>\n<p>（拜耳阵列示意图）<br>拍摄后利用差值算法，算出一张每个像素都是RGB的图。听起来很不错吧。不过，熟悉手机的朋友都知道Pentile排列有什么问题吗？边缘处理会出现有色边缘，同样像素下会给人很强的锯齿感。恩，拜耳阵列也有类似的问题，不过这问题叫做，摩尔纹。</p>\n<p><img src=\"http://cdn.heckpsi.com/889_Mole.jpg\" alt=\"摩尔纹\"></p>\n<p>（采用拜耳阵列的相机拍摄拥有重复纹理的西装时产生的摩尔纹）<br>在拍摄具有重复细节（如纺织品）的画面时，容易产生彩色干扰信息。该问题是由于其规则的分布方式而造成的。其具体表现为在画面中产生难看的色带，而解决该问题的方法是在传感器其安装一块会将画面细节模糊化的AA（或称低通）滤镜。不过，这块滤镜虽然消除了摩尔纹，但是这种细节模糊化的方式，同时也降低了相机分辨率。</p>\n<p>当然，试图解决这样的问题的公司其实不少，给大家举两个例子，常见的比如富士的X-trans传感器。这块传感器的方案是，将2 x 2的阵列改成 6 x 6。，大大增加了子像素的无序性。由于摩尔纹从物理本质上说是波的干涉，那么无序性的增加，在运算过程中更不容易出现摩尔纹。这样确实大大避免了摩尔纹的产生，但是相应地，由于阵列单元的增加，单位面积下容纳的像素就变少了。目前搭载这款感光片的机器也是非常少的。</p>\n<p><img src=\"http://cdn.heckpsi.com/889_Xtrans.jpg\" alt=\"X-Trans排列示例\"></p>\n<p>（X-Trans排列示例）<br>而适马提出的Foveon X3感光片则更是解决得彻底，既然，我们所纠结的是一个平面无法将三个子像素排成正方形，那么我们就立体地解决。适马的X3感光片其实有三块，每一块只感应一种颜色，从平面上看，就是个正方形。以适马SD1为例，官方号称是4600万像素，其实是4600万子像素，实际照片是1500万像素的。由于从理论上完全杜绝了摩尔纹的存在，线条还原能力强，和同样1500万像素采用拜耳阵列的机器比起来细节上的表现简直令人感到恐怖。</p>\n<p><img src=\"http://cdn.heckpsi.com/889_X3.jpg\" alt=\"Foveon X3\"></p>\n<p>（Foveon X3工作原理）<br>不过，上面这两块感光片仍属于一种比较初级的研发阶段，各自存在一些奇奇怪怪的问题，而且产量也比饺小，价钱也是贵得可怕，短时间内几乎没有普及的可能性。</p>"},{"title":"从我能吞下玻璃而不伤身体说字体测试","date":"2015-02-21T08:38:54.000Z","_content":"\n许多使用Ubuntu操作系统的用户都会惊讶于Ubuntu打开一个字体文件的时候用于测试字体而显示的文字：\n\n```\n我能吞下玻璃而不伤身体。\n```\n\n![](http://cdn.heckpsi.com/961_1.png)\n\n为什么是用这样一句句子来测试字体呢？\n\n<!--more-->\n\n这需要联系到一个由哈佛大学学生 Ethan Mollick 创建的一个语言学项目。叫做 [I Can Eat Glass](http://en.wikipedia.org/wiki/I_Can_Eat_Glass)。根据 Ethan Mollick 的解释，他希望让一个人到一个陌生的国家后说出某句简单易学的话，但能让别人感觉他是这个语言的母语者，从而能更尊重地对待他。这句话要有这种神奇的吓唬人的力量，几经思考之后他们选择了 “I can eat glass, but it does not hurt me.” 这句句子。（虽然我完全没有办法理解为什么这句话有这样的作用）他们将这句话翻译成了许多种语言，并制作成了网页。非常糟糕的是，这些网页在今年已经无法正常访问，好在一些好心人制作了这一网站的 [镜像](http://reocities.com/nodotus/hbglass.html)。\n\n```\nWo ke yi chi bo li, wo bu huei sho shang.\n```\n\n写作：我可藝吃玻璃，我不毀受傷。（显然地，他们还写了许多错别字）\n\n但是他们所做的神奇之处并不是他们达到了他们一开始想要达到的目的（显然他们不能），相反地，之后哥伦比亚大学的同学在试图制作 UTF-8 编码的样例的时候想到了这个项目。众所周知，UTF-8 编码希望能通过一种编码正常显示世界上所有语言。而哈佛的这个项目恰好已经把一句话翻译成了各种各样的语言，用来做 UTF-8 编码的显示样例再好不过了。于是哥大的同学就做了这么一个 [项目](http://www.columbia.edu/~fdc/utf8/index.html)。并优化了其中的翻译，其中简体中文的翻译被翻译成了 “我能吞下玻璃而不伤身体。”，也就是现在的样子。\n\n那为什么 Ubuntu 会选择这样一句句子作为字体测试的句子呢？目的是为了测试编码的完整性，也就是这个字体支持的语言的数量。\n\n但是这样的测试真的是好的吗？或者说是足够好的吗？我想可能并不是这样。\n\n对于西文字体而言一个完整的字形测试也就四五十个字符（包含大小写和常用符号）。一种常见的测试方法是大家在 Windows 系统上常见到的范例句子。\n\n```\nThe quick brown fox jumps over the lazy dog.\n```\n\n\n上面这句话使用了全部的26个字母（但并不包含每个大小写）。这样的句子基本上测试了西文字体在显示英文的主要效果。但是对于中文、日文、韩文这些非字母化的重灾区，几个字可能是很难测试好一个字体的。可能你能从中看出是衬线字体还是非衬线字体、宋体还是黑体，但对于其它很多问题并不能很好的测试到。比如对于常见的偏旁部首是怎么设计的、字体覆盖多少汉字、标点符号等宽还是不等宽之类的问题几个字是比较难测试的。靠一句“我能吞下玻璃而不伤身体。”几乎是没什么用的。而 Windows 的“中国智造，慧及全球”就更扯了，完全不能理解这句话能测试出什么东西出来。\n\nMac OS X 字体册在测试日文的时候非常巧妙。\n\n![](http://cdn.heckpsi.com/961_3.png)\n\n测试了假名、汉字、标点符号、复杂汉字的显示效果。选用的是日本诗人 宮沢賢治 的 [《ポラーノの広場》](http://www.aozora.gr.jp/cards/000081/files/1935_19925.html) 的一节。不但用了一个短小的文字，而且测试了实际使用中的大多数字形的问题，可以说是解决地非常巧妙。\n\n然而对于中文的字体测试显得就差了很多。\n\n![](http://cdn.heckpsi.com/961_2.png)\n\n选择的几个字比起 Windows 和 Ubuntu 测试了更多的偏旁部首的显示，这点虽然更好一点，但堆砌了这样一堆没有意义的文字也不很能理解是出于什么样的目的。更重要的是，竟然没有测试标点符号，反而测试了一些奇奇怪怪的中文序号。这一点不但解决地不如日文测试时那么巧妙，甚至连功能都是不够完整的。不过 Mac OS X 在测试字体是支持“自定”测试，可以输入自己需要测试的内容保存下来，还是满足了功能上的需求。\n\n其实比较下来，Ubuntu 的字体测试是最为通用的测试，能覆盖UTF-8编码下各种语言的测试，但是对于每种语言的测试却是不足够的。Mac OS X 确实对于设计者最为友好，但在中文测试的时候还是不够全面优秀。至于 Windows 嘛......\n\n```\n微软唯一的问题是没品位，他们根本的绝对的没品位。——史蒂夫·乔布斯\n```\n\n\n所以指望 Windows 在字体上搞出点什么还是省省吧。如果在 Windows 上对字体有比较高的要求，建议使用第三方的字体管理软件，比如 Adobe Typekit 之类的......\n\n","source":"_posts/how-to-test-a-font.md","raw":"---\ntitle: 从我能吞下玻璃而不伤身体说字体测试\ndate: 2015-02-21 16:38:54\ntags: [字体,科普]\n---\n\n许多使用Ubuntu操作系统的用户都会惊讶于Ubuntu打开一个字体文件的时候用于测试字体而显示的文字：\n\n```\n我能吞下玻璃而不伤身体。\n```\n\n![](http://cdn.heckpsi.com/961_1.png)\n\n为什么是用这样一句句子来测试字体呢？\n\n<!--more-->\n\n这需要联系到一个由哈佛大学学生 Ethan Mollick 创建的一个语言学项目。叫做 [I Can Eat Glass](http://en.wikipedia.org/wiki/I_Can_Eat_Glass)。根据 Ethan Mollick 的解释，他希望让一个人到一个陌生的国家后说出某句简单易学的话，但能让别人感觉他是这个语言的母语者，从而能更尊重地对待他。这句话要有这种神奇的吓唬人的力量，几经思考之后他们选择了 “I can eat glass, but it does not hurt me.” 这句句子。（虽然我完全没有办法理解为什么这句话有这样的作用）他们将这句话翻译成了许多种语言，并制作成了网页。非常糟糕的是，这些网页在今年已经无法正常访问，好在一些好心人制作了这一网站的 [镜像](http://reocities.com/nodotus/hbglass.html)。\n\n```\nWo ke yi chi bo li, wo bu huei sho shang.\n```\n\n写作：我可藝吃玻璃，我不毀受傷。（显然地，他们还写了许多错别字）\n\n但是他们所做的神奇之处并不是他们达到了他们一开始想要达到的目的（显然他们不能），相反地，之后哥伦比亚大学的同学在试图制作 UTF-8 编码的样例的时候想到了这个项目。众所周知，UTF-8 编码希望能通过一种编码正常显示世界上所有语言。而哈佛的这个项目恰好已经把一句话翻译成了各种各样的语言，用来做 UTF-8 编码的显示样例再好不过了。于是哥大的同学就做了这么一个 [项目](http://www.columbia.edu/~fdc/utf8/index.html)。并优化了其中的翻译，其中简体中文的翻译被翻译成了 “我能吞下玻璃而不伤身体。”，也就是现在的样子。\n\n那为什么 Ubuntu 会选择这样一句句子作为字体测试的句子呢？目的是为了测试编码的完整性，也就是这个字体支持的语言的数量。\n\n但是这样的测试真的是好的吗？或者说是足够好的吗？我想可能并不是这样。\n\n对于西文字体而言一个完整的字形测试也就四五十个字符（包含大小写和常用符号）。一种常见的测试方法是大家在 Windows 系统上常见到的范例句子。\n\n```\nThe quick brown fox jumps over the lazy dog.\n```\n\n\n上面这句话使用了全部的26个字母（但并不包含每个大小写）。这样的句子基本上测试了西文字体在显示英文的主要效果。但是对于中文、日文、韩文这些非字母化的重灾区，几个字可能是很难测试好一个字体的。可能你能从中看出是衬线字体还是非衬线字体、宋体还是黑体，但对于其它很多问题并不能很好的测试到。比如对于常见的偏旁部首是怎么设计的、字体覆盖多少汉字、标点符号等宽还是不等宽之类的问题几个字是比较难测试的。靠一句“我能吞下玻璃而不伤身体。”几乎是没什么用的。而 Windows 的“中国智造，慧及全球”就更扯了，完全不能理解这句话能测试出什么东西出来。\n\nMac OS X 字体册在测试日文的时候非常巧妙。\n\n![](http://cdn.heckpsi.com/961_3.png)\n\n测试了假名、汉字、标点符号、复杂汉字的显示效果。选用的是日本诗人 宮沢賢治 的 [《ポラーノの広場》](http://www.aozora.gr.jp/cards/000081/files/1935_19925.html) 的一节。不但用了一个短小的文字，而且测试了实际使用中的大多数字形的问题，可以说是解决地非常巧妙。\n\n然而对于中文的字体测试显得就差了很多。\n\n![](http://cdn.heckpsi.com/961_2.png)\n\n选择的几个字比起 Windows 和 Ubuntu 测试了更多的偏旁部首的显示，这点虽然更好一点，但堆砌了这样一堆没有意义的文字也不很能理解是出于什么样的目的。更重要的是，竟然没有测试标点符号，反而测试了一些奇奇怪怪的中文序号。这一点不但解决地不如日文测试时那么巧妙，甚至连功能都是不够完整的。不过 Mac OS X 在测试字体是支持“自定”测试，可以输入自己需要测试的内容保存下来，还是满足了功能上的需求。\n\n其实比较下来，Ubuntu 的字体测试是最为通用的测试，能覆盖UTF-8编码下各种语言的测试，但是对于每种语言的测试却是不足够的。Mac OS X 确实对于设计者最为友好，但在中文测试的时候还是不够全面优秀。至于 Windows 嘛......\n\n```\n微软唯一的问题是没品位，他们根本的绝对的没品位。——史蒂夫·乔布斯\n```\n\n\n所以指望 Windows 在字体上搞出点什么还是省省吧。如果在 Windows 上对字体有比较高的要求，建议使用第三方的字体管理软件，比如 Adobe Typekit 之类的......\n\n","slug":"how-to-test-a-font","published":1,"updated":"2016-05-15T03:20:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscy0094000rpp8zfdzvv5md","content":"<p>许多使用Ubuntu操作系统的用户都会惊讶于Ubuntu打开一个字体文件的时候用于测试字体而显示的文字：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我能吞下玻璃而不伤身体。</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://cdn.heckpsi.com/961_1.png\" alt=\"\"></p>\n<p>为什么是用这样一句句子来测试字体呢？</p>\n<a id=\"more\"></a>\n<p>这需要联系到一个由哈佛大学学生 Ethan Mollick 创建的一个语言学项目。叫做 <a href=\"http://en.wikipedia.org/wiki/I_Can_Eat_Glass\" target=\"_blank\" rel=\"external\">I Can Eat Glass</a>。根据 Ethan Mollick 的解释，他希望让一个人到一个陌生的国家后说出某句简单易学的话，但能让别人感觉他是这个语言的母语者，从而能更尊重地对待他。这句话要有这种神奇的吓唬人的力量，几经思考之后他们选择了 “I can eat glass, but it does not hurt me.” 这句句子。（虽然我完全没有办法理解为什么这句话有这样的作用）他们将这句话翻译成了许多种语言，并制作成了网页。非常糟糕的是，这些网页在今年已经无法正常访问，好在一些好心人制作了这一网站的 <a href=\"http://reocities.com/nodotus/hbglass.html\" target=\"_blank\" rel=\"external\">镜像</a>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Wo ke yi chi bo li, wo bu huei sho shang.</span><br></pre></td></tr></table></figure>\n<p>写作：我可藝吃玻璃，我不毀受傷。（显然地，他们还写了许多错别字）</p>\n<p>但是他们所做的神奇之处并不是他们达到了他们一开始想要达到的目的（显然他们不能），相反地，之后哥伦比亚大学的同学在试图制作 UTF-8 编码的样例的时候想到了这个项目。众所周知，UTF-8 编码希望能通过一种编码正常显示世界上所有语言。而哈佛的这个项目恰好已经把一句话翻译成了各种各样的语言，用来做 UTF-8 编码的显示样例再好不过了。于是哥大的同学就做了这么一个 <a href=\"http://www.columbia.edu/~fdc/utf8/index.html\" target=\"_blank\" rel=\"external\">项目</a>。并优化了其中的翻译，其中简体中文的翻译被翻译成了 “我能吞下玻璃而不伤身体。”，也就是现在的样子。</p>\n<p>那为什么 Ubuntu 会选择这样一句句子作为字体测试的句子呢？目的是为了测试编码的完整性，也就是这个字体支持的语言的数量。</p>\n<p>但是这样的测试真的是好的吗？或者说是足够好的吗？我想可能并不是这样。</p>\n<p>对于西文字体而言一个完整的字形测试也就四五十个字符（包含大小写和常用符号）。一种常见的测试方法是大家在 Windows 系统上常见到的范例句子。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br></pre></td></tr></table></figure>\n<p>上面这句话使用了全部的26个字母（但并不包含每个大小写）。这样的句子基本上测试了西文字体在显示英文的主要效果。但是对于中文、日文、韩文这些非字母化的重灾区，几个字可能是很难测试好一个字体的。可能你能从中看出是衬线字体还是非衬线字体、宋体还是黑体，但对于其它很多问题并不能很好的测试到。比如对于常见的偏旁部首是怎么设计的、字体覆盖多少汉字、标点符号等宽还是不等宽之类的问题几个字是比较难测试的。靠一句“我能吞下玻璃而不伤身体。”几乎是没什么用的。而 Windows 的“中国智造，慧及全球”就更扯了，完全不能理解这句话能测试出什么东西出来。</p>\n<p>Mac OS X 字体册在测试日文的时候非常巧妙。</p>\n<p><img src=\"http://cdn.heckpsi.com/961_3.png\" alt=\"\"></p>\n<p>测试了假名、汉字、标点符号、复杂汉字的显示效果。选用的是日本诗人 宮沢賢治 的 <a href=\"http://www.aozora.gr.jp/cards/000081/files/1935_19925.html\" target=\"_blank\" rel=\"external\">《ポラーノの広場》</a> 的一节。不但用了一个短小的文字，而且测试了实际使用中的大多数字形的问题，可以说是解决地非常巧妙。</p>\n<p>然而对于中文的字体测试显得就差了很多。</p>\n<p><img src=\"http://cdn.heckpsi.com/961_2.png\" alt=\"\"></p>\n<p>选择的几个字比起 Windows 和 Ubuntu 测试了更多的偏旁部首的显示，这点虽然更好一点，但堆砌了这样一堆没有意义的文字也不很能理解是出于什么样的目的。更重要的是，竟然没有测试标点符号，反而测试了一些奇奇怪怪的中文序号。这一点不但解决地不如日文测试时那么巧妙，甚至连功能都是不够完整的。不过 Mac OS X 在测试字体是支持“自定”测试，可以输入自己需要测试的内容保存下来，还是满足了功能上的需求。</p>\n<p>其实比较下来，Ubuntu 的字体测试是最为通用的测试，能覆盖UTF-8编码下各种语言的测试，但是对于每种语言的测试却是不足够的。Mac OS X 确实对于设计者最为友好，但在中文测试的时候还是不够全面优秀。至于 Windows 嘛……</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">微软唯一的问题是没品位，他们根本的绝对的没品位。——史蒂夫·乔布斯</span><br></pre></td></tr></table></figure>\n<p>所以指望 Windows 在字体上搞出点什么还是省省吧。如果在 Windows 上对字体有比较高的要求，建议使用第三方的字体管理软件，比如 Adobe Typekit 之类的……</p>\n","excerpt":"<p>许多使用Ubuntu操作系统的用户都会惊讶于Ubuntu打开一个字体文件的时候用于测试字体而显示的文字：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我能吞下玻璃而不伤身体。</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://cdn.heckpsi.com/961_1.png\" alt=\"\"></p>\n<p>为什么是用这样一句句子来测试字体呢？</p>","more":"<p>这需要联系到一个由哈佛大学学生 Ethan Mollick 创建的一个语言学项目。叫做 <a href=\"http://en.wikipedia.org/wiki/I_Can_Eat_Glass\">I Can Eat Glass</a>。根据 Ethan Mollick 的解释，他希望让一个人到一个陌生的国家后说出某句简单易学的话，但能让别人感觉他是这个语言的母语者，从而能更尊重地对待他。这句话要有这种神奇的吓唬人的力量，几经思考之后他们选择了 “I can eat glass, but it does not hurt me.” 这句句子。（虽然我完全没有办法理解为什么这句话有这样的作用）他们将这句话翻译成了许多种语言，并制作成了网页。非常糟糕的是，这些网页在今年已经无法正常访问，好在一些好心人制作了这一网站的 <a href=\"http://reocities.com/nodotus/hbglass.html\">镜像</a>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Wo ke yi chi bo li, wo bu huei sho shang.</span><br></pre></td></tr></table></figure>\n<p>写作：我可藝吃玻璃，我不毀受傷。（显然地，他们还写了许多错别字）</p>\n<p>但是他们所做的神奇之处并不是他们达到了他们一开始想要达到的目的（显然他们不能），相反地，之后哥伦比亚大学的同学在试图制作 UTF-8 编码的样例的时候想到了这个项目。众所周知，UTF-8 编码希望能通过一种编码正常显示世界上所有语言。而哈佛的这个项目恰好已经把一句话翻译成了各种各样的语言，用来做 UTF-8 编码的显示样例再好不过了。于是哥大的同学就做了这么一个 <a href=\"http://www.columbia.edu/~fdc/utf8/index.html\">项目</a>。并优化了其中的翻译，其中简体中文的翻译被翻译成了 “我能吞下玻璃而不伤身体。”，也就是现在的样子。</p>\n<p>那为什么 Ubuntu 会选择这样一句句子作为字体测试的句子呢？目的是为了测试编码的完整性，也就是这个字体支持的语言的数量。</p>\n<p>但是这样的测试真的是好的吗？或者说是足够好的吗？我想可能并不是这样。</p>\n<p>对于西文字体而言一个完整的字形测试也就四五十个字符（包含大小写和常用符号）。一种常见的测试方法是大家在 Windows 系统上常见到的范例句子。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br></pre></td></tr></table></figure>\n<p>上面这句话使用了全部的26个字母（但并不包含每个大小写）。这样的句子基本上测试了西文字体在显示英文的主要效果。但是对于中文、日文、韩文这些非字母化的重灾区，几个字可能是很难测试好一个字体的。可能你能从中看出是衬线字体还是非衬线字体、宋体还是黑体，但对于其它很多问题并不能很好的测试到。比如对于常见的偏旁部首是怎么设计的、字体覆盖多少汉字、标点符号等宽还是不等宽之类的问题几个字是比较难测试的。靠一句“我能吞下玻璃而不伤身体。”几乎是没什么用的。而 Windows 的“中国智造，慧及全球”就更扯了，完全不能理解这句话能测试出什么东西出来。</p>\n<p>Mac OS X 字体册在测试日文的时候非常巧妙。</p>\n<p><img src=\"http://cdn.heckpsi.com/961_3.png\" alt=\"\"></p>\n<p>测试了假名、汉字、标点符号、复杂汉字的显示效果。选用的是日本诗人 宮沢賢治 的 <a href=\"http://www.aozora.gr.jp/cards/000081/files/1935_19925.html\">《ポラーノの広場》</a> 的一节。不但用了一个短小的文字，而且测试了实际使用中的大多数字形的问题，可以说是解决地非常巧妙。</p>\n<p>然而对于中文的字体测试显得就差了很多。</p>\n<p><img src=\"http://cdn.heckpsi.com/961_2.png\" alt=\"\"></p>\n<p>选择的几个字比起 Windows 和 Ubuntu 测试了更多的偏旁部首的显示，这点虽然更好一点，但堆砌了这样一堆没有意义的文字也不很能理解是出于什么样的目的。更重要的是，竟然没有测试标点符号，反而测试了一些奇奇怪怪的中文序号。这一点不但解决地不如日文测试时那么巧妙，甚至连功能都是不够完整的。不过 Mac OS X 在测试字体是支持“自定”测试，可以输入自己需要测试的内容保存下来，还是满足了功能上的需求。</p>\n<p>其实比较下来，Ubuntu 的字体测试是最为通用的测试，能覆盖UTF-8编码下各种语言的测试，但是对于每种语言的测试却是不足够的。Mac OS X 确实对于设计者最为友好，但在中文测试的时候还是不够全面优秀。至于 Windows 嘛……</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">微软唯一的问题是没品位，他们根本的绝对的没品位。——史蒂夫·乔布斯</span><br></pre></td></tr></table></figure>\n<p>所以指望 Windows 在字体上搞出点什么还是省省吧。如果在 Windows 上对字体有比较高的要求，建议使用第三方的字体管理软件，比如 Adobe Typekit 之类的……</p>"},{"title":"HTTPS 是如何保证安全的？","date":"2015-04-15T20:21:48.000Z","_content":"\n每当我们讨论到信息安全的时候，我们最长接触到的信息加密传输的方式莫过于 HTTPS 了，当我们浏览器地址栏闪现出绿色时，就代表着这个网站支持 HTTPS 的加密信息传输方式，并且你与它的连接确实被加密了。但是 HTTPS 并不是一个单一的东西，它知识我们常见的 HTTP 协议和某个加密协议的一个混合，这个加密协议通常会是 TLS。那么 HTTPS 为什么安全呢？其实我们需要先考虑 HTTP 为什么不安全。\n\n<!--more-->\n\n假设你坐在一个教室里，你现在非常想把某个信息传递给教室里的另一个人，一般来说，会选择，传纸条。传纸条这个比喻其实非常正确，这就是互联网的一个基础协议 TCP/IP 协议基本的工作模式。而通常，HTTP 协议的数据是使用 TCP/IP 协议进行发送的。HTTP 指的是你在纸条上写明你要传送的目的地是哪个同学的坐位，然后再是要传递的内容。途径的同学拿到纸条后根据纸条上显示的地址依次传过去就好了。这样要面临的第一个问题就是：途径的同学可以完全知道你写了什么。\n\n这就是 HTTP 面临的第一个问题，这个问题通常被叫做 “窃听” 或者 “嗅探” ，指的是和你在同一个网络下或者是途径的路由上的攻击者可以偷窥到你传输的内容。这是 HTTPS 要解决的第一个问题。这种问题通常是通过“加密”来解决的。从非常原始的角度来考虑，其实就是双方约定一个暗号。用什么字母去替代什么字母之类的。不过考虑到互联网每天有无数信息需要加密，这种原始的加密方法似乎不太适合。不过实际上方法也差不多，一般是采用一种叫做 AES 的算法来解决的。这种算法需要一个 密钥 key 来加密整个信息，加密和解密所需要使用的 key 是一样的，所以这种加密一般也被称为“对称加密”。AES 在数学上保证了，只要你使用的 key 足够足够足够足够的长，破解是几乎不可能的。\n\n我们先假设这种破解确实是不可能的，而且目前也确实没有对 AES 本身能发动起有效的攻击的案例出现。\n\n我们再回到这个教室，你接着要传小纸条，你把地址写上后，把要传输的内容用 AES 蹭蹭蹭加密了起来。刚准备传，问题来了。AES 不是有一个 key 吗？key 怎么给目的地啊？如果我把密钥直接写在纸条上，那么中间的人不依然可以解密吗？在现实中你可以通过一些其它方法来把密钥安全传输给目的地而不被其他人看见，但是在互联网上，要想这么做难度就很大了，毕竟传输终究要经过这些路由，所以要做加密，还得找一个更复杂的数学方法。\n\n于是聪明的人们发明了一种更复杂的加密算法——非对称加密。这种加密或许理解起来比较困难，这种加密指的是可以生成一对密钥 (k1, k2)。凡是 k1 加密的数据，k1 自身不能解密，而需要 k2 才能解密；凡是 k2 加密的数据，k2 不能解密，需要 k1 才能解密。这种算法事实上有很多，常用的是 RSA，其基于的数学原理是两个大素数的乘积很容易算，而拿到这个乘积去算出是哪两个素数相乘就很复杂了。好在以目前的技术，分解大数的素因数确实比较困难，尤其是当这个大数足够大的时候（通常使用2的10次方个二进制位这么大），就算是超级计算机解密也需要非常长的时间。\n\n现在利用这种非对称加密的方法，我们来设想一个场景。你继续想要传纸条，但是传纸条之前你先准备把接下来通讯的对称加密密钥给传输过去。于是你用 RSA 技术生成了一对 k1、k2，你把 k1 用明文发送了出去，路经有人或许会截取，但是没有用，k1 加密的数据需要用 k2 才能解密。而此时，k2 在你自己的手里。k1 送达目的地后，目的地的人会去准备一个接下来用于对称加密传输的密钥 key，然后用收到的 k1 把 key 加密了，把加密好的数据传回来。路上的人就算截取到了，也解密不出 key。等到了你自己手上，你用手上的 k2 把用 k1 加密的 key 解出来，现在全教室就只有你和你的目的地拥有 key，你们就可以用 AES 算法进行对称加密的传输啦！这时候你和目的地的通讯将无法再被任何人窃听！\n\n当然，这时候你可能会问两个问题。\n\n既然 非对称加密 可以那么安全，为什么我们不直接用它来加密信息，而是去加密 对称加密 的密钥呢？\n\n这是因为 非对称加密 的密码对生成和加密的消耗时间比较长，为了节省双方的计算时间，通常只用它来交换密钥，而非直接用来传输数据。\n\n使用 非对称加密 是完全安全的吗？\n\n听起来确实是挺安全的，但实际上，还有一种更恶劣的攻击是这种方法无法防范的，这就是传说中的“中间人攻击”。我们继续让你坐在教室里传小纸条。现在你和目的地上途径一个中间人，他有意想要知道你们的消息。由于这个描述比较复杂，我们将你称为 A，你的目的地称为 B，而中间人称为 M。当你要和 B 完成第一次密钥交换的时候，途径了 M。M 知道你要进行密钥交换了，它把小纸条扣了下来，假装自己是 B，伪造了一个 key ，然后用你发来的 k1 加密了 key 发还给你，你以为你和 B 完成了密钥交换，实际上你是和 M 完成了密钥交换。同时 M 和 B 完成一次密钥交换，让 B 误以为和你完成了密钥交换。现在，由 A -> B完整的加密，变成了 A（加密连接1） -> M（明文）->B（加密连接2）的情况了。这时候 M 依然可以知道 A 和 B 传输中的全部信息。\n\n对于这种事，我们似乎很难找到一个解决方法来解决这个问题，除非我们能从源头保证，你密钥交换的对象是安全的。这时候我们就要认识互联网 HTTPS 和你传纸条的微妙区别了。你传纸条时，你和你的目的地的关系几乎是对等的。而你访问网站时，你访问的对象通常是一个比较大的服务供应商，他们有充沛的资源，也许可以证明他们的合法性。\n\n这时候我们会引入一个第三方叫做 CA。CA 是一些非常权威的专门用于认证一个网站合法性的组织。服务商可以向他们申请一个证书，使得他们建立安全连接时可以带上 CA 的签名。而 CA 的安全性由操作系统或浏览器来认证。你的 Windows、Mac、Linux、Chrome、Safari 等会在安装时带上一个他们认为安全的 CA 证书列表。如果和你建立安全连接的人带着这些人的签名，那么认为这个安全连接是安全的，没有遭到中间人攻击。\n\nCA 证书通常情况下是安全的。因为一旦某个 CA 颁发出的某个证书被用于了非法用途，浏览器和操作系统一般会通过更新将整个 CA 颁发过的全部证书全部视为不安全。这使得 CA 通常在颁发证书时是比较小心的。\n\n所以通过 对称加密 + 非对称加密 + CA认证 这三个技术混合在一起，才使得 HTTP 的后面加上了一个 S —— Security。实际上 HTTPS 的协议比我这里描述的更复杂一些，我这里说的主要是基本的实现原理。因为其中任何一环稍有闪失，就会使得整个加密都将变得不安全。这也是为什么 HTTPS 的加密协议从SSL 1.0 升级到 SSL 3.0 再被 TLS 1.0 现在被 TLS 1.2 取代，其背后都是一环环细节上的修改，以防任何地方的闪失。\n\n但即使如此，你的 HTTPS 尽可能的保证了你传输的安全，但这种安全也不是绝对的。比如 CA 证书出了问题被用于了中间人攻击，在短期内，你的安全将会陷入直接的麻烦直到浏览器或操作系统重新更新了你的 CA 列表或者你手动调整了这个列表。但大多情况下不必杞人忧天，它基本上是安全的。\n\n当然了，路由也可以选择直接丢包，它看不到的，也不让你看到。","source":"_posts/how-https-makes-communication-secured.md","raw":"---\ntitle: HTTPS 是如何保证安全的？\ndate: 2015-04-16 04:21:48\ntags: [HTTPS,安全,通讯]\n---\n\n每当我们讨论到信息安全的时候，我们最长接触到的信息加密传输的方式莫过于 HTTPS 了，当我们浏览器地址栏闪现出绿色时，就代表着这个网站支持 HTTPS 的加密信息传输方式，并且你与它的连接确实被加密了。但是 HTTPS 并不是一个单一的东西，它知识我们常见的 HTTP 协议和某个加密协议的一个混合，这个加密协议通常会是 TLS。那么 HTTPS 为什么安全呢？其实我们需要先考虑 HTTP 为什么不安全。\n\n<!--more-->\n\n假设你坐在一个教室里，你现在非常想把某个信息传递给教室里的另一个人，一般来说，会选择，传纸条。传纸条这个比喻其实非常正确，这就是互联网的一个基础协议 TCP/IP 协议基本的工作模式。而通常，HTTP 协议的数据是使用 TCP/IP 协议进行发送的。HTTP 指的是你在纸条上写明你要传送的目的地是哪个同学的坐位，然后再是要传递的内容。途径的同学拿到纸条后根据纸条上显示的地址依次传过去就好了。这样要面临的第一个问题就是：途径的同学可以完全知道你写了什么。\n\n这就是 HTTP 面临的第一个问题，这个问题通常被叫做 “窃听” 或者 “嗅探” ，指的是和你在同一个网络下或者是途径的路由上的攻击者可以偷窥到你传输的内容。这是 HTTPS 要解决的第一个问题。这种问题通常是通过“加密”来解决的。从非常原始的角度来考虑，其实就是双方约定一个暗号。用什么字母去替代什么字母之类的。不过考虑到互联网每天有无数信息需要加密，这种原始的加密方法似乎不太适合。不过实际上方法也差不多，一般是采用一种叫做 AES 的算法来解决的。这种算法需要一个 密钥 key 来加密整个信息，加密和解密所需要使用的 key 是一样的，所以这种加密一般也被称为“对称加密”。AES 在数学上保证了，只要你使用的 key 足够足够足够足够的长，破解是几乎不可能的。\n\n我们先假设这种破解确实是不可能的，而且目前也确实没有对 AES 本身能发动起有效的攻击的案例出现。\n\n我们再回到这个教室，你接着要传小纸条，你把地址写上后，把要传输的内容用 AES 蹭蹭蹭加密了起来。刚准备传，问题来了。AES 不是有一个 key 吗？key 怎么给目的地啊？如果我把密钥直接写在纸条上，那么中间的人不依然可以解密吗？在现实中你可以通过一些其它方法来把密钥安全传输给目的地而不被其他人看见，但是在互联网上，要想这么做难度就很大了，毕竟传输终究要经过这些路由，所以要做加密，还得找一个更复杂的数学方法。\n\n于是聪明的人们发明了一种更复杂的加密算法——非对称加密。这种加密或许理解起来比较困难，这种加密指的是可以生成一对密钥 (k1, k2)。凡是 k1 加密的数据，k1 自身不能解密，而需要 k2 才能解密；凡是 k2 加密的数据，k2 不能解密，需要 k1 才能解密。这种算法事实上有很多，常用的是 RSA，其基于的数学原理是两个大素数的乘积很容易算，而拿到这个乘积去算出是哪两个素数相乘就很复杂了。好在以目前的技术，分解大数的素因数确实比较困难，尤其是当这个大数足够大的时候（通常使用2的10次方个二进制位这么大），就算是超级计算机解密也需要非常长的时间。\n\n现在利用这种非对称加密的方法，我们来设想一个场景。你继续想要传纸条，但是传纸条之前你先准备把接下来通讯的对称加密密钥给传输过去。于是你用 RSA 技术生成了一对 k1、k2，你把 k1 用明文发送了出去，路经有人或许会截取，但是没有用，k1 加密的数据需要用 k2 才能解密。而此时，k2 在你自己的手里。k1 送达目的地后，目的地的人会去准备一个接下来用于对称加密传输的密钥 key，然后用收到的 k1 把 key 加密了，把加密好的数据传回来。路上的人就算截取到了，也解密不出 key。等到了你自己手上，你用手上的 k2 把用 k1 加密的 key 解出来，现在全教室就只有你和你的目的地拥有 key，你们就可以用 AES 算法进行对称加密的传输啦！这时候你和目的地的通讯将无法再被任何人窃听！\n\n当然，这时候你可能会问两个问题。\n\n既然 非对称加密 可以那么安全，为什么我们不直接用它来加密信息，而是去加密 对称加密 的密钥呢？\n\n这是因为 非对称加密 的密码对生成和加密的消耗时间比较长，为了节省双方的计算时间，通常只用它来交换密钥，而非直接用来传输数据。\n\n使用 非对称加密 是完全安全的吗？\n\n听起来确实是挺安全的，但实际上，还有一种更恶劣的攻击是这种方法无法防范的，这就是传说中的“中间人攻击”。我们继续让你坐在教室里传小纸条。现在你和目的地上途径一个中间人，他有意想要知道你们的消息。由于这个描述比较复杂，我们将你称为 A，你的目的地称为 B，而中间人称为 M。当你要和 B 完成第一次密钥交换的时候，途径了 M。M 知道你要进行密钥交换了，它把小纸条扣了下来，假装自己是 B，伪造了一个 key ，然后用你发来的 k1 加密了 key 发还给你，你以为你和 B 完成了密钥交换，实际上你是和 M 完成了密钥交换。同时 M 和 B 完成一次密钥交换，让 B 误以为和你完成了密钥交换。现在，由 A -> B完整的加密，变成了 A（加密连接1） -> M（明文）->B（加密连接2）的情况了。这时候 M 依然可以知道 A 和 B 传输中的全部信息。\n\n对于这种事，我们似乎很难找到一个解决方法来解决这个问题，除非我们能从源头保证，你密钥交换的对象是安全的。这时候我们就要认识互联网 HTTPS 和你传纸条的微妙区别了。你传纸条时，你和你的目的地的关系几乎是对等的。而你访问网站时，你访问的对象通常是一个比较大的服务供应商，他们有充沛的资源，也许可以证明他们的合法性。\n\n这时候我们会引入一个第三方叫做 CA。CA 是一些非常权威的专门用于认证一个网站合法性的组织。服务商可以向他们申请一个证书，使得他们建立安全连接时可以带上 CA 的签名。而 CA 的安全性由操作系统或浏览器来认证。你的 Windows、Mac、Linux、Chrome、Safari 等会在安装时带上一个他们认为安全的 CA 证书列表。如果和你建立安全连接的人带着这些人的签名，那么认为这个安全连接是安全的，没有遭到中间人攻击。\n\nCA 证书通常情况下是安全的。因为一旦某个 CA 颁发出的某个证书被用于了非法用途，浏览器和操作系统一般会通过更新将整个 CA 颁发过的全部证书全部视为不安全。这使得 CA 通常在颁发证书时是比较小心的。\n\n所以通过 对称加密 + 非对称加密 + CA认证 这三个技术混合在一起，才使得 HTTP 的后面加上了一个 S —— Security。实际上 HTTPS 的协议比我这里描述的更复杂一些，我这里说的主要是基本的实现原理。因为其中任何一环稍有闪失，就会使得整个加密都将变得不安全。这也是为什么 HTTPS 的加密协议从SSL 1.0 升级到 SSL 3.0 再被 TLS 1.0 现在被 TLS 1.2 取代，其背后都是一环环细节上的修改，以防任何地方的闪失。\n\n但即使如此，你的 HTTPS 尽可能的保证了你传输的安全，但这种安全也不是绝对的。比如 CA 证书出了问题被用于了中间人攻击，在短期内，你的安全将会陷入直接的麻烦直到浏览器或操作系统重新更新了你的 CA 列表或者你手动调整了这个列表。但大多情况下不必杞人忧天，它基本上是安全的。\n\n当然了，路由也可以选择直接丢包，它看不到的，也不让你看到。","slug":"how-https-makes-communication-secured","published":1,"updated":"2016-04-21T18:32:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscy0096000spp8zwzd3a52x","content":"<p>每当我们讨论到信息安全的时候，我们最长接触到的信息加密传输的方式莫过于 HTTPS 了，当我们浏览器地址栏闪现出绿色时，就代表着这个网站支持 HTTPS 的加密信息传输方式，并且你与它的连接确实被加密了。但是 HTTPS 并不是一个单一的东西，它知识我们常见的 HTTP 协议和某个加密协议的一个混合，这个加密协议通常会是 TLS。那么 HTTPS 为什么安全呢？其实我们需要先考虑 HTTP 为什么不安全。</p>\n<a id=\"more\"></a>\n<p>假设你坐在一个教室里，你现在非常想把某个信息传递给教室里的另一个人，一般来说，会选择，传纸条。传纸条这个比喻其实非常正确，这就是互联网的一个基础协议 TCP/IP 协议基本的工作模式。而通常，HTTP 协议的数据是使用 TCP/IP 协议进行发送的。HTTP 指的是你在纸条上写明你要传送的目的地是哪个同学的坐位，然后再是要传递的内容。途径的同学拿到纸条后根据纸条上显示的地址依次传过去就好了。这样要面临的第一个问题就是：途径的同学可以完全知道你写了什么。</p>\n<p>这就是 HTTP 面临的第一个问题，这个问题通常被叫做 “窃听” 或者 “嗅探” ，指的是和你在同一个网络下或者是途径的路由上的攻击者可以偷窥到你传输的内容。这是 HTTPS 要解决的第一个问题。这种问题通常是通过“加密”来解决的。从非常原始的角度来考虑，其实就是双方约定一个暗号。用什么字母去替代什么字母之类的。不过考虑到互联网每天有无数信息需要加密，这种原始的加密方法似乎不太适合。不过实际上方法也差不多，一般是采用一种叫做 AES 的算法来解决的。这种算法需要一个 密钥 key 来加密整个信息，加密和解密所需要使用的 key 是一样的，所以这种加密一般也被称为“对称加密”。AES 在数学上保证了，只要你使用的 key 足够足够足够足够的长，破解是几乎不可能的。</p>\n<p>我们先假设这种破解确实是不可能的，而且目前也确实没有对 AES 本身能发动起有效的攻击的案例出现。</p>\n<p>我们再回到这个教室，你接着要传小纸条，你把地址写上后，把要传输的内容用 AES 蹭蹭蹭加密了起来。刚准备传，问题来了。AES 不是有一个 key 吗？key 怎么给目的地啊？如果我把密钥直接写在纸条上，那么中间的人不依然可以解密吗？在现实中你可以通过一些其它方法来把密钥安全传输给目的地而不被其他人看见，但是在互联网上，要想这么做难度就很大了，毕竟传输终究要经过这些路由，所以要做加密，还得找一个更复杂的数学方法。</p>\n<p>于是聪明的人们发明了一种更复杂的加密算法——非对称加密。这种加密或许理解起来比较困难，这种加密指的是可以生成一对密钥 (k1, k2)。凡是 k1 加密的数据，k1 自身不能解密，而需要 k2 才能解密；凡是 k2 加密的数据，k2 不能解密，需要 k1 才能解密。这种算法事实上有很多，常用的是 RSA，其基于的数学原理是两个大素数的乘积很容易算，而拿到这个乘积去算出是哪两个素数相乘就很复杂了。好在以目前的技术，分解大数的素因数确实比较困难，尤其是当这个大数足够大的时候（通常使用2的10次方个二进制位这么大），就算是超级计算机解密也需要非常长的时间。</p>\n<p>现在利用这种非对称加密的方法，我们来设想一个场景。你继续想要传纸条，但是传纸条之前你先准备把接下来通讯的对称加密密钥给传输过去。于是你用 RSA 技术生成了一对 k1、k2，你把 k1 用明文发送了出去，路经有人或许会截取，但是没有用，k1 加密的数据需要用 k2 才能解密。而此时，k2 在你自己的手里。k1 送达目的地后，目的地的人会去准备一个接下来用于对称加密传输的密钥 key，然后用收到的 k1 把 key 加密了，把加密好的数据传回来。路上的人就算截取到了，也解密不出 key。等到了你自己手上，你用手上的 k2 把用 k1 加密的 key 解出来，现在全教室就只有你和你的目的地拥有 key，你们就可以用 AES 算法进行对称加密的传输啦！这时候你和目的地的通讯将无法再被任何人窃听！</p>\n<p>当然，这时候你可能会问两个问题。</p>\n<p>既然 非对称加密 可以那么安全，为什么我们不直接用它来加密信息，而是去加密 对称加密 的密钥呢？</p>\n<p>这是因为 非对称加密 的密码对生成和加密的消耗时间比较长，为了节省双方的计算时间，通常只用它来交换密钥，而非直接用来传输数据。</p>\n<p>使用 非对称加密 是完全安全的吗？</p>\n<p>听起来确实是挺安全的，但实际上，还有一种更恶劣的攻击是这种方法无法防范的，这就是传说中的“中间人攻击”。我们继续让你坐在教室里传小纸条。现在你和目的地上途径一个中间人，他有意想要知道你们的消息。由于这个描述比较复杂，我们将你称为 A，你的目的地称为 B，而中间人称为 M。当你要和 B 完成第一次密钥交换的时候，途径了 M。M 知道你要进行密钥交换了，它把小纸条扣了下来，假装自己是 B，伪造了一个 key ，然后用你发来的 k1 加密了 key 发还给你，你以为你和 B 完成了密钥交换，实际上你是和 M 完成了密钥交换。同时 M 和 B 完成一次密钥交换，让 B 误以为和你完成了密钥交换。现在，由 A -&gt; B完整的加密，变成了 A（加密连接1） -&gt; M（明文）-&gt;B（加密连接2）的情况了。这时候 M 依然可以知道 A 和 B 传输中的全部信息。</p>\n<p>对于这种事，我们似乎很难找到一个解决方法来解决这个问题，除非我们能从源头保证，你密钥交换的对象是安全的。这时候我们就要认识互联网 HTTPS 和你传纸条的微妙区别了。你传纸条时，你和你的目的地的关系几乎是对等的。而你访问网站时，你访问的对象通常是一个比较大的服务供应商，他们有充沛的资源，也许可以证明他们的合法性。</p>\n<p>这时候我们会引入一个第三方叫做 CA。CA 是一些非常权威的专门用于认证一个网站合法性的组织。服务商可以向他们申请一个证书，使得他们建立安全连接时可以带上 CA 的签名。而 CA 的安全性由操作系统或浏览器来认证。你的 Windows、Mac、Linux、Chrome、Safari 等会在安装时带上一个他们认为安全的 CA 证书列表。如果和你建立安全连接的人带着这些人的签名，那么认为这个安全连接是安全的，没有遭到中间人攻击。</p>\n<p>CA 证书通常情况下是安全的。因为一旦某个 CA 颁发出的某个证书被用于了非法用途，浏览器和操作系统一般会通过更新将整个 CA 颁发过的全部证书全部视为不安全。这使得 CA 通常在颁发证书时是比较小心的。</p>\n<p>所以通过 对称加密 + 非对称加密 + CA认证 这三个技术混合在一起，才使得 HTTP 的后面加上了一个 S —— Security。实际上 HTTPS 的协议比我这里描述的更复杂一些，我这里说的主要是基本的实现原理。因为其中任何一环稍有闪失，就会使得整个加密都将变得不安全。这也是为什么 HTTPS 的加密协议从SSL 1.0 升级到 SSL 3.0 再被 TLS 1.0 现在被 TLS 1.2 取代，其背后都是一环环细节上的修改，以防任何地方的闪失。</p>\n<p>但即使如此，你的 HTTPS 尽可能的保证了你传输的安全，但这种安全也不是绝对的。比如 CA 证书出了问题被用于了中间人攻击，在短期内，你的安全将会陷入直接的麻烦直到浏览器或操作系统重新更新了你的 CA 列表或者你手动调整了这个列表。但大多情况下不必杞人忧天，它基本上是安全的。</p>\n<p>当然了，路由也可以选择直接丢包，它看不到的，也不让你看到。</p>\n","excerpt":"<p>每当我们讨论到信息安全的时候，我们最长接触到的信息加密传输的方式莫过于 HTTPS 了，当我们浏览器地址栏闪现出绿色时，就代表着这个网站支持 HTTPS 的加密信息传输方式，并且你与它的连接确实被加密了。但是 HTTPS 并不是一个单一的东西，它知识我们常见的 HTTP 协议和某个加密协议的一个混合，这个加密协议通常会是 TLS。那么 HTTPS 为什么安全呢？其实我们需要先考虑 HTTP 为什么不安全。</p>","more":"<p>假设你坐在一个教室里，你现在非常想把某个信息传递给教室里的另一个人，一般来说，会选择，传纸条。传纸条这个比喻其实非常正确，这就是互联网的一个基础协议 TCP/IP 协议基本的工作模式。而通常，HTTP 协议的数据是使用 TCP/IP 协议进行发送的。HTTP 指的是你在纸条上写明你要传送的目的地是哪个同学的坐位，然后再是要传递的内容。途径的同学拿到纸条后根据纸条上显示的地址依次传过去就好了。这样要面临的第一个问题就是：途径的同学可以完全知道你写了什么。</p>\n<p>这就是 HTTP 面临的第一个问题，这个问题通常被叫做 “窃听” 或者 “嗅探” ，指的是和你在同一个网络下或者是途径的路由上的攻击者可以偷窥到你传输的内容。这是 HTTPS 要解决的第一个问题。这种问题通常是通过“加密”来解决的。从非常原始的角度来考虑，其实就是双方约定一个暗号。用什么字母去替代什么字母之类的。不过考虑到互联网每天有无数信息需要加密，这种原始的加密方法似乎不太适合。不过实际上方法也差不多，一般是采用一种叫做 AES 的算法来解决的。这种算法需要一个 密钥 key 来加密整个信息，加密和解密所需要使用的 key 是一样的，所以这种加密一般也被称为“对称加密”。AES 在数学上保证了，只要你使用的 key 足够足够足够足够的长，破解是几乎不可能的。</p>\n<p>我们先假设这种破解确实是不可能的，而且目前也确实没有对 AES 本身能发动起有效的攻击的案例出现。</p>\n<p>我们再回到这个教室，你接着要传小纸条，你把地址写上后，把要传输的内容用 AES 蹭蹭蹭加密了起来。刚准备传，问题来了。AES 不是有一个 key 吗？key 怎么给目的地啊？如果我把密钥直接写在纸条上，那么中间的人不依然可以解密吗？在现实中你可以通过一些其它方法来把密钥安全传输给目的地而不被其他人看见，但是在互联网上，要想这么做难度就很大了，毕竟传输终究要经过这些路由，所以要做加密，还得找一个更复杂的数学方法。</p>\n<p>于是聪明的人们发明了一种更复杂的加密算法——非对称加密。这种加密或许理解起来比较困难，这种加密指的是可以生成一对密钥 (k1, k2)。凡是 k1 加密的数据，k1 自身不能解密，而需要 k2 才能解密；凡是 k2 加密的数据，k2 不能解密，需要 k1 才能解密。这种算法事实上有很多，常用的是 RSA，其基于的数学原理是两个大素数的乘积很容易算，而拿到这个乘积去算出是哪两个素数相乘就很复杂了。好在以目前的技术，分解大数的素因数确实比较困难，尤其是当这个大数足够大的时候（通常使用2的10次方个二进制位这么大），就算是超级计算机解密也需要非常长的时间。</p>\n<p>现在利用这种非对称加密的方法，我们来设想一个场景。你继续想要传纸条，但是传纸条之前你先准备把接下来通讯的对称加密密钥给传输过去。于是你用 RSA 技术生成了一对 k1、k2，你把 k1 用明文发送了出去，路经有人或许会截取，但是没有用，k1 加密的数据需要用 k2 才能解密。而此时，k2 在你自己的手里。k1 送达目的地后，目的地的人会去准备一个接下来用于对称加密传输的密钥 key，然后用收到的 k1 把 key 加密了，把加密好的数据传回来。路上的人就算截取到了，也解密不出 key。等到了你自己手上，你用手上的 k2 把用 k1 加密的 key 解出来，现在全教室就只有你和你的目的地拥有 key，你们就可以用 AES 算法进行对称加密的传输啦！这时候你和目的地的通讯将无法再被任何人窃听！</p>\n<p>当然，这时候你可能会问两个问题。</p>\n<p>既然 非对称加密 可以那么安全，为什么我们不直接用它来加密信息，而是去加密 对称加密 的密钥呢？</p>\n<p>这是因为 非对称加密 的密码对生成和加密的消耗时间比较长，为了节省双方的计算时间，通常只用它来交换密钥，而非直接用来传输数据。</p>\n<p>使用 非对称加密 是完全安全的吗？</p>\n<p>听起来确实是挺安全的，但实际上，还有一种更恶劣的攻击是这种方法无法防范的，这就是传说中的“中间人攻击”。我们继续让你坐在教室里传小纸条。现在你和目的地上途径一个中间人，他有意想要知道你们的消息。由于这个描述比较复杂，我们将你称为 A，你的目的地称为 B，而中间人称为 M。当你要和 B 完成第一次密钥交换的时候，途径了 M。M 知道你要进行密钥交换了，它把小纸条扣了下来，假装自己是 B，伪造了一个 key ，然后用你发来的 k1 加密了 key 发还给你，你以为你和 B 完成了密钥交换，实际上你是和 M 完成了密钥交换。同时 M 和 B 完成一次密钥交换，让 B 误以为和你完成了密钥交换。现在，由 A -&gt; B完整的加密，变成了 A（加密连接1） -&gt; M（明文）-&gt;B（加密连接2）的情况了。这时候 M 依然可以知道 A 和 B 传输中的全部信息。</p>\n<p>对于这种事，我们似乎很难找到一个解决方法来解决这个问题，除非我们能从源头保证，你密钥交换的对象是安全的。这时候我们就要认识互联网 HTTPS 和你传纸条的微妙区别了。你传纸条时，你和你的目的地的关系几乎是对等的。而你访问网站时，你访问的对象通常是一个比较大的服务供应商，他们有充沛的资源，也许可以证明他们的合法性。</p>\n<p>这时候我们会引入一个第三方叫做 CA。CA 是一些非常权威的专门用于认证一个网站合法性的组织。服务商可以向他们申请一个证书，使得他们建立安全连接时可以带上 CA 的签名。而 CA 的安全性由操作系统或浏览器来认证。你的 Windows、Mac、Linux、Chrome、Safari 等会在安装时带上一个他们认为安全的 CA 证书列表。如果和你建立安全连接的人带着这些人的签名，那么认为这个安全连接是安全的，没有遭到中间人攻击。</p>\n<p>CA 证书通常情况下是安全的。因为一旦某个 CA 颁发出的某个证书被用于了非法用途，浏览器和操作系统一般会通过更新将整个 CA 颁发过的全部证书全部视为不安全。这使得 CA 通常在颁发证书时是比较小心的。</p>\n<p>所以通过 对称加密 + 非对称加密 + CA认证 这三个技术混合在一起，才使得 HTTP 的后面加上了一个 S —— Security。实际上 HTTPS 的协议比我这里描述的更复杂一些，我这里说的主要是基本的实现原理。因为其中任何一环稍有闪失，就会使得整个加密都将变得不安全。这也是为什么 HTTPS 的加密协议从SSL 1.0 升级到 SSL 3.0 再被 TLS 1.0 现在被 TLS 1.2 取代，其背后都是一环环细节上的修改，以防任何地方的闪失。</p>\n<p>但即使如此，你的 HTTPS 尽可能的保证了你传输的安全，但这种安全也不是绝对的。比如 CA 证书出了问题被用于了中间人攻击，在短期内，你的安全将会陷入直接的麻烦直到浏览器或操作系统重新更新了你的 CA 列表或者你手动调整了这个列表。但大多情况下不必杞人忧天，它基本上是安全的。</p>\n<p>当然了，路由也可以选择直接丢包，它看不到的，也不让你看到。</p>"},{"title":"认识 Y-Combinator","date":"2016-03-19T00:50:00.000Z","dsc":"所以当我第一次见到 Y-Combinator（Y 组合子）的时候，我的感觉是懵逼的，这是什么玩意。然而当我一步一步，了解这个东西是什么，它是怎么工作的之后，我对函数式编程的认识有了很大的进步。","_content":"\n## 写在开始\n\n不得不说，当我开始学习函数式编程的时候，我并没有被匿名函数感到害怕，理解它的基本概念是极其容易的。但是当你试图去将你日常所书写的指令式的代码转换成函数式，特别是纯函数式的时候，你会感到这是不可能的。它和你之前的编程思想是完全脱离的。\n\n所以当我第一次见到 Y-Combinator（Y 组合子）的时候，我的感觉是懵逼的，这是什么玩意。然而当我一步一步，了解这个东西是什么，它是怎么工作的之后，我对函数式编程的认识有了很大的进步。\n\n即使是 C++ 这样的语言，也在 C++11 标准中引入了匿名函数，使得你有机会在 C++ 中使用函数式编程的特性。在编程中，如果能适当地使用函数式语法进行编程，将非常有助于你写出一些更好理解、更简单的代码。\n\n而在了解一些基本概念之后，了解一下 Y-Combinator 是一个极好的选择，这个东西证明了函数式编程对递归的语义理解，证明了其在递归上和指令式编程的等价之处。你可以通过观察等价的这两者的不同的实现方式，来加深对这两者思想的认识。\n\n<!--more-->\n\n## 与指令式编程的根本区别\n\n大家看下面一段 C 代码\n\n```c++\nfor (int i = 0; i < 100; i++){\n  puts(\"Hello World\");\n}\n```\n\n显然这是一个非常常见的循环。然而这样的循环显然已经被抽象过了，我们也许可以用一个更原始的方法来实现。且让我引入一个 C 开发中应尽量避免的语句 `goto` 来解释。\n\n```C++\nint i = 0;\nloop:\nif (i >= 100) goto next;\nputs(\"Hello World\");\ni++;\ngoto loop;\nnext:\n```\n\n这两段代码除了变量 `i` 的作用域有所区别以外几乎是等价的。相对的，第二段代码非常接近于编译到汇编时的指令，几乎是一一映射的。然而你可以发现，我们的循环都是依赖于跳转代码行数的，不得不说这种写法非常不函数式。\n\n## 第一个函数\n\n我们可以用一个递归来把这个循环实现地更像一个函数：\n\n```C++\nint loop(int n){\n  if (n == 0) return 0;\n  puts(\"Hello World\");\n  return loop(n - 1);\n}\nloop(100);\n```\n\n虽然这个函数是倒过来循环的，但我们大可忽略这些细节，毕竟要做修改也是相对容易的。我们通过一个函数递归的方式来实现了一个循环。需要特别注意的是，如果根据递归的定义，那么这个循环一旦大起来在今天我们的计算机的计算模型（而不是 Lisp Machine）上是会爆栈的，但好在由于是个尾递归，通常是会直接被编译器优化成一个循环的。这确保了即使你写的是函数式代码，也可以最终编译成适合 CPU 运算的形式而不太影响性能。\n\n不过递归有一个问题，我们必须知道函数的名称才能这么做，在真正的 Lambda 运算模型上，函数是匿名的，也就是没有名字，这样你最后根本就无处调用你函数自己。因为你无法写出下面的代码（Ruby）：\n\n```ruby\nlambda { |n|\n  return if n == 0\n  puts \"Hello World\"\n  what_the_f**k_my_function_name_is(n-1)\n}\n```\n\n## 魔法少女 Lambda 酱\n\n下面我们演示一种黑魔法，来使得你没有办法得到自己函数名时实现递归。简单来说就是把「函数」当成一个「参数」传输。\n\n```ruby\nloop = lambda {|f, n|\n  return if n == 0\n  puts \"Hello World\"\n  f.call(n-1)\n  }\nloop.call(loop, 100);\n```\n\n我们把函数本身作为一个参数传了进去，达到了我们的想法。不过这里我们还不是一个完全的匿名函数，而是通过给匿名函数起了一个名字 `loop`，在外面调用了一下。不过事到如今，去掉这个 `loop` 已经很容易了。由于第一条的匿名函数定义中没有任何地方用到 `loop` 只在第二条指令中用到。我们只要将第二条指令中的所有 `loop` 都代换掉就行。我们就能得到下面的代码：\n\n```ruby\nlambda {|f, n|\n  return if n == 0\n  puts \"Hello World\"\n  f.call(n-1)\n  }.call(lambda{|f, n|\n    return if n == 0\n    puts \"Hello World\"\n    f.call(n-1)\n    }, 100)\n```\n\n## 柯里化，最后一步\n\nAmazing！我们通过一个匿名函数的调用成功实现了一个 100 的循环。我们现在距离 Haskell Brooks Curry 先生当年推出 Y 组合子只差一步，那就是将我们做的事情「Currying」（柯里化）。所谓 Currying 就是使用一个高阶函数，将一个函数的多个参数精简成一个。我们看到我们现在的匿名函数还有 `f` 和 `n` 两个参数，我们打算拿掉它。虽然其实并不是真正意义上的拿掉。柯里化，只不过把一个形如 `f(x, y)` 的函数写成了 `f(x)(y)`，也就是 `f(x)` 的返回是一个匿名函数，而这个匿名函数再以 `y` 为参数执行一次。这么搞一下，我们就得到了：\n\n```ruby\nlambda {|p|\n  return lambda { |f|\n    return f.call(f);\n    }.call(lambda {|f| \n      return p.call(lambda {|x| \n        return f.call(f).call(x)\n        })\n      })\n  }.call(lambda {|f| \n    return lambda {|i| \n      return if i == 0; \n      f.call(i-1)\n      }\n    }).call(100)\n```\n\n由于柯里化后匿名函数和调用的参数都单一了，我们因此可以保证我们能将任意一个递归都表达成一个匿名函数的形式。按照 Lambda 演算的形式化表达  `Y := λf.(λx.(f (x x)) λx.(f (x x)))` 。你只要将自己要递归的函数替换掉里面 `f` 的位置，并最后执行一下这个匿名函数就成啦~\n\n## 折腾半天干什么\n\n你肯定想问，我们把一个循环写成这么复杂是为了什么。事实上我想展示的不是循环，而是递归。递归在图灵模型（我们通常 CPU 的计算模型）和丘奇模型（Lambda 演算）上都不是那么地原生的实现。\n\n在图灵模型上地最终形式是每次递归，追加进内存中，并重新 `goto` 回函数开始，在退出时，再一步步内存推出来，并将递归的剩余部分执行完。\n\n而在 Lambda 演算中，最终表达为一个\b逻辑系统构成的严格的数学函数模型的执行。\n\n这两者便是具体化和形式化的极限，充分表现了两种模型的特点。从根本加深了对两种模型差异的认知，从而让我们在两种模型上都能通过正确的编程思想来写代码，以把代码写得更好。\n\n当然也是有一些实际意义的，比如在变量作用域严格的语言中，且又必须使用匿名函数的形式来书写你所需要的东西的时候，而你正好又需要递归才能达到你的要求，那么使用 Y-Combinator 是一个可选的方法。然而通常，出现这种情况大多是你写了错误的思想的代码所导致的，实际编程中几乎遇不到这种情况，毕竟将更抽象更容易理解的函数式编程写成这么一坨一眼看不懂的代码是很失败的。\n\n","source":"_posts/learn-y-combinator.md","raw":"---\ntitle: 认识 Y-Combinator\ndate: 2016-03-19 08:50:00\ndsc: 所以当我第一次见到 Y-Combinator（Y 组合子）的时候，我的感觉是懵逼的，这是什么玩意。然而当我一步一步，了解这个东西是什么，它是怎么工作的之后，我对函数式编程的认识有了很大的进步。\ntags: [Lambda,编程,Lisp]\n---\n\n## 写在开始\n\n不得不说，当我开始学习函数式编程的时候，我并没有被匿名函数感到害怕，理解它的基本概念是极其容易的。但是当你试图去将你日常所书写的指令式的代码转换成函数式，特别是纯函数式的时候，你会感到这是不可能的。它和你之前的编程思想是完全脱离的。\n\n所以当我第一次见到 Y-Combinator（Y 组合子）的时候，我的感觉是懵逼的，这是什么玩意。然而当我一步一步，了解这个东西是什么，它是怎么工作的之后，我对函数式编程的认识有了很大的进步。\n\n即使是 C++ 这样的语言，也在 C++11 标准中引入了匿名函数，使得你有机会在 C++ 中使用函数式编程的特性。在编程中，如果能适当地使用函数式语法进行编程，将非常有助于你写出一些更好理解、更简单的代码。\n\n而在了解一些基本概念之后，了解一下 Y-Combinator 是一个极好的选择，这个东西证明了函数式编程对递归的语义理解，证明了其在递归上和指令式编程的等价之处。你可以通过观察等价的这两者的不同的实现方式，来加深对这两者思想的认识。\n\n<!--more-->\n\n## 与指令式编程的根本区别\n\n大家看下面一段 C 代码\n\n```c++\nfor (int i = 0; i < 100; i++){\n  puts(\"Hello World\");\n}\n```\n\n显然这是一个非常常见的循环。然而这样的循环显然已经被抽象过了，我们也许可以用一个更原始的方法来实现。且让我引入一个 C 开发中应尽量避免的语句 `goto` 来解释。\n\n```C++\nint i = 0;\nloop:\nif (i >= 100) goto next;\nputs(\"Hello World\");\ni++;\ngoto loop;\nnext:\n```\n\n这两段代码除了变量 `i` 的作用域有所区别以外几乎是等价的。相对的，第二段代码非常接近于编译到汇编时的指令，几乎是一一映射的。然而你可以发现，我们的循环都是依赖于跳转代码行数的，不得不说这种写法非常不函数式。\n\n## 第一个函数\n\n我们可以用一个递归来把这个循环实现地更像一个函数：\n\n```C++\nint loop(int n){\n  if (n == 0) return 0;\n  puts(\"Hello World\");\n  return loop(n - 1);\n}\nloop(100);\n```\n\n虽然这个函数是倒过来循环的，但我们大可忽略这些细节，毕竟要做修改也是相对容易的。我们通过一个函数递归的方式来实现了一个循环。需要特别注意的是，如果根据递归的定义，那么这个循环一旦大起来在今天我们的计算机的计算模型（而不是 Lisp Machine）上是会爆栈的，但好在由于是个尾递归，通常是会直接被编译器优化成一个循环的。这确保了即使你写的是函数式代码，也可以最终编译成适合 CPU 运算的形式而不太影响性能。\n\n不过递归有一个问题，我们必须知道函数的名称才能这么做，在真正的 Lambda 运算模型上，函数是匿名的，也就是没有名字，这样你最后根本就无处调用你函数自己。因为你无法写出下面的代码（Ruby）：\n\n```ruby\nlambda { |n|\n  return if n == 0\n  puts \"Hello World\"\n  what_the_f**k_my_function_name_is(n-1)\n}\n```\n\n## 魔法少女 Lambda 酱\n\n下面我们演示一种黑魔法，来使得你没有办法得到自己函数名时实现递归。简单来说就是把「函数」当成一个「参数」传输。\n\n```ruby\nloop = lambda {|f, n|\n  return if n == 0\n  puts \"Hello World\"\n  f.call(n-1)\n  }\nloop.call(loop, 100);\n```\n\n我们把函数本身作为一个参数传了进去，达到了我们的想法。不过这里我们还不是一个完全的匿名函数，而是通过给匿名函数起了一个名字 `loop`，在外面调用了一下。不过事到如今，去掉这个 `loop` 已经很容易了。由于第一条的匿名函数定义中没有任何地方用到 `loop` 只在第二条指令中用到。我们只要将第二条指令中的所有 `loop` 都代换掉就行。我们就能得到下面的代码：\n\n```ruby\nlambda {|f, n|\n  return if n == 0\n  puts \"Hello World\"\n  f.call(n-1)\n  }.call(lambda{|f, n|\n    return if n == 0\n    puts \"Hello World\"\n    f.call(n-1)\n    }, 100)\n```\n\n## 柯里化，最后一步\n\nAmazing！我们通过一个匿名函数的调用成功实现了一个 100 的循环。我们现在距离 Haskell Brooks Curry 先生当年推出 Y 组合子只差一步，那就是将我们做的事情「Currying」（柯里化）。所谓 Currying 就是使用一个高阶函数，将一个函数的多个参数精简成一个。我们看到我们现在的匿名函数还有 `f` 和 `n` 两个参数，我们打算拿掉它。虽然其实并不是真正意义上的拿掉。柯里化，只不过把一个形如 `f(x, y)` 的函数写成了 `f(x)(y)`，也就是 `f(x)` 的返回是一个匿名函数，而这个匿名函数再以 `y` 为参数执行一次。这么搞一下，我们就得到了：\n\n```ruby\nlambda {|p|\n  return lambda { |f|\n    return f.call(f);\n    }.call(lambda {|f| \n      return p.call(lambda {|x| \n        return f.call(f).call(x)\n        })\n      })\n  }.call(lambda {|f| \n    return lambda {|i| \n      return if i == 0; \n      f.call(i-1)\n      }\n    }).call(100)\n```\n\n由于柯里化后匿名函数和调用的参数都单一了，我们因此可以保证我们能将任意一个递归都表达成一个匿名函数的形式。按照 Lambda 演算的形式化表达  `Y := λf.(λx.(f (x x)) λx.(f (x x)))` 。你只要将自己要递归的函数替换掉里面 `f` 的位置，并最后执行一下这个匿名函数就成啦~\n\n## 折腾半天干什么\n\n你肯定想问，我们把一个循环写成这么复杂是为了什么。事实上我想展示的不是循环，而是递归。递归在图灵模型（我们通常 CPU 的计算模型）和丘奇模型（Lambda 演算）上都不是那么地原生的实现。\n\n在图灵模型上地最终形式是每次递归，追加进内存中，并重新 `goto` 回函数开始，在退出时，再一步步内存推出来，并将递归的剩余部分执行完。\n\n而在 Lambda 演算中，最终表达为一个\b逻辑系统构成的严格的数学函数模型的执行。\n\n这两者便是具体化和形式化的极限，充分表现了两种模型的特点。从根本加深了对两种模型差异的认知，从而让我们在两种模型上都能通过正确的编程思想来写代码，以把代码写得更好。\n\n当然也是有一些实际意义的，比如在变量作用域严格的语言中，且又必须使用匿名函数的形式来书写你所需要的东西的时候，而你正好又需要递归才能达到你的要求，那么使用 Y-Combinator 是一个可选的方法。然而通常，出现这种情况大多是你写了错误的思想的代码所导致的，实际编程中几乎遇不到这种情况，毕竟将更抽象更容易理解的函数式编程写成这么一坨一眼看不懂的代码是很失败的。\n\n","slug":"learn-y-combinator","published":1,"updated":"2016-04-21T16:34:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscy0099000upp8z9ytkhbq3","content":"<h2 id=\"写在开始\"><a href=\"#写在开始\" class=\"headerlink\" title=\"写在开始\"></a>写在开始</h2><p>不得不说，当我开始学习函数式编程的时候，我并没有被匿名函数感到害怕，理解它的基本概念是极其容易的。但是当你试图去将你日常所书写的指令式的代码转换成函数式，特别是纯函数式的时候，你会感到这是不可能的。它和你之前的编程思想是完全脱离的。</p>\n<p>所以当我第一次见到 Y-Combinator（Y 组合子）的时候，我的感觉是懵逼的，这是什么玩意。然而当我一步一步，了解这个东西是什么，它是怎么工作的之后，我对函数式编程的认识有了很大的进步。</p>\n<p>即使是 C++ 这样的语言，也在 C++11 标准中引入了匿名函数，使得你有机会在 C++ 中使用函数式编程的特性。在编程中，如果能适当地使用函数式语法进行编程，将非常有助于你写出一些更好理解、更简单的代码。</p>\n<p>而在了解一些基本概念之后，了解一下 Y-Combinator 是一个极好的选择，这个东西证明了函数式编程对递归的语义理解，证明了其在递归上和指令式编程的等价之处。你可以通过观察等价的这两者的不同的实现方式，来加深对这两者思想的认识。</p>\n<a id=\"more\"></a>\n<h2 id=\"与指令式编程的根本区别\"><a href=\"#与指令式编程的根本区别\" class=\"headerlink\" title=\"与指令式编程的根本区别\"></a>与指令式编程的根本区别</h2><p>大家看下面一段 C 代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">\"Hello World\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>显然这是一个非常常见的循环。然而这样的循环显然已经被抽象过了，我们也许可以用一个更原始的方法来实现。且让我引入一个 C 开发中应尽量避免的语句 <code>goto</code> 来解释。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">loop:</span><br><span class=\"line\"><span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">100</span>) <span class=\"keyword\">goto</span> next;</span><br><span class=\"line\"><span class=\"built_in\">puts</span>(<span class=\"string\">\"Hello World\"</span>);</span><br><span class=\"line\">i++;</span><br><span class=\"line\"><span class=\"keyword\">goto</span> loop;</span><br><span class=\"line\">next:</span><br></pre></td></tr></table></figure>\n<p>这两段代码除了变量 <code>i</code> 的作用域有所区别以外几乎是等价的。相对的，第二段代码非常接近于编译到汇编时的指令，几乎是一一映射的。然而你可以发现，我们的循环都是依赖于跳转代码行数的，不得不说这种写法非常不函数式。</p>\n<h2 id=\"第一个函数\"><a href=\"#第一个函数\" class=\"headerlink\" title=\"第一个函数\"></a>第一个函数</h2><p>我们可以用一个递归来把这个循环实现地更像一个函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">loop</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) return <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">\"Hello World\"</span>);</span><br><span class=\"line\">  return loop(n - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">loop(<span class=\"number\">100</span>);</span><br></pre></td></tr></table></figure>\n<p>虽然这个函数是倒过来循环的，但我们大可忽略这些细节，毕竟要做修改也是相对容易的。我们通过一个函数递归的方式来实现了一个循环。需要特别注意的是，如果根据递归的定义，那么这个循环一旦大起来在今天我们的计算机的计算模型（而不是 Lisp Machine）上是会爆栈的，但好在由于是个尾递归，通常是会直接被编译器优化成一个循环的。这确保了即使你写的是函数式代码，也可以最终编译成适合 CPU 运算的形式而不太影响性能。</p>\n<p>不过递归有一个问题，我们必须知道函数的名称才能这么做，在真正的 Lambda 运算模型上，函数是匿名的，也就是没有名字，这样你最后根本就无处调用你函数自己。因为你无法写出下面的代码（Ruby）：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lambda &#123; <span class=\"params\">|n|</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">if</span> n == <span class=\"number\">0</span></span><br><span class=\"line\">  puts <span class=\"string\">\"Hello World\"</span></span><br><span class=\"line\">  what_the_f**k_my_function_name_is(n-<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"魔法少女-Lambda-酱\"><a href=\"#魔法少女-Lambda-酱\" class=\"headerlink\" title=\"魔法少女 Lambda 酱\"></a>魔法少女 Lambda 酱</h2><p>下面我们演示一种黑魔法，来使得你没有办法得到自己函数名时实现递归。简单来说就是把「函数」当成一个「参数」传输。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loop = lambda &#123;<span class=\"params\">|f, n|</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">if</span> n == <span class=\"number\">0</span></span><br><span class=\"line\">  puts <span class=\"string\">\"Hello World\"</span></span><br><span class=\"line\">  f.call(n-<span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">loop.call(loop, <span class=\"number\">100</span>);</span><br></pre></td></tr></table></figure>\n<p>我们把函数本身作为一个参数传了进去，达到了我们的想法。不过这里我们还不是一个完全的匿名函数，而是通过给匿名函数起了一个名字 <code>loop</code>，在外面调用了一下。不过事到如今，去掉这个 <code>loop</code> 已经很容易了。由于第一条的匿名函数定义中没有任何地方用到 <code>loop</code> 只在第二条指令中用到。我们只要将第二条指令中的所有 <code>loop</code> 都代换掉就行。我们就能得到下面的代码：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lambda &#123;<span class=\"params\">|f, n|</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">if</span> n == <span class=\"number\">0</span></span><br><span class=\"line\">  puts <span class=\"string\">\"Hello World\"</span></span><br><span class=\"line\">  f.call(n-<span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;.call(lambda&#123;<span class=\"params\">|f, n|</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">if</span> n == <span class=\"number\">0</span></span><br><span class=\"line\">    puts <span class=\"string\">\"Hello World\"</span></span><br><span class=\"line\">    f.call(n-<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;, <span class=\"number\">100</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"柯里化，最后一步\"><a href=\"#柯里化，最后一步\" class=\"headerlink\" title=\"柯里化，最后一步\"></a>柯里化，最后一步</h2><p>Amazing！我们通过一个匿名函数的调用成功实现了一个 100 的循环。我们现在距离 Haskell Brooks Curry 先生当年推出 Y 组合子只差一步，那就是将我们做的事情「Currying」（柯里化）。所谓 Currying 就是使用一个高阶函数，将一个函数的多个参数精简成一个。我们看到我们现在的匿名函数还有 <code>f</code> 和 <code>n</code> 两个参数，我们打算拿掉它。虽然其实并不是真正意义上的拿掉。柯里化，只不过把一个形如 <code>f(x, y)</code> 的函数写成了 <code>f(x)(y)</code>，也就是 <code>f(x)</code> 的返回是一个匿名函数，而这个匿名函数再以 <code>y</code> 为参数执行一次。这么搞一下，我们就得到了：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lambda &#123;<span class=\"params\">|p|</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> lambda &#123; <span class=\"params\">|f|</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> f.call(f);</span><br><span class=\"line\">    &#125;.call(lambda &#123;<span class=\"params\">|f|</span> </span><br><span class=\"line\">      <span class=\"keyword\">return</span> p.call(lambda &#123;<span class=\"params\">|x|</span> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> f.call(f).call(x)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  &#125;.call(lambda &#123;<span class=\"params\">|f|</span> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> lambda &#123;<span class=\"params\">|i|</span> </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">if</span> i == <span class=\"number\">0</span>; </span><br><span class=\"line\">      f.call(i-<span class=\"number\">1</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;).call(<span class=\"number\">100</span>)</span><br></pre></td></tr></table></figure>\n<p>由于柯里化后匿名函数和调用的参数都单一了，我们因此可以保证我们能将任意一个递归都表达成一个匿名函数的形式。按照 Lambda 演算的形式化表达  <code>Y := λf.(λx.(f (x x)) λx.(f (x x)))</code> 。你只要将自己要递归的函数替换掉里面 <code>f</code> 的位置，并最后执行一下这个匿名函数就成啦~</p>\n<h2 id=\"折腾半天干什么\"><a href=\"#折腾半天干什么\" class=\"headerlink\" title=\"折腾半天干什么\"></a>折腾半天干什么</h2><p>你肯定想问，我们把一个循环写成这么复杂是为了什么。事实上我想展示的不是循环，而是递归。递归在图灵模型（我们通常 CPU 的计算模型）和丘奇模型（Lambda 演算）上都不是那么地原生的实现。</p>\n<p>在图灵模型上地最终形式是每次递归，追加进内存中，并重新 <code>goto</code> 回函数开始，在退出时，再一步步内存推出来，并将递归的剩余部分执行完。</p>\n<p>而在 Lambda 演算中，最终表达为一个\b逻辑系统构成的严格的数学函数模型的执行。</p>\n<p>这两者便是具体化和形式化的极限，充分表现了两种模型的特点。从根本加深了对两种模型差异的认知，从而让我们在两种模型上都能通过正确的编程思想来写代码，以把代码写得更好。</p>\n<p>当然也是有一些实际意义的，比如在变量作用域严格的语言中，且又必须使用匿名函数的形式来书写你所需要的东西的时候，而你正好又需要递归才能达到你的要求，那么使用 Y-Combinator 是一个可选的方法。然而通常，出现这种情况大多是你写了错误的思想的代码所导致的，实际编程中几乎遇不到这种情况，毕竟将更抽象更容易理解的函数式编程写成这么一坨一眼看不懂的代码是很失败的。</p>\n","excerpt":"<h2 id=\"写在开始\"><a href=\"#写在开始\" class=\"headerlink\" title=\"写在开始\"></a>写在开始</h2><p>不得不说，当我开始学习函数式编程的时候，我并没有被匿名函数感到害怕，理解它的基本概念是极其容易的。但是当你试图去将你日常所书写的指令式的代码转换成函数式，特别是纯函数式的时候，你会感到这是不可能的。它和你之前的编程思想是完全脱离的。</p>\n<p>所以当我第一次见到 Y-Combinator（Y 组合子）的时候，我的感觉是懵逼的，这是什么玩意。然而当我一步一步，了解这个东西是什么，它是怎么工作的之后，我对函数式编程的认识有了很大的进步。</p>\n<p>即使是 C++ 这样的语言，也在 C++11 标准中引入了匿名函数，使得你有机会在 C++ 中使用函数式编程的特性。在编程中，如果能适当地使用函数式语法进行编程，将非常有助于你写出一些更好理解、更简单的代码。</p>\n<p>而在了解一些基本概念之后，了解一下 Y-Combinator 是一个极好的选择，这个东西证明了函数式编程对递归的语义理解，证明了其在递归上和指令式编程的等价之处。你可以通过观察等价的这两者的不同的实现方式，来加深对这两者思想的认识。</p>","more":"<h2 id=\"与指令式编程的根本区别\"><a href=\"#与指令式编程的根本区别\" class=\"headerlink\" title=\"与指令式编程的根本区别\"></a>与指令式编程的根本区别</h2><p>大家看下面一段 C 代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">\"Hello World\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>显然这是一个非常常见的循环。然而这样的循环显然已经被抽象过了，我们也许可以用一个更原始的方法来实现。且让我引入一个 C 开发中应尽量避免的语句 <code>goto</code> 来解释。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">loop:</span><br><span class=\"line\"><span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">100</span>) <span class=\"keyword\">goto</span> next;</span><br><span class=\"line\"><span class=\"built_in\">puts</span>(<span class=\"string\">\"Hello World\"</span>);</span><br><span class=\"line\">i++;</span><br><span class=\"line\"><span class=\"keyword\">goto</span> loop;</span><br><span class=\"line\">next:</span><br></pre></td></tr></table></figure>\n<p>这两段代码除了变量 <code>i</code> 的作用域有所区别以外几乎是等价的。相对的，第二段代码非常接近于编译到汇编时的指令，几乎是一一映射的。然而你可以发现，我们的循环都是依赖于跳转代码行数的，不得不说这种写法非常不函数式。</p>\n<h2 id=\"第一个函数\"><a href=\"#第一个函数\" class=\"headerlink\" title=\"第一个函数\"></a>第一个函数</h2><p>我们可以用一个递归来把这个循环实现地更像一个函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">loop</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) return <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">\"Hello World\"</span>);</span><br><span class=\"line\">  return loop(n - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">loop(<span class=\"number\">100</span>);</span><br></pre></td></tr></table></figure>\n<p>虽然这个函数是倒过来循环的，但我们大可忽略这些细节，毕竟要做修改也是相对容易的。我们通过一个函数递归的方式来实现了一个循环。需要特别注意的是，如果根据递归的定义，那么这个循环一旦大起来在今天我们的计算机的计算模型（而不是 Lisp Machine）上是会爆栈的，但好在由于是个尾递归，通常是会直接被编译器优化成一个循环的。这确保了即使你写的是函数式代码，也可以最终编译成适合 CPU 运算的形式而不太影响性能。</p>\n<p>不过递归有一个问题，我们必须知道函数的名称才能这么做，在真正的 Lambda 运算模型上，函数是匿名的，也就是没有名字，这样你最后根本就无处调用你函数自己。因为你无法写出下面的代码（Ruby）：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lambda &#123; <span class=\"params\">|n|</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">if</span> n == <span class=\"number\">0</span></span><br><span class=\"line\">  puts <span class=\"string\">\"Hello World\"</span></span><br><span class=\"line\">  what_the_f**k_my_function_name_is(n-<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"魔法少女-Lambda-酱\"><a href=\"#魔法少女-Lambda-酱\" class=\"headerlink\" title=\"魔法少女 Lambda 酱\"></a>魔法少女 Lambda 酱</h2><p>下面我们演示一种黑魔法，来使得你没有办法得到自己函数名时实现递归。简单来说就是把「函数」当成一个「参数」传输。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loop = lambda &#123;<span class=\"params\">|f, n|</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">if</span> n == <span class=\"number\">0</span></span><br><span class=\"line\">  puts <span class=\"string\">\"Hello World\"</span></span><br><span class=\"line\">  f.call(n-<span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">loop.call(loop, <span class=\"number\">100</span>);</span><br></pre></td></tr></table></figure>\n<p>我们把函数本身作为一个参数传了进去，达到了我们的想法。不过这里我们还不是一个完全的匿名函数，而是通过给匿名函数起了一个名字 <code>loop</code>，在外面调用了一下。不过事到如今，去掉这个 <code>loop</code> 已经很容易了。由于第一条的匿名函数定义中没有任何地方用到 <code>loop</code> 只在第二条指令中用到。我们只要将第二条指令中的所有 <code>loop</code> 都代换掉就行。我们就能得到下面的代码：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lambda &#123;<span class=\"params\">|f, n|</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">if</span> n == <span class=\"number\">0</span></span><br><span class=\"line\">  puts <span class=\"string\">\"Hello World\"</span></span><br><span class=\"line\">  f.call(n-<span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;.call(lambda&#123;<span class=\"params\">|f, n|</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">if</span> n == <span class=\"number\">0</span></span><br><span class=\"line\">    puts <span class=\"string\">\"Hello World\"</span></span><br><span class=\"line\">    f.call(n-<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;, <span class=\"number\">100</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"柯里化，最后一步\"><a href=\"#柯里化，最后一步\" class=\"headerlink\" title=\"柯里化，最后一步\"></a>柯里化，最后一步</h2><p>Amazing！我们通过一个匿名函数的调用成功实现了一个 100 的循环。我们现在距离 Haskell Brooks Curry 先生当年推出 Y 组合子只差一步，那就是将我们做的事情「Currying」（柯里化）。所谓 Currying 就是使用一个高阶函数，将一个函数的多个参数精简成一个。我们看到我们现在的匿名函数还有 <code>f</code> 和 <code>n</code> 两个参数，我们打算拿掉它。虽然其实并不是真正意义上的拿掉。柯里化，只不过把一个形如 <code>f(x, y)</code> 的函数写成了 <code>f(x)(y)</code>，也就是 <code>f(x)</code> 的返回是一个匿名函数，而这个匿名函数再以 <code>y</code> 为参数执行一次。这么搞一下，我们就得到了：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lambda &#123;<span class=\"params\">|p|</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> lambda &#123; <span class=\"params\">|f|</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> f.call(f);</span><br><span class=\"line\">    &#125;.call(lambda &#123;<span class=\"params\">|f|</span> </span><br><span class=\"line\">      <span class=\"keyword\">return</span> p.call(lambda &#123;<span class=\"params\">|x|</span> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> f.call(f).call(x)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  &#125;.call(lambda &#123;<span class=\"params\">|f|</span> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> lambda &#123;<span class=\"params\">|i|</span> </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">if</span> i == <span class=\"number\">0</span>; </span><br><span class=\"line\">      f.call(i-<span class=\"number\">1</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;).call(<span class=\"number\">100</span>)</span><br></pre></td></tr></table></figure>\n<p>由于柯里化后匿名函数和调用的参数都单一了，我们因此可以保证我们能将任意一个递归都表达成一个匿名函数的形式。按照 Lambda 演算的形式化表达  <code>Y := λf.(λx.(f (x x)) λx.(f (x x)))</code> 。你只要将自己要递归的函数替换掉里面 <code>f</code> 的位置，并最后执行一下这个匿名函数就成啦~</p>\n<h2 id=\"折腾半天干什么\"><a href=\"#折腾半天干什么\" class=\"headerlink\" title=\"折腾半天干什么\"></a>折腾半天干什么</h2><p>你肯定想问，我们把一个循环写成这么复杂是为了什么。事实上我想展示的不是循环，而是递归。递归在图灵模型（我们通常 CPU 的计算模型）和丘奇模型（Lambda 演算）上都不是那么地原生的实现。</p>\n<p>在图灵模型上地最终形式是每次递归，追加进内存中，并重新 <code>goto</code> 回函数开始，在退出时，再一步步内存推出来，并将递归的剩余部分执行完。</p>\n<p>而在 Lambda 演算中，最终表达为一个\b逻辑系统构成的严格的数学函数模型的执行。</p>\n<p>这两者便是具体化和形式化的极限，充分表现了两种模型的特点。从根本加深了对两种模型差异的认知，从而让我们在两种模型上都能通过正确的编程思想来写代码，以把代码写得更好。</p>\n<p>当然也是有一些实际意义的，比如在变量作用域严格的语言中，且又必须使用匿名函数的形式来书写你所需要的东西的时候，而你正好又需要递归才能达到你的要求，那么使用 Y-Combinator 是一个可选的方法。然而通常，出现这种情况大多是你写了错误的思想的代码所导致的，实际编程中几乎遇不到这种情况，毕竟将更抽象更容易理解的函数式编程写成这么一坨一眼看不懂的代码是很失败的。</p>"},{"title":"当今计算机教学的普遍问题","date":"2016-04-23T17:10:44.000Z","_content":"\n 今天的计算机行业，特别是互联网行业，又一次成为了人人谈论的朝阳产业，越来越多的人希望加入到这个行业里。但是，不得不指出的是，计算机科学，作为一门工程与科学相结合的学科，并没有任何捷径可走。任何人，如果想在这个行业中哪怕是进入一个平均水平，也需要系统地进行学习。\n\n越来越多的人渴望得到计算机科学上的教学，但同时，计算机行业又在以一个非常快速的方式在发展和进步着。每年、每个月甚至是每天，都能见到一些令人兴奋的新特性、新技术的产生。不得不说，今天的计算机教学，很大程度上，与计算机行业的发展已经拖了钩。任何一门课程、教科书都无法及时跟上最新技术发展的脚步，成为了新人进入行业很大的阻碍。\n\n<!--more-->\n\n如果一位老师，从事计算机教学，却不从事实际的开发工作，那么他的技术栈也将很快落后于行业。这意味着，我们无法像过去那样，通过专业的「师范」教学，培养优秀的计算机科学教师。落后的教学内容很可能是「无用的」或者用处「极少的」，因为他们通常会在一些已经被解决的问题上浪费太多的时间。而更要命的是一些教学不只是「无用的」，甚至可能是「有害的」。\n\n从标准被制定到采纳并应用于某项技术中需要多久？在今天社区协同的环境下，这些事情的发生有时只要几天。当一项实用的新技术被加入进来后，到教科书的再版需要多久？从再版到教师去学会了这些内容，并能将其教授给学生需要多久？如果这时间花费很长，那么很可能就会教出很多无用的内容。然而相反，从标准被废除到采纳并应用于某项技术中需要多久？废除后能写进教科书再版需要多久？而教师学会并能教授又需要多久？如果这个步骤时间很长，那么，教授的内容就更是「有害的」了。\n\n更何况，人非圣贤孰能无过。编写教科书的人以及教师的编程经历本身都会影响其对技术的理解。几乎每个老师都难免在教授过程中出现错误。BASIC 出身的谭浩强老师的《C 语言程序设计》整本书仿佛都写着「错误」两字，却依然能走进我国大多数的大学课堂。这样的例子数不胜数，我们无法估量这背后的影响有多大。\n\n**落后、无用、有害，能够从根本上被改变吗？**\n\n如果要回答如何缩短技术的更新到教科书更新的时间，我们不妨先问这样一个问题：为什么互联网技术更新如此迅速呢？其答案是互联网技术本身。基于互联网、社区的协同办公，使得一项技术得到社区的普遍认同变得前所未有的迅速。然而教科书在今天，依然还是依赖于传统的编写、审稿、出版的步骤。为什么我们不能依赖互联网技术本身、依赖社区，来编写教科书呢？\n\n这样操作甚至能带来一个连带的作用，那就是，利用社区的力量来减少教科书中出现错误的可能性。谭浩强老师的《C 语言程序设计》整本书仿佛都写着「错误」两字，但正是由于广泛的使用，几乎每个错误你都能在网上找到。但如果社区从编写教科书时就参与，是不是错误能从教科书中就被直接删除呢？\n\n今天，长期关注于计算机教学领域的 HeckPsi 将启动全新的实验性项目[「HeckPsi Education」/「HeckPsi 公开课」](http://edu.heckpsi.com) —— 一个依赖于社区进行的免费、开源、实时的教科书计划。一个社区中的每个人都能参与新建、更新、修正教科书的计划，它让教学变得前所未有地与时俱进。而 HeckPsi 从中扮演的角色，仅限于审核的工作。在未来数日内，HeckPsi 将逐步公开社区参与的具体流程，我们希望这次试验能使得计算机科学的教学迈上真正的计算机时代。\n\n\n\n","source":"_posts/problems-of-it-textbooks-now.md","raw":"---\ntitle: 当今计算机教学的普遍问题\ndate: 2016-04-24 01:10:44\ntags: [站务]\n---\n\n 今天的计算机行业，特别是互联网行业，又一次成为了人人谈论的朝阳产业，越来越多的人希望加入到这个行业里。但是，不得不指出的是，计算机科学，作为一门工程与科学相结合的学科，并没有任何捷径可走。任何人，如果想在这个行业中哪怕是进入一个平均水平，也需要系统地进行学习。\n\n越来越多的人渴望得到计算机科学上的教学，但同时，计算机行业又在以一个非常快速的方式在发展和进步着。每年、每个月甚至是每天，都能见到一些令人兴奋的新特性、新技术的产生。不得不说，今天的计算机教学，很大程度上，与计算机行业的发展已经拖了钩。任何一门课程、教科书都无法及时跟上最新技术发展的脚步，成为了新人进入行业很大的阻碍。\n\n<!--more-->\n\n如果一位老师，从事计算机教学，却不从事实际的开发工作，那么他的技术栈也将很快落后于行业。这意味着，我们无法像过去那样，通过专业的「师范」教学，培养优秀的计算机科学教师。落后的教学内容很可能是「无用的」或者用处「极少的」，因为他们通常会在一些已经被解决的问题上浪费太多的时间。而更要命的是一些教学不只是「无用的」，甚至可能是「有害的」。\n\n从标准被制定到采纳并应用于某项技术中需要多久？在今天社区协同的环境下，这些事情的发生有时只要几天。当一项实用的新技术被加入进来后，到教科书的再版需要多久？从再版到教师去学会了这些内容，并能将其教授给学生需要多久？如果这时间花费很长，那么很可能就会教出很多无用的内容。然而相反，从标准被废除到采纳并应用于某项技术中需要多久？废除后能写进教科书再版需要多久？而教师学会并能教授又需要多久？如果这个步骤时间很长，那么，教授的内容就更是「有害的」了。\n\n更何况，人非圣贤孰能无过。编写教科书的人以及教师的编程经历本身都会影响其对技术的理解。几乎每个老师都难免在教授过程中出现错误。BASIC 出身的谭浩强老师的《C 语言程序设计》整本书仿佛都写着「错误」两字，却依然能走进我国大多数的大学课堂。这样的例子数不胜数，我们无法估量这背后的影响有多大。\n\n**落后、无用、有害，能够从根本上被改变吗？**\n\n如果要回答如何缩短技术的更新到教科书更新的时间，我们不妨先问这样一个问题：为什么互联网技术更新如此迅速呢？其答案是互联网技术本身。基于互联网、社区的协同办公，使得一项技术得到社区的普遍认同变得前所未有的迅速。然而教科书在今天，依然还是依赖于传统的编写、审稿、出版的步骤。为什么我们不能依赖互联网技术本身、依赖社区，来编写教科书呢？\n\n这样操作甚至能带来一个连带的作用，那就是，利用社区的力量来减少教科书中出现错误的可能性。谭浩强老师的《C 语言程序设计》整本书仿佛都写着「错误」两字，但正是由于广泛的使用，几乎每个错误你都能在网上找到。但如果社区从编写教科书时就参与，是不是错误能从教科书中就被直接删除呢？\n\n今天，长期关注于计算机教学领域的 HeckPsi 将启动全新的实验性项目[「HeckPsi Education」/「HeckPsi 公开课」](http://edu.heckpsi.com) —— 一个依赖于社区进行的免费、开源、实时的教科书计划。一个社区中的每个人都能参与新建、更新、修正教科书的计划，它让教学变得前所未有地与时俱进。而 HeckPsi 从中扮演的角色，仅限于审核的工作。在未来数日内，HeckPsi 将逐步公开社区参与的具体流程，我们希望这次试验能使得计算机科学的教学迈上真正的计算机时代。\n\n\n\n","slug":"problems-of-it-textbooks-now","published":1,"updated":"2016-04-23T17:53:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscy009c000wpp8zwv5yyfgs","content":"<p> 今天的计算机行业，特别是互联网行业，又一次成为了人人谈论的朝阳产业，越来越多的人希望加入到这个行业里。但是，不得不指出的是，计算机科学，作为一门工程与科学相结合的学科，并没有任何捷径可走。任何人，如果想在这个行业中哪怕是进入一个平均水平，也需要系统地进行学习。</p>\n<p>越来越多的人渴望得到计算机科学上的教学，但同时，计算机行业又在以一个非常快速的方式在发展和进步着。每年、每个月甚至是每天，都能见到一些令人兴奋的新特性、新技术的产生。不得不说，今天的计算机教学，很大程度上，与计算机行业的发展已经拖了钩。任何一门课程、教科书都无法及时跟上最新技术发展的脚步，成为了新人进入行业很大的阻碍。</p>\n<a id=\"more\"></a>\n<p>如果一位老师，从事计算机教学，却不从事实际的开发工作，那么他的技术栈也将很快落后于行业。这意味着，我们无法像过去那样，通过专业的「师范」教学，培养优秀的计算机科学教师。落后的教学内容很可能是「无用的」或者用处「极少的」，因为他们通常会在一些已经被解决的问题上浪费太多的时间。而更要命的是一些教学不只是「无用的」，甚至可能是「有害的」。</p>\n<p>从标准被制定到采纳并应用于某项技术中需要多久？在今天社区协同的环境下，这些事情的发生有时只要几天。当一项实用的新技术被加入进来后，到教科书的再版需要多久？从再版到教师去学会了这些内容，并能将其教授给学生需要多久？如果这时间花费很长，那么很可能就会教出很多无用的内容。然而相反，从标准被废除到采纳并应用于某项技术中需要多久？废除后能写进教科书再版需要多久？而教师学会并能教授又需要多久？如果这个步骤时间很长，那么，教授的内容就更是「有害的」了。</p>\n<p>更何况，人非圣贤孰能无过。编写教科书的人以及教师的编程经历本身都会影响其对技术的理解。几乎每个老师都难免在教授过程中出现错误。BASIC 出身的谭浩强老师的《C 语言程序设计》整本书仿佛都写着「错误」两字，却依然能走进我国大多数的大学课堂。这样的例子数不胜数，我们无法估量这背后的影响有多大。</p>\n<p><strong>落后、无用、有害，能够从根本上被改变吗？</strong></p>\n<p>如果要回答如何缩短技术的更新到教科书更新的时间，我们不妨先问这样一个问题：为什么互联网技术更新如此迅速呢？其答案是互联网技术本身。基于互联网、社区的协同办公，使得一项技术得到社区的普遍认同变得前所未有的迅速。然而教科书在今天，依然还是依赖于传统的编写、审稿、出版的步骤。为什么我们不能依赖互联网技术本身、依赖社区，来编写教科书呢？</p>\n<p>这样操作甚至能带来一个连带的作用，那就是，利用社区的力量来减少教科书中出现错误的可能性。谭浩强老师的《C 语言程序设计》整本书仿佛都写着「错误」两字，但正是由于广泛的使用，几乎每个错误你都能在网上找到。但如果社区从编写教科书时就参与，是不是错误能从教科书中就被直接删除呢？</p>\n<p>今天，长期关注于计算机教学领域的 HeckPsi 将启动全新的实验性项目<a href=\"http://edu.heckpsi.com\" target=\"_blank\" rel=\"external\">「HeckPsi Education」/「HeckPsi 公开课」</a> —— 一个依赖于社区进行的免费、开源、实时的教科书计划。一个社区中的每个人都能参与新建、更新、修正教科书的计划，它让教学变得前所未有地与时俱进。而 HeckPsi 从中扮演的角色，仅限于审核的工作。在未来数日内，HeckPsi 将逐步公开社区参与的具体流程，我们希望这次试验能使得计算机科学的教学迈上真正的计算机时代。</p>\n","excerpt":"<p> 今天的计算机行业，特别是互联网行业，又一次成为了人人谈论的朝阳产业，越来越多的人希望加入到这个行业里。但是，不得不指出的是，计算机科学，作为一门工程与科学相结合的学科，并没有任何捷径可走。任何人，如果想在这个行业中哪怕是进入一个平均水平，也需要系统地进行学习。</p>\n<p>越来越多的人渴望得到计算机科学上的教学，但同时，计算机行业又在以一个非常快速的方式在发展和进步着。每年、每个月甚至是每天，都能见到一些令人兴奋的新特性、新技术的产生。不得不说，今天的计算机教学，很大程度上，与计算机行业的发展已经拖了钩。任何一门课程、教科书都无法及时跟上最新技术发展的脚步，成为了新人进入行业很大的阻碍。</p>","more":"<p>如果一位老师，从事计算机教学，却不从事实际的开发工作，那么他的技术栈也将很快落后于行业。这意味着，我们无法像过去那样，通过专业的「师范」教学，培养优秀的计算机科学教师。落后的教学内容很可能是「无用的」或者用处「极少的」，因为他们通常会在一些已经被解决的问题上浪费太多的时间。而更要命的是一些教学不只是「无用的」，甚至可能是「有害的」。</p>\n<p>从标准被制定到采纳并应用于某项技术中需要多久？在今天社区协同的环境下，这些事情的发生有时只要几天。当一项实用的新技术被加入进来后，到教科书的再版需要多久？从再版到教师去学会了这些内容，并能将其教授给学生需要多久？如果这时间花费很长，那么很可能就会教出很多无用的内容。然而相反，从标准被废除到采纳并应用于某项技术中需要多久？废除后能写进教科书再版需要多久？而教师学会并能教授又需要多久？如果这个步骤时间很长，那么，教授的内容就更是「有害的」了。</p>\n<p>更何况，人非圣贤孰能无过。编写教科书的人以及教师的编程经历本身都会影响其对技术的理解。几乎每个老师都难免在教授过程中出现错误。BASIC 出身的谭浩强老师的《C 语言程序设计》整本书仿佛都写着「错误」两字，却依然能走进我国大多数的大学课堂。这样的例子数不胜数，我们无法估量这背后的影响有多大。</p>\n<p><strong>落后、无用、有害，能够从根本上被改变吗？</strong></p>\n<p>如果要回答如何缩短技术的更新到教科书更新的时间，我们不妨先问这样一个问题：为什么互联网技术更新如此迅速呢？其答案是互联网技术本身。基于互联网、社区的协同办公，使得一项技术得到社区的普遍认同变得前所未有的迅速。然而教科书在今天，依然还是依赖于传统的编写、审稿、出版的步骤。为什么我们不能依赖互联网技术本身、依赖社区，来编写教科书呢？</p>\n<p>这样操作甚至能带来一个连带的作用，那就是，利用社区的力量来减少教科书中出现错误的可能性。谭浩强老师的《C 语言程序设计》整本书仿佛都写着「错误」两字，但正是由于广泛的使用，几乎每个错误你都能在网上找到。但如果社区从编写教科书时就参与，是不是错误能从教科书中就被直接删除呢？</p>\n<p>今天，长期关注于计算机教学领域的 HeckPsi 将启动全新的实验性项目<a href=\"http://edu.heckpsi.com\">「HeckPsi Education」/「HeckPsi 公开课」</a> —— 一个依赖于社区进行的免费、开源、实时的教科书计划。一个社区中的每个人都能参与新建、更新、修正教科书的计划，它让教学变得前所未有地与时俱进。而 HeckPsi 从中扮演的角色，仅限于审核的工作。在未来数日内，HeckPsi 将逐步公开社区参与的具体流程，我们希望这次试验能使得计算机科学的教学迈上真正的计算机时代。</p>"},{"title":"Project Genji 全栈工程师培养计划","date":"2016-08-15T00:53:32.000Z","_content":"\n### Project Genji 是什么？\n\n**我们可以改变世界，在了解世界的现行法则之后。**\n\n### \n\n### Project Genji 的具体计划？\n\n具体课程安排如下（暂定，时间不包含作业）\n\n- 路人码农的养成方法（开发的基本哲学，2 小时）\n- 可爱标记魔法（JSON XML HTML 与 Markdown 入门，4 小时）\n- 关于完全听不懂 JavaScript 在说什么的故事（前端 JavaScript 入门）\n  - JavaScript 的基础使用（4 小时）\n  - JavaScript 在网站开发中的使用（4 小时）\n- Re: 从零开始的函数式编程（2 小时）\n- 魔法少女 Ruby\n  - Ruby 的基础使用（8 小时）\n  - 后端开发与网络通讯的基本原理（4 小时）\n  - Sinatra 的魔法（4 小时）\n- 中二病也要写后端（横向比较各语言后端常见框架，2 小时）\n- 这个博客大有问题！\n  - 数据库的分类和 SQLite 的基本用法（3 小时）\n  - 写一个博客（2 小时）\n  - 合适的抽象（面向对象，2 小时）\n  - 基于静态生成的博客设计（2 小时）\n\n\n- 请问您今天要来点 APP 吗？\n  - API 与客户端设计（2 小时）\n  - Java 与 Android 基础（6 小时）\n  - 写一个 Android 博客客户端（6 小时）\n  - Swift 与 iOS 基础（6 小时）\n  - 用 Swift 来写一个 iOS 博客客户端（6 小时）\n  - .net 与 Windows 开发基础（6 小时）\n  - 用 C# 来写一个 Windows 博客客户端（6 小时）\n  - 一切钦定的与不钦定的 SDK（其他开发 SDK 的横向对比，2 小时）\n- 网站的彼方（基于 API 的 WebApp 开发）\n  - React 入门（4 小时）\n  - Vue 入门（2 小时）\n  - 写一个基于 API 开发的博客应用（5 小时）\n- 我的应用安全物语果然有问题（4 小时）\n- 超级\u000f嵌套字\n  - 了解 Linux 网络编程（2 小时）\n  - C 语言入门（8 小时）\n  - 用 C 写一个简易后端（6 小时）\n- 没有性能存在的无聊世界（4 小时）\n\n\n\n### Project Genji 的参与费用？\n\n免费。\n\n### 如何报名 Project Genji？\n\n\n\n### 其他细节\n\n","source":"_posts/project-genji.md","raw":"---\ntitle: Project Genji 全栈工程师培养计划\ndate: 2016-08-15 08:53:32\ntags: [HeckPsi,Genji]\n---\n\n### Project Genji 是什么？\n\n**我们可以改变世界，在了解世界的现行法则之后。**\n\n### \n\n### Project Genji 的具体计划？\n\n具体课程安排如下（暂定，时间不包含作业）\n\n- 路人码农的养成方法（开发的基本哲学，2 小时）\n- 可爱标记魔法（JSON XML HTML 与 Markdown 入门，4 小时）\n- 关于完全听不懂 JavaScript 在说什么的故事（前端 JavaScript 入门）\n  - JavaScript 的基础使用（4 小时）\n  - JavaScript 在网站开发中的使用（4 小时）\n- Re: 从零开始的函数式编程（2 小时）\n- 魔法少女 Ruby\n  - Ruby 的基础使用（8 小时）\n  - 后端开发与网络通讯的基本原理（4 小时）\n  - Sinatra 的魔法（4 小时）\n- 中二病也要写后端（横向比较各语言后端常见框架，2 小时）\n- 这个博客大有问题！\n  - 数据库的分类和 SQLite 的基本用法（3 小时）\n  - 写一个博客（2 小时）\n  - 合适的抽象（面向对象，2 小时）\n  - 基于静态生成的博客设计（2 小时）\n\n\n- 请问您今天要来点 APP 吗？\n  - API 与客户端设计（2 小时）\n  - Java 与 Android 基础（6 小时）\n  - 写一个 Android 博客客户端（6 小时）\n  - Swift 与 iOS 基础（6 小时）\n  - 用 Swift 来写一个 iOS 博客客户端（6 小时）\n  - .net 与 Windows 开发基础（6 小时）\n  - 用 C# 来写一个 Windows 博客客户端（6 小时）\n  - 一切钦定的与不钦定的 SDK（其他开发 SDK 的横向对比，2 小时）\n- 网站的彼方（基于 API 的 WebApp 开发）\n  - React 入门（4 小时）\n  - Vue 入门（2 小时）\n  - 写一个基于 API 开发的博客应用（5 小时）\n- 我的应用安全物语果然有问题（4 小时）\n- 超级\u000f嵌套字\n  - 了解 Linux 网络编程（2 小时）\n  - C 语言入门（8 小时）\n  - 用 C 写一个简易后端（6 小时）\n- 没有性能存在的无聊世界（4 小时）\n\n\n\n### Project Genji 的参与费用？\n\n免费。\n\n### 如何报名 Project Genji？\n\n\n\n### 其他细节\n\n","slug":"project-genji","published":1,"updated":"2016-08-16T09:48:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscy009d000zpp8zxdhngwep","content":"<h3 id=\"Project-Genji-是什么？\"><a href=\"#Project-Genji-是什么？\" class=\"headerlink\" title=\"Project Genji 是什么？\"></a>Project Genji 是什么？</h3><p><strong>我们可以改变世界，在了解世界的现行法则之后。</strong></p>\n<p>### </p>\n<h3 id=\"Project-Genji-的具体计划？\"><a href=\"#Project-Genji-的具体计划？\" class=\"headerlink\" title=\"Project Genji 的具体计划？\"></a>Project Genji 的具体计划？</h3><p>具体课程安排如下（暂定，时间不包含作业）</p>\n<ul>\n<li>路人码农的养成方法（开发的基本哲学，2 小时）</li>\n<li>可爱标记魔法（JSON XML HTML 与 Markdown 入门，4 小时）</li>\n<li>关于完全听不懂 JavaScript 在说什么的故事（前端 JavaScript 入门）<ul>\n<li>JavaScript 的基础使用（4 小时）</li>\n<li>JavaScript 在网站开发中的使用（4 小时）</li>\n</ul>\n</li>\n<li>Re: 从零开始的函数式编程（2 小时）</li>\n<li>魔法少女 Ruby<ul>\n<li>Ruby 的基础使用（8 小时）</li>\n<li>后端开发与网络通讯的基本原理（4 小时）</li>\n<li>Sinatra 的魔法（4 小时）</li>\n</ul>\n</li>\n<li>中二病也要写后端（横向比较各语言后端常见框架，2 小时）</li>\n<li>这个博客大有问题！<ul>\n<li>数据库的分类和 SQLite 的基本用法（3 小时）</li>\n<li>写一个博客（2 小时）</li>\n<li>合适的抽象（面向对象，2 小时）</li>\n<li>基于静态生成的博客设计（2 小时）</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>请问您今天要来点 APP 吗？<ul>\n<li>API 与客户端设计（2 小时）</li>\n<li>Java 与 Android 基础（6 小时）</li>\n<li>写一个 Android 博客客户端（6 小时）</li>\n<li>Swift 与 iOS 基础（6 小时）</li>\n<li>用 Swift 来写一个 iOS 博客客户端（6 小时）</li>\n<li>.net 与 Windows 开发基础（6 小时）</li>\n<li>用 C# 来写一个 Windows 博客客户端（6 小时）</li>\n<li>一切钦定的与不钦定的 SDK（其他开发 SDK 的横向对比，2 小时）</li>\n</ul>\n</li>\n<li>网站的彼方（基于 API 的 WebApp 开发）<ul>\n<li>React 入门（4 小时）</li>\n<li>Vue 入门（2 小时）</li>\n<li>写一个基于 API 开发的博客应用（5 小时）</li>\n</ul>\n</li>\n<li>我的应用安全物语果然有问题（4 小时）</li>\n<li>超级\u000f嵌套字<ul>\n<li>了解 Linux 网络编程（2 小时）</li>\n<li>C 语言入门（8 小时）</li>\n<li>用 C 写一个简易后端（6 小时）</li>\n</ul>\n</li>\n<li>没有性能存在的无聊世界（4 小时）</li>\n</ul>\n<h3 id=\"Project-Genji-的参与费用？\"><a href=\"#Project-Genji-的参与费用？\" class=\"headerlink\" title=\"Project Genji 的参与费用？\"></a>Project Genji 的参与费用？</h3><p>免费。</p>\n<h3 id=\"如何报名-Project-Genji？\"><a href=\"#如何报名-Project-Genji？\" class=\"headerlink\" title=\"如何报名 Project Genji？\"></a>如何报名 Project Genji？</h3><h3 id=\"其他细节\"><a href=\"#其他细节\" class=\"headerlink\" title=\"其他细节\"></a>其他细节</h3>","excerpt":"","more":"<h3 id=\"Project-Genji-是什么？\"><a href=\"#Project-Genji-是什么？\" class=\"headerlink\" title=\"Project Genji 是什么？\"></a>Project Genji 是什么？</h3><p><strong>我们可以改变世界，在了解世界的现行法则之后。</strong></p>\n<p>### </p>\n<h3 id=\"Project-Genji-的具体计划？\"><a href=\"#Project-Genji-的具体计划？\" class=\"headerlink\" title=\"Project Genji 的具体计划？\"></a>Project Genji 的具体计划？</h3><p>具体课程安排如下（暂定，时间不包含作业）</p>\n<ul>\n<li>路人码农的养成方法（开发的基本哲学，2 小时）</li>\n<li>可爱标记魔法（JSON XML HTML 与 Markdown 入门，4 小时）</li>\n<li>关于完全听不懂 JavaScript 在说什么的故事（前端 JavaScript 入门）<ul>\n<li>JavaScript 的基础使用（4 小时）</li>\n<li>JavaScript 在网站开发中的使用（4 小时）</li>\n</ul>\n</li>\n<li>Re: 从零开始的函数式编程（2 小时）</li>\n<li>魔法少女 Ruby<ul>\n<li>Ruby 的基础使用（8 小时）</li>\n<li>后端开发与网络通讯的基本原理（4 小时）</li>\n<li>Sinatra 的魔法（4 小时）</li>\n</ul>\n</li>\n<li>中二病也要写后端（横向比较各语言后端常见框架，2 小时）</li>\n<li>这个博客大有问题！<ul>\n<li>数据库的分类和 SQLite 的基本用法（3 小时）</li>\n<li>写一个博客（2 小时）</li>\n<li>合适的抽象（面向对象，2 小时）</li>\n<li>基于静态生成的博客设计（2 小时）</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>请问您今天要来点 APP 吗？<ul>\n<li>API 与客户端设计（2 小时）</li>\n<li>Java 与 Android 基础（6 小时）</li>\n<li>写一个 Android 博客客户端（6 小时）</li>\n<li>Swift 与 iOS 基础（6 小时）</li>\n<li>用 Swift 来写一个 iOS 博客客户端（6 小时）</li>\n<li>.net 与 Windows 开发基础（6 小时）</li>\n<li>用 C# 来写一个 Windows 博客客户端（6 小时）</li>\n<li>一切钦定的与不钦定的 SDK（其他开发 SDK 的横向对比，2 小时）</li>\n</ul>\n</li>\n<li>网站的彼方（基于 API 的 WebApp 开发）<ul>\n<li>React 入门（4 小时）</li>\n<li>Vue 入门（2 小时）</li>\n<li>写一个基于 API 开发的博客应用（5 小时）</li>\n</ul>\n</li>\n<li>我的应用安全物语果然有问题（4 小时）</li>\n<li>超级\u000f嵌套字<ul>\n<li>了解 Linux 网络编程（2 小时）</li>\n<li>C 语言入门（8 小时）</li>\n<li>用 C 写一个简易后端（6 小时）</li>\n</ul>\n</li>\n<li>没有性能存在的无聊世界（4 小时）</li>\n</ul>\n<h3 id=\"Project-Genji-的参与费用？\"><a href=\"#Project-Genji-的参与费用？\" class=\"headerlink\" title=\"Project Genji 的参与费用？\"></a>Project Genji 的参与费用？</h3><p>免费。</p>\n<h3 id=\"如何报名-Project-Genji？\"><a href=\"#如何报名-Project-Genji？\" class=\"headerlink\" title=\"如何报名 Project Genji？\"></a>如何报名 Project Genji？</h3><h3 id=\"其他细节\"><a href=\"#其他细节\" class=\"headerlink\" title=\"其他细节\"></a>其他细节</h3>"},{"title":"从零开始 Ruby on PHP","date":"2016-06-10T22:54:40.000Z","_content":"\n### 关于什叶派 PHP 教徒\nPHP 早期的设计意图下整个语言都是模板驱动的。也就是说主要就是写个静态页面，在适当的需要动态的场合插入一些短小的 CGI 代码。然而逊尼派 PHP 教徒确认为 PHP 可以变成一门大而全的语言，摇身一变，强行又是 MVC 又是 MVC 的。各种框架层出不穷，抄完 Spring 又抄 Rails，甚至在一门模板驱动的语言中再搞一个模板渲染引擎。简直是异教。\n\n### Ruby on PHP\n考虑到 Ruby 是一门强大的支持元编程的语言。很容易地我们能够将 Ruby 写成一门以模板来驱动的 CGI 语言。通过几行代码\n\n<!--more-->\n\n```ruby\nrequire 'sinatra'\n\nget '/' do\n  redirect '/index.php'\nend\n\nget /^\\/(.*?)\\.php$/ do |c|\n  erb c.to_sym\nend\n\npost /^\\/(.*?)\\.php$/ do |c|\n  erb c.to_sym\nend\n```\n这样，只需要在 `./view` 下创建 erb 文件就可以当做 php 来写了，甚至连子目录都可以。\n当然这样有一些小问题，比如，传进 erb 后连 request 来什么请求都不知道了。\n所以我们可以稍作修改。\n```ruby\nrequire 'sinatra'\n\nget '/' do\n  redirect '/index.php'\nend\n\nget /^\\/(.*?)\\.php$/ do |c|\n  erb c.to_sym, locals: {request: request}\nend\n\npost /^\\/(.*?)\\.php$/ do |c|\n  erb c.to_sym, locals: {request: request}\nend\n```\n这样我们就有了一切 request 的数据了。自己在里面继续二次处理就是了。\n\n### 模板渲染\nerb 模板是有趣的，但是像 PHP 那样一次性插十几行代码就不是很方便了。其实 erb 里也有这样的方法，只是 deprecated 而已。\n```erb\n<body>\n  <%\n    puts 'foo'\n    puts 'bar'\n  %>\n</body>\n```\n然而问题来了，erb 里并不支持 echo 那样的命令。这样我们没法在一坨 Ruby 代码中输出某个东西到网页。\n但是，Rails 里的 ActionView 不是支持 concat 吗？那么我们稍稍用点元编程的技巧，支持一下 echo 咯。\n所以我们得到了最终代码\n```ruby\n# This is yet another PHP project\nrequire 'sinatra'\nrequire 'action_view'\n\nlookup_context = ActionView::LookupContext.new('./views')\nlookup_context.cache = false if development?\nview_context = ActionView::Base.new(lookup_context)\n\nmodule ActionView::Helpers::TextHelper\n  def echo(string)\n    output_buffer << string\n  end\nend\n\nget '/' do\n  redirect '/index.php'\nend\n\nget /^\\/(.*?)\\.php$/ do |c|\n  view_context.render(file: c, locals: {request: request})\nend\n\npost /^\\/(.*?)\\.php$/ do |c|\n  view_context.render(file: c, locals: {request: request})\nend\n```\n我们也能在 erb 里愉快地 echo 了\n```erb\n<html>\n  <body>\n    Proudly Powered By \n    <br>\n  <%\n    echo 'PHP'\n  %>\n  </body>\n</html>\n```\n\n### 副作用\n根据上面的做法，我们把 Ruby 变成了一门什叶派 PHP 心目中 PHP 本该有的样子了。\n顺便还带来了一点副作用那就是，Wappalyzer 把这个项目完全当做 PHP 项目了。\n假如黑客试图用 PHP 的漏洞来攻击你，就等着看好戏吧。诶嘿~\n\n","source":"_posts/ruby-on-php-abc.md","raw":"---\ntitle: 从零开始 Ruby on PHP\ndate: 2016-06-11 06:54:40\ntags: [Ruby, PHP]\n---\n\n### 关于什叶派 PHP 教徒\nPHP 早期的设计意图下整个语言都是模板驱动的。也就是说主要就是写个静态页面，在适当的需要动态的场合插入一些短小的 CGI 代码。然而逊尼派 PHP 教徒确认为 PHP 可以变成一门大而全的语言，摇身一变，强行又是 MVC 又是 MVC 的。各种框架层出不穷，抄完 Spring 又抄 Rails，甚至在一门模板驱动的语言中再搞一个模板渲染引擎。简直是异教。\n\n### Ruby on PHP\n考虑到 Ruby 是一门强大的支持元编程的语言。很容易地我们能够将 Ruby 写成一门以模板来驱动的 CGI 语言。通过几行代码\n\n<!--more-->\n\n```ruby\nrequire 'sinatra'\n\nget '/' do\n  redirect '/index.php'\nend\n\nget /^\\/(.*?)\\.php$/ do |c|\n  erb c.to_sym\nend\n\npost /^\\/(.*?)\\.php$/ do |c|\n  erb c.to_sym\nend\n```\n这样，只需要在 `./view` 下创建 erb 文件就可以当做 php 来写了，甚至连子目录都可以。\n当然这样有一些小问题，比如，传进 erb 后连 request 来什么请求都不知道了。\n所以我们可以稍作修改。\n```ruby\nrequire 'sinatra'\n\nget '/' do\n  redirect '/index.php'\nend\n\nget /^\\/(.*?)\\.php$/ do |c|\n  erb c.to_sym, locals: {request: request}\nend\n\npost /^\\/(.*?)\\.php$/ do |c|\n  erb c.to_sym, locals: {request: request}\nend\n```\n这样我们就有了一切 request 的数据了。自己在里面继续二次处理就是了。\n\n### 模板渲染\nerb 模板是有趣的，但是像 PHP 那样一次性插十几行代码就不是很方便了。其实 erb 里也有这样的方法，只是 deprecated 而已。\n```erb\n<body>\n  <%\n    puts 'foo'\n    puts 'bar'\n  %>\n</body>\n```\n然而问题来了，erb 里并不支持 echo 那样的命令。这样我们没法在一坨 Ruby 代码中输出某个东西到网页。\n但是，Rails 里的 ActionView 不是支持 concat 吗？那么我们稍稍用点元编程的技巧，支持一下 echo 咯。\n所以我们得到了最终代码\n```ruby\n# This is yet another PHP project\nrequire 'sinatra'\nrequire 'action_view'\n\nlookup_context = ActionView::LookupContext.new('./views')\nlookup_context.cache = false if development?\nview_context = ActionView::Base.new(lookup_context)\n\nmodule ActionView::Helpers::TextHelper\n  def echo(string)\n    output_buffer << string\n  end\nend\n\nget '/' do\n  redirect '/index.php'\nend\n\nget /^\\/(.*?)\\.php$/ do |c|\n  view_context.render(file: c, locals: {request: request})\nend\n\npost /^\\/(.*?)\\.php$/ do |c|\n  view_context.render(file: c, locals: {request: request})\nend\n```\n我们也能在 erb 里愉快地 echo 了\n```erb\n<html>\n  <body>\n    Proudly Powered By \n    <br>\n  <%\n    echo 'PHP'\n  %>\n  </body>\n</html>\n```\n\n### 副作用\n根据上面的做法，我们把 Ruby 变成了一门什叶派 PHP 心目中 PHP 本该有的样子了。\n顺便还带来了一点副作用那就是，Wappalyzer 把这个项目完全当做 PHP 项目了。\n假如黑客试图用 PHP 的漏洞来攻击你，就等着看好戏吧。诶嘿~\n\n","slug":"ruby-on-php-abc","published":1,"updated":"2016-06-10T23:08:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscy009g0011pp8zt7v7aahm","content":"<h3 id=\"关于什叶派-PHP-教徒\"><a href=\"#关于什叶派-PHP-教徒\" class=\"headerlink\" title=\"关于什叶派 PHP 教徒\"></a>关于什叶派 PHP 教徒</h3><p>PHP 早期的设计意图下整个语言都是模板驱动的。也就是说主要就是写个静态页面，在适当的需要动态的场合插入一些短小的 CGI 代码。然而逊尼派 PHP 教徒确认为 PHP 可以变成一门大而全的语言，摇身一变，强行又是 MVC 又是 MVC 的。各种框架层出不穷，抄完 Spring 又抄 Rails，甚至在一门模板驱动的语言中再搞一个模板渲染引擎。简直是异教。</p>\n<h3 id=\"Ruby-on-PHP\"><a href=\"#Ruby-on-PHP\" class=\"headerlink\" title=\"Ruby on PHP\"></a>Ruby on PHP</h3><p>考虑到 Ruby 是一门强大的支持元编程的语言。很容易地我们能够将 Ruby 写成一门以模板来驱动的 CGI 语言。通过几行代码</p>\n<a id=\"more\"></a>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">require</span> <span class=\"string\">'sinatra'</span></span><br><span class=\"line\"></span><br><span class=\"line\">get <span class=\"string\">'/'</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">  redirect <span class=\"string\">'/index.php'</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">get /^\\/(.*?)\\.php$/ <span class=\"keyword\">do</span> <span class=\"params\">|c|</span></span><br><span class=\"line\">  erb c.to_sym</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">post /^\\/(.*?)\\.php$/ <span class=\"keyword\">do</span> <span class=\"params\">|c|</span></span><br><span class=\"line\">  erb c.to_sym</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>这样，只需要在 <code>./view</code> 下创建 erb 文件就可以当做 php 来写了，甚至连子目录都可以。<br>当然这样有一些小问题，比如，传进 erb 后连 request 来什么请求都不知道了。<br>所以我们可以稍作修改。<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">require</span> <span class=\"string\">'sinatra'</span></span><br><span class=\"line\"></span><br><span class=\"line\">get <span class=\"string\">'/'</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">  redirect <span class=\"string\">'/index.php'</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">get /^\\/(.*?)\\.php$/ <span class=\"keyword\">do</span> <span class=\"params\">|c|</span></span><br><span class=\"line\">  erb c.to_sym, <span class=\"symbol\">locals:</span> &#123;<span class=\"symbol\">request:</span> request&#125;</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">post /^\\/(.*?)\\.php$/ <span class=\"keyword\">do</span> <span class=\"params\">|c|</span></span><br><span class=\"line\">  erb c.to_sym, <span class=\"symbol\">locals:</span> &#123;<span class=\"symbol\">request:</span> request&#125;</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure></p>\n<p>这样我们就有了一切 request 的数据了。自己在里面继续二次处理就是了。</p>\n<h3 id=\"模板渲染\"><a href=\"#模板渲染\" class=\"headerlink\" title=\"模板渲染\"></a>模板渲染</h3><p>erb 模板是有趣的，但是像 PHP 那样一次性插十几行代码就不是很方便了。其实 erb 里也有这样的方法，只是 deprecated 而已。<br><figure class=\"highlight erb\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;%<span class=\"ruby\"></span><br><span class=\"line\">    puts <span class=\"string\">'foo'</span></span><br><span class=\"line\">    puts <span class=\"string\">'bar'</span></span><br><span class=\"line\">  </span>%&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p>\n<p>然而问题来了，erb 里并不支持 echo 那样的命令。这样我们没法在一坨 Ruby 代码中输出某个东西到网页。<br>但是，Rails 里的 ActionView 不是支持 concat 吗？那么我们稍稍用点元编程的技巧，支持一下 echo 咯。<br>所以我们得到了最终代码<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># This is yet another PHP project</span></span><br><span class=\"line\"><span class=\"keyword\">require</span> <span class=\"string\">'sinatra'</span></span><br><span class=\"line\"><span class=\"keyword\">require</span> <span class=\"string\">'action_view'</span></span><br><span class=\"line\"></span><br><span class=\"line\">lookup_context = ActionView::LookupContext.new(<span class=\"string\">'./views'</span>)</span><br><span class=\"line\">lookup_context.cache = <span class=\"literal\">false</span> <span class=\"keyword\">if</span> development?</span><br><span class=\"line\">view_context = ActionView::Base.new(lookup_context)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">module</span> <span class=\"title\">ActionView::Helpers::TextHelper</span></span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">echo</span><span class=\"params\">(string)</span></span></span><br><span class=\"line\">    output_buffer &lt;&lt; string</span><br><span class=\"line\">  <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">get <span class=\"string\">'/'</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">  redirect <span class=\"string\">'/index.php'</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">get /^\\/(.*?)\\.php$/ <span class=\"keyword\">do</span> <span class=\"params\">|c|</span></span><br><span class=\"line\">  view_context.render(<span class=\"symbol\">file:</span> c, <span class=\"symbol\">locals:</span> &#123;<span class=\"symbol\">request:</span> request&#125;)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">post /^\\/(.*?)\\.php$/ <span class=\"keyword\">do</span> <span class=\"params\">|c|</span></span><br><span class=\"line\">  view_context.render(<span class=\"symbol\">file:</span> c, <span class=\"symbol\">locals:</span> &#123;<span class=\"symbol\">request:</span> request&#125;)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure></p>\n<p>我们也能在 erb 里愉快地 echo 了<br><figure class=\"highlight erb\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;body&gt;</span><br><span class=\"line\">    Proudly Powered By </span><br><span class=\"line\">    &lt;br&gt;</span><br><span class=\"line\">  &lt;%<span class=\"ruby\"></span><br><span class=\"line\">    echo <span class=\"string\">'PHP'</span></span><br><span class=\"line\">  </span>%&gt;</span><br><span class=\"line\">  &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"副作用\"><a href=\"#副作用\" class=\"headerlink\" title=\"副作用\"></a>副作用</h3><p>根据上面的做法，我们把 Ruby 变成了一门什叶派 PHP 心目中 PHP 本该有的样子了。<br>顺便还带来了一点副作用那就是，Wappalyzer 把这个项目完全当做 PHP 项目了。<br>假如黑客试图用 PHP 的漏洞来攻击你，就等着看好戏吧。诶嘿~</p>\n","excerpt":"<h3 id=\"关于什叶派-PHP-教徒\"><a href=\"#关于什叶派-PHP-教徒\" class=\"headerlink\" title=\"关于什叶派 PHP 教徒\"></a>关于什叶派 PHP 教徒</h3><p>PHP 早期的设计意图下整个语言都是模板驱动的。也就是说主要就是写个静态页面，在适当的需要动态的场合插入一些短小的 CGI 代码。然而逊尼派 PHP 教徒确认为 PHP 可以变成一门大而全的语言，摇身一变，强行又是 MVC 又是 MVC 的。各种框架层出不穷，抄完 Spring 又抄 Rails，甚至在一门模板驱动的语言中再搞一个模板渲染引擎。简直是异教。</p>\n<h3 id=\"Ruby-on-PHP\"><a href=\"#Ruby-on-PHP\" class=\"headerlink\" title=\"Ruby on PHP\"></a>Ruby on PHP</h3><p>考虑到 Ruby 是一门强大的支持元编程的语言。很容易地我们能够将 Ruby 写成一门以模板来驱动的 CGI 语言。通过几行代码</p>","more":"<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">require</span> <span class=\"string\">'sinatra'</span></span><br><span class=\"line\"></span><br><span class=\"line\">get <span class=\"string\">'/'</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">  redirect <span class=\"string\">'/index.php'</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">get /^\\/(.*?)\\.php$/ <span class=\"keyword\">do</span> <span class=\"params\">|c|</span></span><br><span class=\"line\">  erb c.to_sym</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">post /^\\/(.*?)\\.php$/ <span class=\"keyword\">do</span> <span class=\"params\">|c|</span></span><br><span class=\"line\">  erb c.to_sym</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>这样，只需要在 <code>./view</code> 下创建 erb 文件就可以当做 php 来写了，甚至连子目录都可以。<br>当然这样有一些小问题，比如，传进 erb 后连 request 来什么请求都不知道了。<br>所以我们可以稍作修改。<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">require</span> <span class=\"string\">'sinatra'</span></span><br><span class=\"line\"></span><br><span class=\"line\">get <span class=\"string\">'/'</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">  redirect <span class=\"string\">'/index.php'</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">get /^\\/(.*?)\\.php$/ <span class=\"keyword\">do</span> <span class=\"params\">|c|</span></span><br><span class=\"line\">  erb c.to_sym, <span class=\"symbol\">locals:</span> &#123;<span class=\"symbol\">request:</span> request&#125;</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">post /^\\/(.*?)\\.php$/ <span class=\"keyword\">do</span> <span class=\"params\">|c|</span></span><br><span class=\"line\">  erb c.to_sym, <span class=\"symbol\">locals:</span> &#123;<span class=\"symbol\">request:</span> request&#125;</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure></p>\n<p>这样我们就有了一切 request 的数据了。自己在里面继续二次处理就是了。</p>\n<h3 id=\"模板渲染\"><a href=\"#模板渲染\" class=\"headerlink\" title=\"模板渲染\"></a>模板渲染</h3><p>erb 模板是有趣的，但是像 PHP 那样一次性插十几行代码就不是很方便了。其实 erb 里也有这样的方法，只是 deprecated 而已。<br><figure class=\"highlight erb\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;%<span class=\"ruby\"></span><br><span class=\"line\">    puts <span class=\"string\">'foo'</span></span><br><span class=\"line\">    puts <span class=\"string\">'bar'</span></span><br><span class=\"line\">  </span>%&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p>\n<p>然而问题来了，erb 里并不支持 echo 那样的命令。这样我们没法在一坨 Ruby 代码中输出某个东西到网页。<br>但是，Rails 里的 ActionView 不是支持 concat 吗？那么我们稍稍用点元编程的技巧，支持一下 echo 咯。<br>所以我们得到了最终代码<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># This is yet another PHP project</span></span><br><span class=\"line\"><span class=\"keyword\">require</span> <span class=\"string\">'sinatra'</span></span><br><span class=\"line\"><span class=\"keyword\">require</span> <span class=\"string\">'action_view'</span></span><br><span class=\"line\"></span><br><span class=\"line\">lookup_context = ActionView::LookupContext.new(<span class=\"string\">'./views'</span>)</span><br><span class=\"line\">lookup_context.cache = <span class=\"literal\">false</span> <span class=\"keyword\">if</span> development?</span><br><span class=\"line\">view_context = ActionView::Base.new(lookup_context)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">module</span> <span class=\"title\">ActionView::Helpers::TextHelper</span></span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">echo</span><span class=\"params\">(string)</span></span></span><br><span class=\"line\">    output_buffer &lt;&lt; string</span><br><span class=\"line\">  <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">get <span class=\"string\">'/'</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">  redirect <span class=\"string\">'/index.php'</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">get /^\\/(.*?)\\.php$/ <span class=\"keyword\">do</span> <span class=\"params\">|c|</span></span><br><span class=\"line\">  view_context.render(<span class=\"symbol\">file:</span> c, <span class=\"symbol\">locals:</span> &#123;<span class=\"symbol\">request:</span> request&#125;)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">post /^\\/(.*?)\\.php$/ <span class=\"keyword\">do</span> <span class=\"params\">|c|</span></span><br><span class=\"line\">  view_context.render(<span class=\"symbol\">file:</span> c, <span class=\"symbol\">locals:</span> &#123;<span class=\"symbol\">request:</span> request&#125;)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure></p>\n<p>我们也能在 erb 里愉快地 echo 了<br><figure class=\"highlight erb\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;body&gt;</span><br><span class=\"line\">    Proudly Powered By </span><br><span class=\"line\">    &lt;br&gt;</span><br><span class=\"line\">  &lt;%<span class=\"ruby\"></span><br><span class=\"line\">    echo <span class=\"string\">'PHP'</span></span><br><span class=\"line\">  </span>%&gt;</span><br><span class=\"line\">  &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"副作用\"><a href=\"#副作用\" class=\"headerlink\" title=\"副作用\"></a>副作用</h3><p>根据上面的做法，我们把 Ruby 变成了一门什叶派 PHP 心目中 PHP 本该有的样子了。<br>顺便还带来了一点副作用那就是，Wappalyzer 把这个项目完全当做 PHP 项目了。<br>假如黑客试图用 PHP 的漏洞来攻击你，就等着看好戏吧。诶嘿~</p>"},{"title":"Android 的虚拟按键","date":"2013-06-30T00:16:36.000Z","_content":"\n相较于 iPhone 单一的实体 Home 键，安卓按键相对来说丰富很多。第一款安卓手机 HTC G1，正面就采用了6个按键，还采取了侧滑全键盘。暂且不说侧滑全键盘对生产力提高的影响（iPhone可以说就是个玩具）。六个实体按键也为操作带来了不少好处，除了操作上简便了不少，也分担了各个按键的损坏速度...（这算是个附加的好处吧）。不过缺点也显而易见，在产品设计上和iPhone看起来确实不够前卫，也和内容常常格格不入，更要命的是大大增加了学习成本。在智能手机还不是很普及的年代，学习成本确实是个相当要命的东西。\n\n<!--more-->\n\n![](http://cdn.heckpsi.com/iPhone-2G.JPG)\n\n![](http://cdn.heckpsi.com/htc-g1-dream.png)\n\n在接下来的几年，安卓阵营慢慢开始发生了一些改变。按键变成了三到四个，一般为 Menu、Home 和 Back，按键也从实体变为触摸，这样使用寿命也变长了不少，而且设计更为简洁。为了增加 Feedback，默认按上去还是有震动的，使用相当舒服。但是几年下来，又发现了新的问题。各个厂家相当地不统一。有的是 Menu Home Back，有的是 Search Menu Home Back，更有丧心病狂的是 Back Menu Home Search。我还用过一个特别有意思的，联想 K1 平板电脑，看起来只有一个 Home 实体按键，但是 Home 键里左右各隐藏了一个红外距离传感器，从左向右滑动 Home 键就是 Menu，从右往左滑动就是 Back。但有一点我不能理解，塑料对红外几乎是透明的，联想为什么非要把这块塑料做成半透明的呢？你可以清楚看到里面的控制 IC，大大影响整体美观，这实在令人难以理解。\n\n随着 Google 的 Android 3.0 和 Android 4.0 的发布， Google 开始在系统逻辑上做减法，同时要动刀的就是这些按键了。首先是 Menu 键被取消了，取而代之的是 Action Bar。什么是 Action Bar 呢？这一点你可以在安卓开发者网页上很清楚的看到描述。硬件上取消了，开发者也必须跟上，否则嘛，就会出现两幅皮\n\n这里还有个问题，就是有些应用明明Ｍenu键毫无用途，为什么还会有两幅皮呢？我们来看安卓空程序的默认源代码中的一段，\n\n```java\n@Override\npublic boolean onCreateOptionsMenu(Menu menu) {\n// Inflate the menu; this adds items to the action bar if it is present.\ngetMenuInflater().inflate(R.menu.activity_main, menu);\nreturn true;\n}\n```\n\n也就是说，Android 4.0 空程序默认就注册了 Menu 键，如果开发者比较无良，没有删掉或者改成 return false 的话，再碰上系统本身优化也不到位，默认就是有两层皮的。\n\n难道没有解决方法吗？当然有，Google Nexus 4 给我们提供了标准， 厂家只要把屏幕做大一条，把所有按键都去掉，剩下就交给 Google 了。他可以保证不同机器的虚拟按键排列一致（减少学习成本），也可以在不同软件下显示不同的按键。可以说是一举多得的方法。但是也有两个问题，一个是厂家似乎不愿意跟进。支持的厂家实在是太少了（HTC One的触摸按键能再奇葩一点吗？）另一个似乎是用户不太接受，总是有用户吐槽被吞掉了一块屏幕很不爽。对于这两个问题，Google 能否解决会成为未来 Android 阵营系统逻辑发展的一个重要议题。\n\n","source":"_posts/things-about-android-touchkeys.md","raw":"---\ntitle: Android 的虚拟按键\ndate: 2013-06-30 08:16:36\ntags: [Android,Google,Apple,iOS,操作系统]\n---\n\n相较于 iPhone 单一的实体 Home 键，安卓按键相对来说丰富很多。第一款安卓手机 HTC G1，正面就采用了6个按键，还采取了侧滑全键盘。暂且不说侧滑全键盘对生产力提高的影响（iPhone可以说就是个玩具）。六个实体按键也为操作带来了不少好处，除了操作上简便了不少，也分担了各个按键的损坏速度...（这算是个附加的好处吧）。不过缺点也显而易见，在产品设计上和iPhone看起来确实不够前卫，也和内容常常格格不入，更要命的是大大增加了学习成本。在智能手机还不是很普及的年代，学习成本确实是个相当要命的东西。\n\n<!--more-->\n\n![](http://cdn.heckpsi.com/iPhone-2G.JPG)\n\n![](http://cdn.heckpsi.com/htc-g1-dream.png)\n\n在接下来的几年，安卓阵营慢慢开始发生了一些改变。按键变成了三到四个，一般为 Menu、Home 和 Back，按键也从实体变为触摸，这样使用寿命也变长了不少，而且设计更为简洁。为了增加 Feedback，默认按上去还是有震动的，使用相当舒服。但是几年下来，又发现了新的问题。各个厂家相当地不统一。有的是 Menu Home Back，有的是 Search Menu Home Back，更有丧心病狂的是 Back Menu Home Search。我还用过一个特别有意思的，联想 K1 平板电脑，看起来只有一个 Home 实体按键，但是 Home 键里左右各隐藏了一个红外距离传感器，从左向右滑动 Home 键就是 Menu，从右往左滑动就是 Back。但有一点我不能理解，塑料对红外几乎是透明的，联想为什么非要把这块塑料做成半透明的呢？你可以清楚看到里面的控制 IC，大大影响整体美观，这实在令人难以理解。\n\n随着 Google 的 Android 3.0 和 Android 4.0 的发布， Google 开始在系统逻辑上做减法，同时要动刀的就是这些按键了。首先是 Menu 键被取消了，取而代之的是 Action Bar。什么是 Action Bar 呢？这一点你可以在安卓开发者网页上很清楚的看到描述。硬件上取消了，开发者也必须跟上，否则嘛，就会出现两幅皮\n\n这里还有个问题，就是有些应用明明Ｍenu键毫无用途，为什么还会有两幅皮呢？我们来看安卓空程序的默认源代码中的一段，\n\n```java\n@Override\npublic boolean onCreateOptionsMenu(Menu menu) {\n// Inflate the menu; this adds items to the action bar if it is present.\ngetMenuInflater().inflate(R.menu.activity_main, menu);\nreturn true;\n}\n```\n\n也就是说，Android 4.0 空程序默认就注册了 Menu 键，如果开发者比较无良，没有删掉或者改成 return false 的话，再碰上系统本身优化也不到位，默认就是有两层皮的。\n\n难道没有解决方法吗？当然有，Google Nexus 4 给我们提供了标准， 厂家只要把屏幕做大一条，把所有按键都去掉，剩下就交给 Google 了。他可以保证不同机器的虚拟按键排列一致（减少学习成本），也可以在不同软件下显示不同的按键。可以说是一举多得的方法。但是也有两个问题，一个是厂家似乎不愿意跟进。支持的厂家实在是太少了（HTC One的触摸按键能再奇葩一点吗？）另一个似乎是用户不太接受，总是有用户吐槽被吞掉了一块屏幕很不爽。对于这两个问题，Google 能否解决会成为未来 Android 阵营系统逻辑发展的一个重要议题。\n\n","slug":"things-about-android-touchkeys","published":1,"updated":"2016-05-15T03:20:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscy009i0014pp8zp3grkicl","content":"<p>相较于 iPhone 单一的实体 Home 键，安卓按键相对来说丰富很多。第一款安卓手机 HTC G1，正面就采用了6个按键，还采取了侧滑全键盘。暂且不说侧滑全键盘对生产力提高的影响（iPhone可以说就是个玩具）。六个实体按键也为操作带来了不少好处，除了操作上简便了不少，也分担了各个按键的损坏速度…（这算是个附加的好处吧）。不过缺点也显而易见，在产品设计上和iPhone看起来确实不够前卫，也和内容常常格格不入，更要命的是大大增加了学习成本。在智能手机还不是很普及的年代，学习成本确实是个相当要命的东西。</p>\n<a id=\"more\"></a>\n<p><img src=\"http://cdn.heckpsi.com/iPhone-2G.JPG\" alt=\"\"></p>\n<p><img src=\"http://cdn.heckpsi.com/htc-g1-dream.png\" alt=\"\"></p>\n<p>在接下来的几年，安卓阵营慢慢开始发生了一些改变。按键变成了三到四个，一般为 Menu、Home 和 Back，按键也从实体变为触摸，这样使用寿命也变长了不少，而且设计更为简洁。为了增加 Feedback，默认按上去还是有震动的，使用相当舒服。但是几年下来，又发现了新的问题。各个厂家相当地不统一。有的是 Menu Home Back，有的是 Search Menu Home Back，更有丧心病狂的是 Back Menu Home Search。我还用过一个特别有意思的，联想 K1 平板电脑，看起来只有一个 Home 实体按键，但是 Home 键里左右各隐藏了一个红外距离传感器，从左向右滑动 Home 键就是 Menu，从右往左滑动就是 Back。但有一点我不能理解，塑料对红外几乎是透明的，联想为什么非要把这块塑料做成半透明的呢？你可以清楚看到里面的控制 IC，大大影响整体美观，这实在令人难以理解。</p>\n<p>随着 Google 的 Android 3.0 和 Android 4.0 的发布， Google 开始在系统逻辑上做减法，同时要动刀的就是这些按键了。首先是 Menu 键被取消了，取而代之的是 Action Bar。什么是 Action Bar 呢？这一点你可以在安卓开发者网页上很清楚的看到描述。硬件上取消了，开发者也必须跟上，否则嘛，就会出现两幅皮</p>\n<p>这里还有个问题，就是有些应用明明Ｍenu键毫无用途，为什么还会有两幅皮呢？我们来看安卓空程序的默认源代码中的一段，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onCreateOptionsMenu</span><span class=\"params\">(Menu menu)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// Inflate the menu; this adds items to the action bar if it is present.</span></span><br><span class=\"line\">getMenuInflater().inflate(R.menu.activity_main, menu);</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也就是说，Android 4.0 空程序默认就注册了 Menu 键，如果开发者比较无良，没有删掉或者改成 return false 的话，再碰上系统本身优化也不到位，默认就是有两层皮的。</p>\n<p>难道没有解决方法吗？当然有，Google Nexus 4 给我们提供了标准， 厂家只要把屏幕做大一条，把所有按键都去掉，剩下就交给 Google 了。他可以保证不同机器的虚拟按键排列一致（减少学习成本），也可以在不同软件下显示不同的按键。可以说是一举多得的方法。但是也有两个问题，一个是厂家似乎不愿意跟进。支持的厂家实在是太少了（HTC One的触摸按键能再奇葩一点吗？）另一个似乎是用户不太接受，总是有用户吐槽被吞掉了一块屏幕很不爽。对于这两个问题，Google 能否解决会成为未来 Android 阵营系统逻辑发展的一个重要议题。</p>\n","excerpt":"<p>相较于 iPhone 单一的实体 Home 键，安卓按键相对来说丰富很多。第一款安卓手机 HTC G1，正面就采用了6个按键，还采取了侧滑全键盘。暂且不说侧滑全键盘对生产力提高的影响（iPhone可以说就是个玩具）。六个实体按键也为操作带来了不少好处，除了操作上简便了不少，也分担了各个按键的损坏速度…（这算是个附加的好处吧）。不过缺点也显而易见，在产品设计上和iPhone看起来确实不够前卫，也和内容常常格格不入，更要命的是大大增加了学习成本。在智能手机还不是很普及的年代，学习成本确实是个相当要命的东西。</p>","more":"<p><img src=\"http://cdn.heckpsi.com/iPhone-2G.JPG\" alt=\"\"></p>\n<p><img src=\"http://cdn.heckpsi.com/htc-g1-dream.png\" alt=\"\"></p>\n<p>在接下来的几年，安卓阵营慢慢开始发生了一些改变。按键变成了三到四个，一般为 Menu、Home 和 Back，按键也从实体变为触摸，这样使用寿命也变长了不少，而且设计更为简洁。为了增加 Feedback，默认按上去还是有震动的，使用相当舒服。但是几年下来，又发现了新的问题。各个厂家相当地不统一。有的是 Menu Home Back，有的是 Search Menu Home Back，更有丧心病狂的是 Back Menu Home Search。我还用过一个特别有意思的，联想 K1 平板电脑，看起来只有一个 Home 实体按键，但是 Home 键里左右各隐藏了一个红外距离传感器，从左向右滑动 Home 键就是 Menu，从右往左滑动就是 Back。但有一点我不能理解，塑料对红外几乎是透明的，联想为什么非要把这块塑料做成半透明的呢？你可以清楚看到里面的控制 IC，大大影响整体美观，这实在令人难以理解。</p>\n<p>随着 Google 的 Android 3.0 和 Android 4.0 的发布， Google 开始在系统逻辑上做减法，同时要动刀的就是这些按键了。首先是 Menu 键被取消了，取而代之的是 Action Bar。什么是 Action Bar 呢？这一点你可以在安卓开发者网页上很清楚的看到描述。硬件上取消了，开发者也必须跟上，否则嘛，就会出现两幅皮</p>\n<p>这里还有个问题，就是有些应用明明Ｍenu键毫无用途，为什么还会有两幅皮呢？我们来看安卓空程序的默认源代码中的一段，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onCreateOptionsMenu</span><span class=\"params\">(Menu menu)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// Inflate the menu; this adds items to the action bar if it is present.</span></span><br><span class=\"line\">getMenuInflater().inflate(R.menu.activity_main, menu);</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也就是说，Android 4.0 空程序默认就注册了 Menu 键，如果开发者比较无良，没有删掉或者改成 return false 的话，再碰上系统本身优化也不到位，默认就是有两层皮的。</p>\n<p>难道没有解决方法吗？当然有，Google Nexus 4 给我们提供了标准， 厂家只要把屏幕做大一条，把所有按键都去掉，剩下就交给 Google 了。他可以保证不同机器的虚拟按键排列一致（减少学习成本），也可以在不同软件下显示不同的按键。可以说是一举多得的方法。但是也有两个问题，一个是厂家似乎不愿意跟进。支持的厂家实在是太少了（HTC One的触摸按键能再奇葩一点吗？）另一个似乎是用户不太接受，总是有用户吐槽被吞掉了一块屏幕很不爽。对于这两个问题，Google 能否解决会成为未来 Android 阵营系统逻辑发展的一个重要议题。</p>"},{"title":"SA 屏究竟是一套什么样的技术？（上）","date":"2015-11-01T07:15:00.000Z","dsc":"从 LED 聊到 Super AMOLED","_content":"\n**从 LED 聊到 Super AMOLED**\n\n<!--more-->\n\n### 万物基于 ~~MIUI~~ LED\n\nLED 是一项非常古老的技术，如果我们追溯其起源，可以到达五十多年前的 1961 年。今天已经是世界第三大半导体制造商德州仪器（Texas Instruments）的两位研究员 Robert Biard 和 Gary Pittman 首次发现了基于砷化镓的半导体材料能够放射出红外线。次年，通用电气公司的（General Electiric Company）的 Nick Holonyak 制造出了首个可以发出可见光的 LED。\n\nLED，Light-Emitting Diode 即「发光二极管」究其本质当然是一种\u000e能发光的半导体。二极管的基本特性简单来理解是说当电流从一个方向流过时，能够很正常的导通。但从反方向流过时，会受到较大的电阻，只能产生微弱的电流。然而这样的特性对于发光特性并没有什么直接的联系。那 LED 为什么会成为一项主流的发光技术呢？那我们应该和另一项我们常见的发光技术来比较发光原理，那就是钨丝灯泡或卤素灯泡（钨卤灯泡）。\n\n电灯泡的基本原理是根据了黑体辐射理论（非常有意思的是黑体辐射理论作为量子力学的一部分提出在灯泡发明后的一百余年），物体在不同温度下能发出不同频率的光，当温度小的时候通常是肉眼不可见的红外线，而温度高了之后就能发出可见光了（比如我们看到打铁的时候铁块会发出红光）。这样的灯泡首先首先体积不小，其次温度很高，更糟糕的是，白炽灯只有少于 10% 的能量会成为光，发光效率非常低下。\n\n而 LED 由半导体材料组成，当电流从阳极（p极）流向阴极（n极）的时候，电子会跌落到较低能阶的轨道上，多出的能量会以电磁波（光子）的形式被释出。这样从理论上是发光效率极高的，因为少掉的能量几乎都变成了放出的电磁波。而我们只需要让放出的电磁波是可见光波段我们即可实现发光的作用了。体积、工作温度、发光效率都能远超电灯泡。\n\n对于 LED 的发展事实上只有一个问题需要考虑，那就是半导体的材料。材料决定了发出了光的频率即颜色。如今人们发现的 LED 无机材料已经超过了 20 多种。\n\n### 把不要显示的东西遮住，液晶显示器（LCD）的基本原理\nLED 的最经典的应用当然不是各种信号灯之类，而是是现在普遍使用的液晶显示器（LCD）了。LED 技术的出现意味着我们可以做出比起 CRT（阴极射线管）那样要远距离开枪发光的屏幕更薄更小的屏幕了。然而要利用 LED 做屏幕我们有几个非常关键的问题要解决。首先，LED 的成本并不低，如果我们为每个像素都配上红绿蓝三个 LED 这将变得非常昂贵。但如果我们不这么做的话是无法发出任何合成光的，至少，LED 发的光都是单色光，而像白色这样的光都是合成光，是无法实现的。\n\n读到这里的有些同学可能就要产生疑问了，既然如此，那我们平时看到商场里卖的白色 LED 灯泡又是怎么做的呢？事实上，现在我们看到的白光 LED 是蓝色或者紫外 LED，然后在灯泡内壁上涂上能吸收蓝光或紫外线发出红光绿光蓝光的荧光剂，从而发出红绿蓝的混合光，即白光。这时候我们就有个很大的消耗，就是荧光剂转换光的颜色的过程中会浪费一部分能量，所以我们看到白色 LED 的发热相比其他颜色还是要高一点的。\n\n除了利用荧光发出白光的 LED 的技术的发明，另一项重要的技术也是 LCD 发明的重要步骤，那就是液晶（Liquid Crystal）。液晶存在一个特殊的性质就是它的液晶相能改变偏光性。\n\n简单的你可以认为，一束光含有非常多的小的光子，每个光子在向前运动过程中，自身还会沿着某个随机的方向发生小的振动。而透过一片液晶后，横向振动的正常通过了；垂直振动的撞在了液晶上，能量被液晶吸收放出了热能，无法通过；斜着振动的，垂直部分的能量被吸收，而横向的能量保持，继续通过了液晶。从宏观的角度来看，亮度减少了一半。而如果连续通过两个液晶，而他们能通过的方向是正好垂直的，那么 100% 的光都可以被吸收，完全不发光。\n\n而液晶本身对电信号敏感，意味着我们能通过通电来改变液晶的方向，从而很容易地控制哪些光应该被遮住哪些应该被通过。屏幕上其实是有两块液晶构成的，第一块就是单纯只让一个方向的光通过，而第二层由电信号控制，来决定透过多少光，显示一个多亮的东西。\n\nLCD 显示器是由一块白色的 LED 背光，一片液晶和一片被电信号控制的液晶组成的。彩色的 LCD 显示器就是在背光上再贴上红色绿色蓝色的贴纸，来精确控制每个颜色的亮度而已。然而事实上，这种能量损耗是惊人的。首先 LED 由蓝色变成白色需要损失一部分能量，再贴上三色的贴纸又要损失 66% 的能量，通过一片液晶又会损失 50% 的能量。所以最下面的 LED 背光需要非常亮才行。\n\n尽管如此，这项技术随着时间的发展已经变得非常成熟，显示效果非常地好。直到智能手机发明后的好一段时间大家发现，手机的主要耗电都放在了屏幕上，而手机的电池又不那么够用。我们急需一项新技术来改进我们显示的功耗。\n\n### OLED —— 更低的成本，更大的应用可能\n我们之前说到 LED 决定颜色的主要关键在于材料，但我之前也说我们发现了超过 20 种无机材料，无机材料简单来说就是一些合金，组合的数量其实很少，可供选择的改进很少，已有的选项生产成本都不低。然而这时候我们需要谈到一个人，他叫做邓青云，他出生于英属香港，后在英属哥伦比亚大学得到化学理学士学位，后进入康奈尔大学获得物理化学博士学位，之后于 1975 年进入柯达公司 Rochester 实验室工作。在实验中意外发现了一些有机材料也可以成为这样的材料。OLED 使用了有机化合物作为半导体材料，工艺简单、成本低廉甚至还能用印刷方式制造。这意味着我们可以用 OLED 印刷出一个大面积的发光面。\n\n这些特性都是传统 LED 没有的。我们用红色、绿色、蓝色的 OLED 通过印刷方法就能得到一个很大的屏幕，通过电信号单独控制每个灯，我们就能精确发出光的亮度。在显示黑色的时候耗能几乎是 0，发光不透过彩色贴纸、不透过液晶、没有荧光粉，简直就是我们继续要找的这么一款用来做手机显示器的卓越材料。\n\n\n### 下篇预告\n- AMOLED 与 PMOLED 的区别在于有没有 TFT（我并没有在开玩笑）\n- Super AMOLED 与 OGS、InCell、OnCell\n- 拜耳阵列与 Pentile 排列的发展\n\n","source":"_posts/super-amoled-introduction-part-1.md","raw":"---\ntitle: SA 屏究竟是一套什么样的技术？（上）\ndate: 2015-11-01 15:15:00\ndsc: 从 LED 聊到 Super AMOLED\ntags: [科普,Samsung,SuperAmoled]\n---\n\n**从 LED 聊到 Super AMOLED**\n\n<!--more-->\n\n### 万物基于 ~~MIUI~~ LED\n\nLED 是一项非常古老的技术，如果我们追溯其起源，可以到达五十多年前的 1961 年。今天已经是世界第三大半导体制造商德州仪器（Texas Instruments）的两位研究员 Robert Biard 和 Gary Pittman 首次发现了基于砷化镓的半导体材料能够放射出红外线。次年，通用电气公司的（General Electiric Company）的 Nick Holonyak 制造出了首个可以发出可见光的 LED。\n\nLED，Light-Emitting Diode 即「发光二极管」究其本质当然是一种\u000e能发光的半导体。二极管的基本特性简单来理解是说当电流从一个方向流过时，能够很正常的导通。但从反方向流过时，会受到较大的电阻，只能产生微弱的电流。然而这样的特性对于发光特性并没有什么直接的联系。那 LED 为什么会成为一项主流的发光技术呢？那我们应该和另一项我们常见的发光技术来比较发光原理，那就是钨丝灯泡或卤素灯泡（钨卤灯泡）。\n\n电灯泡的基本原理是根据了黑体辐射理论（非常有意思的是黑体辐射理论作为量子力学的一部分提出在灯泡发明后的一百余年），物体在不同温度下能发出不同频率的光，当温度小的时候通常是肉眼不可见的红外线，而温度高了之后就能发出可见光了（比如我们看到打铁的时候铁块会发出红光）。这样的灯泡首先首先体积不小，其次温度很高，更糟糕的是，白炽灯只有少于 10% 的能量会成为光，发光效率非常低下。\n\n而 LED 由半导体材料组成，当电流从阳极（p极）流向阴极（n极）的时候，电子会跌落到较低能阶的轨道上，多出的能量会以电磁波（光子）的形式被释出。这样从理论上是发光效率极高的，因为少掉的能量几乎都变成了放出的电磁波。而我们只需要让放出的电磁波是可见光波段我们即可实现发光的作用了。体积、工作温度、发光效率都能远超电灯泡。\n\n对于 LED 的发展事实上只有一个问题需要考虑，那就是半导体的材料。材料决定了发出了光的频率即颜色。如今人们发现的 LED 无机材料已经超过了 20 多种。\n\n### 把不要显示的东西遮住，液晶显示器（LCD）的基本原理\nLED 的最经典的应用当然不是各种信号灯之类，而是是现在普遍使用的液晶显示器（LCD）了。LED 技术的出现意味着我们可以做出比起 CRT（阴极射线管）那样要远距离开枪发光的屏幕更薄更小的屏幕了。然而要利用 LED 做屏幕我们有几个非常关键的问题要解决。首先，LED 的成本并不低，如果我们为每个像素都配上红绿蓝三个 LED 这将变得非常昂贵。但如果我们不这么做的话是无法发出任何合成光的，至少，LED 发的光都是单色光，而像白色这样的光都是合成光，是无法实现的。\n\n读到这里的有些同学可能就要产生疑问了，既然如此，那我们平时看到商场里卖的白色 LED 灯泡又是怎么做的呢？事实上，现在我们看到的白光 LED 是蓝色或者紫外 LED，然后在灯泡内壁上涂上能吸收蓝光或紫外线发出红光绿光蓝光的荧光剂，从而发出红绿蓝的混合光，即白光。这时候我们就有个很大的消耗，就是荧光剂转换光的颜色的过程中会浪费一部分能量，所以我们看到白色 LED 的发热相比其他颜色还是要高一点的。\n\n除了利用荧光发出白光的 LED 的技术的发明，另一项重要的技术也是 LCD 发明的重要步骤，那就是液晶（Liquid Crystal）。液晶存在一个特殊的性质就是它的液晶相能改变偏光性。\n\n简单的你可以认为，一束光含有非常多的小的光子，每个光子在向前运动过程中，自身还会沿着某个随机的方向发生小的振动。而透过一片液晶后，横向振动的正常通过了；垂直振动的撞在了液晶上，能量被液晶吸收放出了热能，无法通过；斜着振动的，垂直部分的能量被吸收，而横向的能量保持，继续通过了液晶。从宏观的角度来看，亮度减少了一半。而如果连续通过两个液晶，而他们能通过的方向是正好垂直的，那么 100% 的光都可以被吸收，完全不发光。\n\n而液晶本身对电信号敏感，意味着我们能通过通电来改变液晶的方向，从而很容易地控制哪些光应该被遮住哪些应该被通过。屏幕上其实是有两块液晶构成的，第一块就是单纯只让一个方向的光通过，而第二层由电信号控制，来决定透过多少光，显示一个多亮的东西。\n\nLCD 显示器是由一块白色的 LED 背光，一片液晶和一片被电信号控制的液晶组成的。彩色的 LCD 显示器就是在背光上再贴上红色绿色蓝色的贴纸，来精确控制每个颜色的亮度而已。然而事实上，这种能量损耗是惊人的。首先 LED 由蓝色变成白色需要损失一部分能量，再贴上三色的贴纸又要损失 66% 的能量，通过一片液晶又会损失 50% 的能量。所以最下面的 LED 背光需要非常亮才行。\n\n尽管如此，这项技术随着时间的发展已经变得非常成熟，显示效果非常地好。直到智能手机发明后的好一段时间大家发现，手机的主要耗电都放在了屏幕上，而手机的电池又不那么够用。我们急需一项新技术来改进我们显示的功耗。\n\n### OLED —— 更低的成本，更大的应用可能\n我们之前说到 LED 决定颜色的主要关键在于材料，但我之前也说我们发现了超过 20 种无机材料，无机材料简单来说就是一些合金，组合的数量其实很少，可供选择的改进很少，已有的选项生产成本都不低。然而这时候我们需要谈到一个人，他叫做邓青云，他出生于英属香港，后在英属哥伦比亚大学得到化学理学士学位，后进入康奈尔大学获得物理化学博士学位，之后于 1975 年进入柯达公司 Rochester 实验室工作。在实验中意外发现了一些有机材料也可以成为这样的材料。OLED 使用了有机化合物作为半导体材料，工艺简单、成本低廉甚至还能用印刷方式制造。这意味着我们可以用 OLED 印刷出一个大面积的发光面。\n\n这些特性都是传统 LED 没有的。我们用红色、绿色、蓝色的 OLED 通过印刷方法就能得到一个很大的屏幕，通过电信号单独控制每个灯，我们就能精确发出光的亮度。在显示黑色的时候耗能几乎是 0，发光不透过彩色贴纸、不透过液晶、没有荧光粉，简直就是我们继续要找的这么一款用来做手机显示器的卓越材料。\n\n\n### 下篇预告\n- AMOLED 与 PMOLED 的区别在于有没有 TFT（我并没有在开玩笑）\n- Super AMOLED 与 OGS、InCell、OnCell\n- 拜耳阵列与 Pentile 排列的发展\n\n","slug":"super-amoled-introduction-part-1","published":1,"updated":"2016-04-21T16:33:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscy009k0016pp8z8j5jyoev","content":"<p><strong>从 LED 聊到 Super AMOLED</strong></p>\n<a id=\"more\"></a>\n<h3 id=\"万物基于-MIUI-LED\"><a href=\"#万物基于-MIUI-LED\" class=\"headerlink\" title=\"万物基于 MIUI LED\"></a>万物基于 <del>MIUI</del> LED</h3><p>LED 是一项非常古老的技术，如果我们追溯其起源，可以到达五十多年前的 1961 年。今天已经是世界第三大半导体制造商德州仪器（Texas Instruments）的两位研究员 Robert Biard 和 Gary Pittman 首次发现了基于砷化镓的半导体材料能够放射出红外线。次年，通用电气公司的（General Electiric Company）的 Nick Holonyak 制造出了首个可以发出可见光的 LED。</p>\n<p>LED，Light-Emitting Diode 即「发光二极管」究其本质当然是一种\u000e能发光的半导体。二极管的基本特性简单来理解是说当电流从一个方向流过时，能够很正常的导通。但从反方向流过时，会受到较大的电阻，只能产生微弱的电流。然而这样的特性对于发光特性并没有什么直接的联系。那 LED 为什么会成为一项主流的发光技术呢？那我们应该和另一项我们常见的发光技术来比较发光原理，那就是钨丝灯泡或卤素灯泡（钨卤灯泡）。</p>\n<p>电灯泡的基本原理是根据了黑体辐射理论（非常有意思的是黑体辐射理论作为量子力学的一部分提出在灯泡发明后的一百余年），物体在不同温度下能发出不同频率的光，当温度小的时候通常是肉眼不可见的红外线，而温度高了之后就能发出可见光了（比如我们看到打铁的时候铁块会发出红光）。这样的灯泡首先首先体积不小，其次温度很高，更糟糕的是，白炽灯只有少于 10% 的能量会成为光，发光效率非常低下。</p>\n<p>而 LED 由半导体材料组成，当电流从阳极（p极）流向阴极（n极）的时候，电子会跌落到较低能阶的轨道上，多出的能量会以电磁波（光子）的形式被释出。这样从理论上是发光效率极高的，因为少掉的能量几乎都变成了放出的电磁波。而我们只需要让放出的电磁波是可见光波段我们即可实现发光的作用了。体积、工作温度、发光效率都能远超电灯泡。</p>\n<p>对于 LED 的发展事实上只有一个问题需要考虑，那就是半导体的材料。材料决定了发出了光的频率即颜色。如今人们发现的 LED 无机材料已经超过了 20 多种。</p>\n<h3 id=\"把不要显示的东西遮住，液晶显示器（LCD）的基本原理\"><a href=\"#把不要显示的东西遮住，液晶显示器（LCD）的基本原理\" class=\"headerlink\" title=\"把不要显示的东西遮住，液晶显示器（LCD）的基本原理\"></a>把不要显示的东西遮住，液晶显示器（LCD）的基本原理</h3><p>LED 的最经典的应用当然不是各种信号灯之类，而是是现在普遍使用的液晶显示器（LCD）了。LED 技术的出现意味着我们可以做出比起 CRT（阴极射线管）那样要远距离开枪发光的屏幕更薄更小的屏幕了。然而要利用 LED 做屏幕我们有几个非常关键的问题要解决。首先，LED 的成本并不低，如果我们为每个像素都配上红绿蓝三个 LED 这将变得非常昂贵。但如果我们不这么做的话是无法发出任何合成光的，至少，LED 发的光都是单色光，而像白色这样的光都是合成光，是无法实现的。</p>\n<p>读到这里的有些同学可能就要产生疑问了，既然如此，那我们平时看到商场里卖的白色 LED 灯泡又是怎么做的呢？事实上，现在我们看到的白光 LED 是蓝色或者紫外 LED，然后在灯泡内壁上涂上能吸收蓝光或紫外线发出红光绿光蓝光的荧光剂，从而发出红绿蓝的混合光，即白光。这时候我们就有个很大的消耗，就是荧光剂转换光的颜色的过程中会浪费一部分能量，所以我们看到白色 LED 的发热相比其他颜色还是要高一点的。</p>\n<p>除了利用荧光发出白光的 LED 的技术的发明，另一项重要的技术也是 LCD 发明的重要步骤，那就是液晶（Liquid Crystal）。液晶存在一个特殊的性质就是它的液晶相能改变偏光性。</p>\n<p>简单的你可以认为，一束光含有非常多的小的光子，每个光子在向前运动过程中，自身还会沿着某个随机的方向发生小的振动。而透过一片液晶后，横向振动的正常通过了；垂直振动的撞在了液晶上，能量被液晶吸收放出了热能，无法通过；斜着振动的，垂直部分的能量被吸收，而横向的能量保持，继续通过了液晶。从宏观的角度来看，亮度减少了一半。而如果连续通过两个液晶，而他们能通过的方向是正好垂直的，那么 100% 的光都可以被吸收，完全不发光。</p>\n<p>而液晶本身对电信号敏感，意味着我们能通过通电来改变液晶的方向，从而很容易地控制哪些光应该被遮住哪些应该被通过。屏幕上其实是有两块液晶构成的，第一块就是单纯只让一个方向的光通过，而第二层由电信号控制，来决定透过多少光，显示一个多亮的东西。</p>\n<p>LCD 显示器是由一块白色的 LED 背光，一片液晶和一片被电信号控制的液晶组成的。彩色的 LCD 显示器就是在背光上再贴上红色绿色蓝色的贴纸，来精确控制每个颜色的亮度而已。然而事实上，这种能量损耗是惊人的。首先 LED 由蓝色变成白色需要损失一部分能量，再贴上三色的贴纸又要损失 66% 的能量，通过一片液晶又会损失 50% 的能量。所以最下面的 LED 背光需要非常亮才行。</p>\n<p>尽管如此，这项技术随着时间的发展已经变得非常成熟，显示效果非常地好。直到智能手机发明后的好一段时间大家发现，手机的主要耗电都放在了屏幕上，而手机的电池又不那么够用。我们急需一项新技术来改进我们显示的功耗。</p>\n<h3 id=\"OLED-——-更低的成本，更大的应用可能\"><a href=\"#OLED-——-更低的成本，更大的应用可能\" class=\"headerlink\" title=\"OLED —— 更低的成本，更大的应用可能\"></a>OLED —— 更低的成本，更大的应用可能</h3><p>我们之前说到 LED 决定颜色的主要关键在于材料，但我之前也说我们发现了超过 20 种无机材料，无机材料简单来说就是一些合金，组合的数量其实很少，可供选择的改进很少，已有的选项生产成本都不低。然而这时候我们需要谈到一个人，他叫做邓青云，他出生于英属香港，后在英属哥伦比亚大学得到化学理学士学位，后进入康奈尔大学获得物理化学博士学位，之后于 1975 年进入柯达公司 Rochester 实验室工作。在实验中意外发现了一些有机材料也可以成为这样的材料。OLED 使用了有机化合物作为半导体材料，工艺简单、成本低廉甚至还能用印刷方式制造。这意味着我们可以用 OLED 印刷出一个大面积的发光面。</p>\n<p>这些特性都是传统 LED 没有的。我们用红色、绿色、蓝色的 OLED 通过印刷方法就能得到一个很大的屏幕，通过电信号单独控制每个灯，我们就能精确发出光的亮度。在显示黑色的时候耗能几乎是 0，发光不透过彩色贴纸、不透过液晶、没有荧光粉，简直就是我们继续要找的这么一款用来做手机显示器的卓越材料。</p>\n<h3 id=\"下篇预告\"><a href=\"#下篇预告\" class=\"headerlink\" title=\"下篇预告\"></a>下篇预告</h3><ul>\n<li>AMOLED 与 PMOLED 的区别在于有没有 TFT（我并没有在开玩笑）</li>\n<li>Super AMOLED 与 OGS、InCell、OnCell</li>\n<li>拜耳阵列与 Pentile 排列的发展</li>\n</ul>\n","excerpt":"<p><strong>从 LED 聊到 Super AMOLED</strong></p>","more":"<h3 id=\"万物基于-MIUI-LED\"><a href=\"#万物基于-MIUI-LED\" class=\"headerlink\" title=\"万物基于 MIUI LED\"></a>万物基于 <del>MIUI</del> LED</h3><p>LED 是一项非常古老的技术，如果我们追溯其起源，可以到达五十多年前的 1961 年。今天已经是世界第三大半导体制造商德州仪器（Texas Instruments）的两位研究员 Robert Biard 和 Gary Pittman 首次发现了基于砷化镓的半导体材料能够放射出红外线。次年，通用电气公司的（General Electiric Company）的 Nick Holonyak 制造出了首个可以发出可见光的 LED。</p>\n<p>LED，Light-Emitting Diode 即「发光二极管」究其本质当然是一种\u000e能发光的半导体。二极管的基本特性简单来理解是说当电流从一个方向流过时，能够很正常的导通。但从反方向流过时，会受到较大的电阻，只能产生微弱的电流。然而这样的特性对于发光特性并没有什么直接的联系。那 LED 为什么会成为一项主流的发光技术呢？那我们应该和另一项我们常见的发光技术来比较发光原理，那就是钨丝灯泡或卤素灯泡（钨卤灯泡）。</p>\n<p>电灯泡的基本原理是根据了黑体辐射理论（非常有意思的是黑体辐射理论作为量子力学的一部分提出在灯泡发明后的一百余年），物体在不同温度下能发出不同频率的光，当温度小的时候通常是肉眼不可见的红外线，而温度高了之后就能发出可见光了（比如我们看到打铁的时候铁块会发出红光）。这样的灯泡首先首先体积不小，其次温度很高，更糟糕的是，白炽灯只有少于 10% 的能量会成为光，发光效率非常低下。</p>\n<p>而 LED 由半导体材料组成，当电流从阳极（p极）流向阴极（n极）的时候，电子会跌落到较低能阶的轨道上，多出的能量会以电磁波（光子）的形式被释出。这样从理论上是发光效率极高的，因为少掉的能量几乎都变成了放出的电磁波。而我们只需要让放出的电磁波是可见光波段我们即可实现发光的作用了。体积、工作温度、发光效率都能远超电灯泡。</p>\n<p>对于 LED 的发展事实上只有一个问题需要考虑，那就是半导体的材料。材料决定了发出了光的频率即颜色。如今人们发现的 LED 无机材料已经超过了 20 多种。</p>\n<h3 id=\"把不要显示的东西遮住，液晶显示器（LCD）的基本原理\"><a href=\"#把不要显示的东西遮住，液晶显示器（LCD）的基本原理\" class=\"headerlink\" title=\"把不要显示的东西遮住，液晶显示器（LCD）的基本原理\"></a>把不要显示的东西遮住，液晶显示器（LCD）的基本原理</h3><p>LED 的最经典的应用当然不是各种信号灯之类，而是是现在普遍使用的液晶显示器（LCD）了。LED 技术的出现意味着我们可以做出比起 CRT（阴极射线管）那样要远距离开枪发光的屏幕更薄更小的屏幕了。然而要利用 LED 做屏幕我们有几个非常关键的问题要解决。首先，LED 的成本并不低，如果我们为每个像素都配上红绿蓝三个 LED 这将变得非常昂贵。但如果我们不这么做的话是无法发出任何合成光的，至少，LED 发的光都是单色光，而像白色这样的光都是合成光，是无法实现的。</p>\n<p>读到这里的有些同学可能就要产生疑问了，既然如此，那我们平时看到商场里卖的白色 LED 灯泡又是怎么做的呢？事实上，现在我们看到的白光 LED 是蓝色或者紫外 LED，然后在灯泡内壁上涂上能吸收蓝光或紫外线发出红光绿光蓝光的荧光剂，从而发出红绿蓝的混合光，即白光。这时候我们就有个很大的消耗，就是荧光剂转换光的颜色的过程中会浪费一部分能量，所以我们看到白色 LED 的发热相比其他颜色还是要高一点的。</p>\n<p>除了利用荧光发出白光的 LED 的技术的发明，另一项重要的技术也是 LCD 发明的重要步骤，那就是液晶（Liquid Crystal）。液晶存在一个特殊的性质就是它的液晶相能改变偏光性。</p>\n<p>简单的你可以认为，一束光含有非常多的小的光子，每个光子在向前运动过程中，自身还会沿着某个随机的方向发生小的振动。而透过一片液晶后，横向振动的正常通过了；垂直振动的撞在了液晶上，能量被液晶吸收放出了热能，无法通过；斜着振动的，垂直部分的能量被吸收，而横向的能量保持，继续通过了液晶。从宏观的角度来看，亮度减少了一半。而如果连续通过两个液晶，而他们能通过的方向是正好垂直的，那么 100% 的光都可以被吸收，完全不发光。</p>\n<p>而液晶本身对电信号敏感，意味着我们能通过通电来改变液晶的方向，从而很容易地控制哪些光应该被遮住哪些应该被通过。屏幕上其实是有两块液晶构成的，第一块就是单纯只让一个方向的光通过，而第二层由电信号控制，来决定透过多少光，显示一个多亮的东西。</p>\n<p>LCD 显示器是由一块白色的 LED 背光，一片液晶和一片被电信号控制的液晶组成的。彩色的 LCD 显示器就是在背光上再贴上红色绿色蓝色的贴纸，来精确控制每个颜色的亮度而已。然而事实上，这种能量损耗是惊人的。首先 LED 由蓝色变成白色需要损失一部分能量，再贴上三色的贴纸又要损失 66% 的能量，通过一片液晶又会损失 50% 的能量。所以最下面的 LED 背光需要非常亮才行。</p>\n<p>尽管如此，这项技术随着时间的发展已经变得非常成熟，显示效果非常地好。直到智能手机发明后的好一段时间大家发现，手机的主要耗电都放在了屏幕上，而手机的电池又不那么够用。我们急需一项新技术来改进我们显示的功耗。</p>\n<h3 id=\"OLED-——-更低的成本，更大的应用可能\"><a href=\"#OLED-——-更低的成本，更大的应用可能\" class=\"headerlink\" title=\"OLED —— 更低的成本，更大的应用可能\"></a>OLED —— 更低的成本，更大的应用可能</h3><p>我们之前说到 LED 决定颜色的主要关键在于材料，但我之前也说我们发现了超过 20 种无机材料，无机材料简单来说就是一些合金，组合的数量其实很少，可供选择的改进很少，已有的选项生产成本都不低。然而这时候我们需要谈到一个人，他叫做邓青云，他出生于英属香港，后在英属哥伦比亚大学得到化学理学士学位，后进入康奈尔大学获得物理化学博士学位，之后于 1975 年进入柯达公司 Rochester 实验室工作。在实验中意外发现了一些有机材料也可以成为这样的材料。OLED 使用了有机化合物作为半导体材料，工艺简单、成本低廉甚至还能用印刷方式制造。这意味着我们可以用 OLED 印刷出一个大面积的发光面。</p>\n<p>这些特性都是传统 LED 没有的。我们用红色、绿色、蓝色的 OLED 通过印刷方法就能得到一个很大的屏幕，通过电信号单独控制每个灯，我们就能精确发出光的亮度。在显示黑色的时候耗能几乎是 0，发光不透过彩色贴纸、不透过液晶、没有荧光粉，简直就是我们继续要找的这么一款用来做手机显示器的卓越材料。</p>\n<h3 id=\"下篇预告\"><a href=\"#下篇预告\" class=\"headerlink\" title=\"下篇预告\"></a>下篇预告</h3><ul>\n<li>AMOLED 与 PMOLED 的区别在于有没有 TFT（我并没有在开玩笑）</li>\n<li>Super AMOLED 与 OGS、InCell、OnCell</li>\n<li>拜耳阵列与 Pentile 排列的发展</li>\n</ul>"},{"title":"脑洞打开说联觉","date":"2015-03-28T12:42:09.000Z","_content":"\n在日本小说家野村美月的轻小说《文学少女》中天野远子拥有“尝书”的奇特能力。在阅读文字的过程中可以感受到书的美味。也就是说，远子学姐的视觉和她的味觉产生某种内部的关联，使得她视觉上的感知能自发地去刺激味觉的感知。这样子的体验看似非常的荒诞，却也十分的有趣，但非更有意思的是，现实生活中还确实存在这样的情况。\n\n魅族 MX4 Pro 的发布会上魅族将其自身的音频解决方案包装命名为 Retina Sound —— 视网膜的声音... 考虑到魅族这样的大企业也不至于会去犯英语不过四级的错误，我们或许完全可以从中挖掘出更深层的秘密。黄章凭借 mp3 产品当年创造一代奇迹的真正原因是不是黄章本身拥有某些我们没有的能力。或许他能像远子学姐用视觉刺激味觉一样，用听觉去刺激视觉呢？\n\n<!--more-->\n\n黄章是不是有这样的能力我不知道，但是现实中有这样类似能力的人倒是有不少。心理学上通常把这种现象叫做联觉认知现象(Synesthesia，有时也译作通感)。\n\n联觉是一种特殊的认知现象。联觉人通常会因为一种感官刺激或认知途径自发且非主动地引起另一种感知或认识。比如当听到某一个声音的时候，会感觉出某一种颜色；看到某一些文字，会感受到某一种味觉；更复杂的还有当看到某个数字的时候，会感觉具体出现在某一个位置等等。联觉通常是无意识的，联觉者一般会认为这样的联系非常的正常而不会刻意地注意到这点。根据估算，人群中平均每23个人会出现一个联觉人。而概率更小的甚至有多联觉人，比如看到某个数字会感觉到某种颜色，同时还能出现在空间中的某一个位置。\n\n对于联觉上的认识不断深入，尤其是本世纪以来的一些研究发展使得神经科学家已经逐渐揭示了联觉现象背后的机理。枯燥的研究论文大煞联觉神秘风景的同时，也带来了不少有意义的应用。比如，我们甚至可以通过一些手段去人工创造一些类似“联觉现象”的产生。比如当你看到某个颜色的时候我们特意去发出某个声音或者去触碰身体的某个部位，通过长期对大脑的不断学习之后，也会产生这样子的联觉的认知。这种认知的产生也可以更有利地去训练一些听力、视力障碍的一些患者去获得这些感知的体验。\n\n通常而言，联觉收到感性化的影响是比较大的，而对于许多联觉人来说，这种体验基本是中性的，甚至有时是比较愉悦的。我们回到我们一开始举的几个例子上。如果黄章真的有这样联觉的认知，把自己的音频产品命名为“视网膜声音”也就不再见怪了。相反的，这显示出了其声音的清晰度，如视网膜看到东西一般“可视化的音频”。黄章使用音频设备播放音乐的时候应该能比常人拥有更深刻的体验。而天野远子那样能将书中的文字转化成味觉的，能使她在阅读上有更加感性的认知，也非常有意思。\n\n这种有意思的体验常常被用于艺术创作之中。比如1940年迪斯尼创作的电影《幻想曲(Fantasia)》中的许多镜头声音的变化会随着画面颜色的变化一同进行。联觉被广泛运用于文学、音乐、绘画、电影、动画之中，并且许多艺术家也是联觉人，联觉给他们带来的体验成为了他们创作过程的源泉。\n\n","source":"_posts/synesthesia.md","raw":"---\ntitle: 脑洞打开说联觉\ndate: 2015-03-28 20:42:09\ntags: [科普,魅族]\n---\n\n在日本小说家野村美月的轻小说《文学少女》中天野远子拥有“尝书”的奇特能力。在阅读文字的过程中可以感受到书的美味。也就是说，远子学姐的视觉和她的味觉产生某种内部的关联，使得她视觉上的感知能自发地去刺激味觉的感知。这样子的体验看似非常的荒诞，却也十分的有趣，但非更有意思的是，现实生活中还确实存在这样的情况。\n\n魅族 MX4 Pro 的发布会上魅族将其自身的音频解决方案包装命名为 Retina Sound —— 视网膜的声音... 考虑到魅族这样的大企业也不至于会去犯英语不过四级的错误，我们或许完全可以从中挖掘出更深层的秘密。黄章凭借 mp3 产品当年创造一代奇迹的真正原因是不是黄章本身拥有某些我们没有的能力。或许他能像远子学姐用视觉刺激味觉一样，用听觉去刺激视觉呢？\n\n<!--more-->\n\n黄章是不是有这样的能力我不知道，但是现实中有这样类似能力的人倒是有不少。心理学上通常把这种现象叫做联觉认知现象(Synesthesia，有时也译作通感)。\n\n联觉是一种特殊的认知现象。联觉人通常会因为一种感官刺激或认知途径自发且非主动地引起另一种感知或认识。比如当听到某一个声音的时候，会感觉出某一种颜色；看到某一些文字，会感受到某一种味觉；更复杂的还有当看到某个数字的时候，会感觉具体出现在某一个位置等等。联觉通常是无意识的，联觉者一般会认为这样的联系非常的正常而不会刻意地注意到这点。根据估算，人群中平均每23个人会出现一个联觉人。而概率更小的甚至有多联觉人，比如看到某个数字会感觉到某种颜色，同时还能出现在空间中的某一个位置。\n\n对于联觉上的认识不断深入，尤其是本世纪以来的一些研究发展使得神经科学家已经逐渐揭示了联觉现象背后的机理。枯燥的研究论文大煞联觉神秘风景的同时，也带来了不少有意义的应用。比如，我们甚至可以通过一些手段去人工创造一些类似“联觉现象”的产生。比如当你看到某个颜色的时候我们特意去发出某个声音或者去触碰身体的某个部位，通过长期对大脑的不断学习之后，也会产生这样子的联觉的认知。这种认知的产生也可以更有利地去训练一些听力、视力障碍的一些患者去获得这些感知的体验。\n\n通常而言，联觉收到感性化的影响是比较大的，而对于许多联觉人来说，这种体验基本是中性的，甚至有时是比较愉悦的。我们回到我们一开始举的几个例子上。如果黄章真的有这样联觉的认知，把自己的音频产品命名为“视网膜声音”也就不再见怪了。相反的，这显示出了其声音的清晰度，如视网膜看到东西一般“可视化的音频”。黄章使用音频设备播放音乐的时候应该能比常人拥有更深刻的体验。而天野远子那样能将书中的文字转化成味觉的，能使她在阅读上有更加感性的认知，也非常有意思。\n\n这种有意思的体验常常被用于艺术创作之中。比如1940年迪斯尼创作的电影《幻想曲(Fantasia)》中的许多镜头声音的变化会随着画面颜色的变化一同进行。联觉被广泛运用于文学、音乐、绘画、电影、动画之中，并且许多艺术家也是联觉人，联觉给他们带来的体验成为了他们创作过程的源泉。\n\n","slug":"synesthesia","published":1,"updated":"2016-04-22T06:52:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscy009l0018pp8zdbgypqbj","content":"<p>在日本小说家野村美月的轻小说《文学少女》中天野远子拥有“尝书”的奇特能力。在阅读文字的过程中可以感受到书的美味。也就是说，远子学姐的视觉和她的味觉产生某种内部的关联，使得她视觉上的感知能自发地去刺激味觉的感知。这样子的体验看似非常的荒诞，却也十分的有趣，但非更有意思的是，现实生活中还确实存在这样的情况。</p>\n<p>魅族 MX4 Pro 的发布会上魅族将其自身的音频解决方案包装命名为 Retina Sound —— 视网膜的声音… 考虑到魅族这样的大企业也不至于会去犯英语不过四级的错误，我们或许完全可以从中挖掘出更深层的秘密。黄章凭借 mp3 产品当年创造一代奇迹的真正原因是不是黄章本身拥有某些我们没有的能力。或许他能像远子学姐用视觉刺激味觉一样，用听觉去刺激视觉呢？</p>\n<a id=\"more\"></a>\n<p>黄章是不是有这样的能力我不知道，但是现实中有这样类似能力的人倒是有不少。心理学上通常把这种现象叫做联觉认知现象(Synesthesia，有时也译作通感)。</p>\n<p>联觉是一种特殊的认知现象。联觉人通常会因为一种感官刺激或认知途径自发且非主动地引起另一种感知或认识。比如当听到某一个声音的时候，会感觉出某一种颜色；看到某一些文字，会感受到某一种味觉；更复杂的还有当看到某个数字的时候，会感觉具体出现在某一个位置等等。联觉通常是无意识的，联觉者一般会认为这样的联系非常的正常而不会刻意地注意到这点。根据估算，人群中平均每23个人会出现一个联觉人。而概率更小的甚至有多联觉人，比如看到某个数字会感觉到某种颜色，同时还能出现在空间中的某一个位置。</p>\n<p>对于联觉上的认识不断深入，尤其是本世纪以来的一些研究发展使得神经科学家已经逐渐揭示了联觉现象背后的机理。枯燥的研究论文大煞联觉神秘风景的同时，也带来了不少有意义的应用。比如，我们甚至可以通过一些手段去人工创造一些类似“联觉现象”的产生。比如当你看到某个颜色的时候我们特意去发出某个声音或者去触碰身体的某个部位，通过长期对大脑的不断学习之后，也会产生这样子的联觉的认知。这种认知的产生也可以更有利地去训练一些听力、视力障碍的一些患者去获得这些感知的体验。</p>\n<p>通常而言，联觉收到感性化的影响是比较大的，而对于许多联觉人来说，这种体验基本是中性的，甚至有时是比较愉悦的。我们回到我们一开始举的几个例子上。如果黄章真的有这样联觉的认知，把自己的音频产品命名为“视网膜声音”也就不再见怪了。相反的，这显示出了其声音的清晰度，如视网膜看到东西一般“可视化的音频”。黄章使用音频设备播放音乐的时候应该能比常人拥有更深刻的体验。而天野远子那样能将书中的文字转化成味觉的，能使她在阅读上有更加感性的认知，也非常有意思。</p>\n<p>这种有意思的体验常常被用于艺术创作之中。比如1940年迪斯尼创作的电影《幻想曲(Fantasia)》中的许多镜头声音的变化会随着画面颜色的变化一同进行。联觉被广泛运用于文学、音乐、绘画、电影、动画之中，并且许多艺术家也是联觉人，联觉给他们带来的体验成为了他们创作过程的源泉。</p>\n","excerpt":"<p>在日本小说家野村美月的轻小说《文学少女》中天野远子拥有“尝书”的奇特能力。在阅读文字的过程中可以感受到书的美味。也就是说，远子学姐的视觉和她的味觉产生某种内部的关联，使得她视觉上的感知能自发地去刺激味觉的感知。这样子的体验看似非常的荒诞，却也十分的有趣，但非更有意思的是，现实生活中还确实存在这样的情况。</p>\n<p>魅族 MX4 Pro 的发布会上魅族将其自身的音频解决方案包装命名为 Retina Sound —— 视网膜的声音… 考虑到魅族这样的大企业也不至于会去犯英语不过四级的错误，我们或许完全可以从中挖掘出更深层的秘密。黄章凭借 mp3 产品当年创造一代奇迹的真正原因是不是黄章本身拥有某些我们没有的能力。或许他能像远子学姐用视觉刺激味觉一样，用听觉去刺激视觉呢？</p>","more":"<p>黄章是不是有这样的能力我不知道，但是现实中有这样类似能力的人倒是有不少。心理学上通常把这种现象叫做联觉认知现象(Synesthesia，有时也译作通感)。</p>\n<p>联觉是一种特殊的认知现象。联觉人通常会因为一种感官刺激或认知途径自发且非主动地引起另一种感知或认识。比如当听到某一个声音的时候，会感觉出某一种颜色；看到某一些文字，会感受到某一种味觉；更复杂的还有当看到某个数字的时候，会感觉具体出现在某一个位置等等。联觉通常是无意识的，联觉者一般会认为这样的联系非常的正常而不会刻意地注意到这点。根据估算，人群中平均每23个人会出现一个联觉人。而概率更小的甚至有多联觉人，比如看到某个数字会感觉到某种颜色，同时还能出现在空间中的某一个位置。</p>\n<p>对于联觉上的认识不断深入，尤其是本世纪以来的一些研究发展使得神经科学家已经逐渐揭示了联觉现象背后的机理。枯燥的研究论文大煞联觉神秘风景的同时，也带来了不少有意义的应用。比如，我们甚至可以通过一些手段去人工创造一些类似“联觉现象”的产生。比如当你看到某个颜色的时候我们特意去发出某个声音或者去触碰身体的某个部位，通过长期对大脑的不断学习之后，也会产生这样子的联觉的认知。这种认知的产生也可以更有利地去训练一些听力、视力障碍的一些患者去获得这些感知的体验。</p>\n<p>通常而言，联觉收到感性化的影响是比较大的，而对于许多联觉人来说，这种体验基本是中性的，甚至有时是比较愉悦的。我们回到我们一开始举的几个例子上。如果黄章真的有这样联觉的认知，把自己的音频产品命名为“视网膜声音”也就不再见怪了。相反的，这显示出了其声音的清晰度，如视网膜看到东西一般“可视化的音频”。黄章使用音频设备播放音乐的时候应该能比常人拥有更深刻的体验。而天野远子那样能将书中的文字转化成味觉的，能使她在阅读上有更加感性的认知，也非常有意思。</p>\n<p>这种有意思的体验常常被用于艺术创作之中。比如1940年迪斯尼创作的电影《幻想曲(Fantasia)》中的许多镜头声音的变化会随着画面颜色的变化一同进行。联觉被广泛运用于文学、音乐、绘画、电影、动画之中，并且许多艺术家也是联觉人，联觉给他们带来的体验成为了他们创作过程的源泉。</p>"},{"title":"为什么有些软件运行的时候看起来窗口/图标/文字很小？","date":"2015-01-28T10:19:23.000Z","_content":"\n为什么这个软件在其他电脑上运行时很正常，而到我电脑上的界面/字体/图片会显示得很小？这个问题，大概是在13年前第一次被人问及。第一次被问到这个问题的时候是感觉别人的电脑玩 Windows 98 自带的纸牌竟是撑满整个屏幕的，而在这台电脑上却空出了很大的空间，即使是最大化这个窗口，显示的牌的大小也很小。而最近更多的则是一些软件，比如旧版本的 Photoshop 之类图标小得根本没法点究竟是什么原因？\n\n![](http://cdn.heckpsi.com/928_1.jpg)\n\n<!--more-->\n\n当然，其实这些问题从原理上来说是殊途同归，同一个问题。而且这个问题是历史遗留问题，这一遗留，已经留了 28 年了。1987 年的一个晚上，IBM 的工程师制定了一种叫做VGA (Video Graphics Array) 的视频传输标准。这是一种模拟信号的传输标准，旨在创造一种统一的视频传输的方式。这个标准下包括了我们目前也依然在使用的 D-Sub 接口（也就是俗称的 VGA 接口），一套通讯的协议，以及当时制定的最基础的视频制式和它的分辨率：640×480。这个标准被广泛应用，以至于当时计算机最常用的分辨率都是 640×480。\n\nWindows 95 的设计当时默认了一个前提，那就是 PC 使用的是640×480的分辨率，这当时看来似乎没有太大的问题。那么既然大家分辨率差不多，那屏幕尺寸的大小相当于等大地“放大”或“缩小”屏幕上的东西。\n\n![](http://cdn.heckpsi.com/928_2.png)\n\n为了方便理解这个概念。我们需要进一步阐释一下分辨率的概念。分辨率指屏幕上显示多少个“点”。比如 640×480 值得就是屏幕上每一行显示 640 个点，而一共显示 480 行。如果这个屏幕比较大，那么这个“点”会变得更大一些，以使得总的显示的点数要维持在 640×480 这个数字上以符合标准。虽然显然地，这个点的尺寸越小，屏幕能显示的东西越细腻，显示的效果会越好。但是标准的制定者似乎也想到另一个观点，屏幕的尺寸越大，大家观看屏幕的距离也会变远，那么大屏幕的“点”稍微大一点也不成什么问题。\n\n所有的设计都是基于这个前提上进行的。所以 Windows 的所有窗口程序都是基于“像素”，也就是“点”的数量这一概念。所有的程序只需要告诉系统，我的窗口是 300×200 大小的，在任何屏幕上显示都会是大约占屏幕1/4的地方，毫无问题。\n\n但是实际上，屏幕的发展却像另外一个方向行进了。640×480 的分辨率做成的 15 或者 17 寸屏幕，人坐在一个合理的距离时，屏幕上面的点并没有小到肉眼不可辨啊，再加上 D-Sub 接口也完全兼容更高的分辨率，这么看来，显示完全可以向更细腻的方向发展。不久后市面上也出现了被称为 Super VGA（800×600）分辨率的屏幕，并且微软很快为 Windows 95 推出了SVGA的驱动程序，使之显示更为细腻。\n\n但是这时候就出现了一个问题，原先我定义窗口大小是 640×480 的话能撑满屏幕，而现在却撑不满了。但是实际想想 800×600 虽然比 640×480 大，但却没大多少，对体验的影响并不大，所以没有引起很大的重视。但是后来推出了 XVGA 的屏幕，也就是 1024×768 的分辨率。但是此时其实也没大多少，再加上 640×480 已经基本淘汰，开发者以 800×600 和 1024×768 为标准就可以了。这个时候大概是 Windows XP 开始盛行的时代。\n\n![](http://cdn.heckpsi.com/928_3.jpg)\n\n各大系统厂商在这几年里开始慢慢发现问题的严重性， 1024×768 慢慢变成了过去时，尤其是越来越多的宽屏分辨率的出现，连 4:3 的比例都不是了，屏幕分辨率多得越来越离奇了，1920×1080 的全高清更是比 640×480 不知道大到哪里去了。所以大家似乎都意识到，光靠基于像素的界面再下去，在不同显示器上的显示效果会很糟糕，于是都推出了不同的方案。\n\n比如苹果的 Mac OS X 10.4 Tiger（2005年4月29日上市）就把整个设计模式都进行了质的变化，XCode 2.0 中采用了全新的视觉模型。视觉是完全基于DPI（即每一英寸有多少个像素点）这样一个比例值为基础来设计的。这一关系更是在之后每一代的 OS X 中得到了强化。但是这种翻天覆地的变化带来一个很不好的结果就是：很差的向后兼容性。这意味着为旧版本 Mac OS X 设计的程序很可能不能在新版本的系统上运行。这一点来说非常糟糕。\n\n![](http://cdn.heckpsi.com/928_4.jpg)\n\n尤其是 Windows 这样面对着大量商业用户的操作系统而言，绝对不能这样做。但是，分辨率的问题也要解决。虽然 XP 下也能调节 DPI 来放大或缩小，但是那种放大镜式的调节，显示效果只能用恶心来形容。于是微软在 Windows Vista 上也试图在保证可运行旧程序这一兼容性要求下引入可变化的DPI模式。这个功能无需原有的软件做任何更改，完全是系统级别的放大和缩小的处理。听起来似乎很有道理，但是依然有两点问题。第一、这个功能藏得深得根本找不到，也没有明确的引导。第二、有些应用的显示尤其是字体的显示会直接错位，这点体验很糟糕。\n\n![](http://cdn.heckpsi.com/928_5.gif)\n\n到了 Windows 7 再到 Windows 8 之后，微软不断地完善了这一项功能，至少它现在基本能用了，也成为了一个默认功能。当你的屏幕尺寸比饺小而分辨率很高时，安装完系统就会默认调高你的 DPI 值以获得更好的显示效果，而不会是基于简单的像素把内容显示在很小一坨。但是，这一功能的兼容性，还是有限的。对于一些完完全全基于像素写的旧软件，如果系统强制放大了内容，可能会导致错位，就像在 Windows Vista 上那样，而如今微软选择，彻底不去动它们。于是，就会有各位在高分屏上安装个 Photoshop 7.0 出现了各种小的可怜的图标，以及其它一些旧程序的显示问题。\n\n当然，微软这么做也是实在出于无奈。Windows 的应用范围如此之广，从地铁的闸机到银行的 ATM 机，从电子广告屏到你手中的 PC，都可能是 Windows。如果搞一个像苹果那样的大清洗，估计大家都没有兴趣升级新系统了，这卖不掉可才会变成更大的问题。进退两难之中，又要做好基于dpi的显示功能，又要做好对之前程序的兼容，也许对于旧程序，能运行和使用，但显示效果不是很好也算是一个权宜之策、无奈之举吧。\n\n","source":"_posts/things-about-dpi.md","raw":"---\ntitle: 为什么有些软件运行的时候看起来窗口/图标/文字很小？\ndate: 2015-01-28 18:19:23\ntags: [科普,DPI,操作系统]\n---\n\n为什么这个软件在其他电脑上运行时很正常，而到我电脑上的界面/字体/图片会显示得很小？这个问题，大概是在13年前第一次被人问及。第一次被问到这个问题的时候是感觉别人的电脑玩 Windows 98 自带的纸牌竟是撑满整个屏幕的，而在这台电脑上却空出了很大的空间，即使是最大化这个窗口，显示的牌的大小也很小。而最近更多的则是一些软件，比如旧版本的 Photoshop 之类图标小得根本没法点究竟是什么原因？\n\n![](http://cdn.heckpsi.com/928_1.jpg)\n\n<!--more-->\n\n当然，其实这些问题从原理上来说是殊途同归，同一个问题。而且这个问题是历史遗留问题，这一遗留，已经留了 28 年了。1987 年的一个晚上，IBM 的工程师制定了一种叫做VGA (Video Graphics Array) 的视频传输标准。这是一种模拟信号的传输标准，旨在创造一种统一的视频传输的方式。这个标准下包括了我们目前也依然在使用的 D-Sub 接口（也就是俗称的 VGA 接口），一套通讯的协议，以及当时制定的最基础的视频制式和它的分辨率：640×480。这个标准被广泛应用，以至于当时计算机最常用的分辨率都是 640×480。\n\nWindows 95 的设计当时默认了一个前提，那就是 PC 使用的是640×480的分辨率，这当时看来似乎没有太大的问题。那么既然大家分辨率差不多，那屏幕尺寸的大小相当于等大地“放大”或“缩小”屏幕上的东西。\n\n![](http://cdn.heckpsi.com/928_2.png)\n\n为了方便理解这个概念。我们需要进一步阐释一下分辨率的概念。分辨率指屏幕上显示多少个“点”。比如 640×480 值得就是屏幕上每一行显示 640 个点，而一共显示 480 行。如果这个屏幕比较大，那么这个“点”会变得更大一些，以使得总的显示的点数要维持在 640×480 这个数字上以符合标准。虽然显然地，这个点的尺寸越小，屏幕能显示的东西越细腻，显示的效果会越好。但是标准的制定者似乎也想到另一个观点，屏幕的尺寸越大，大家观看屏幕的距离也会变远，那么大屏幕的“点”稍微大一点也不成什么问题。\n\n所有的设计都是基于这个前提上进行的。所以 Windows 的所有窗口程序都是基于“像素”，也就是“点”的数量这一概念。所有的程序只需要告诉系统，我的窗口是 300×200 大小的，在任何屏幕上显示都会是大约占屏幕1/4的地方，毫无问题。\n\n但是实际上，屏幕的发展却像另外一个方向行进了。640×480 的分辨率做成的 15 或者 17 寸屏幕，人坐在一个合理的距离时，屏幕上面的点并没有小到肉眼不可辨啊，再加上 D-Sub 接口也完全兼容更高的分辨率，这么看来，显示完全可以向更细腻的方向发展。不久后市面上也出现了被称为 Super VGA（800×600）分辨率的屏幕，并且微软很快为 Windows 95 推出了SVGA的驱动程序，使之显示更为细腻。\n\n但是这时候就出现了一个问题，原先我定义窗口大小是 640×480 的话能撑满屏幕，而现在却撑不满了。但是实际想想 800×600 虽然比 640×480 大，但却没大多少，对体验的影响并不大，所以没有引起很大的重视。但是后来推出了 XVGA 的屏幕，也就是 1024×768 的分辨率。但是此时其实也没大多少，再加上 640×480 已经基本淘汰，开发者以 800×600 和 1024×768 为标准就可以了。这个时候大概是 Windows XP 开始盛行的时代。\n\n![](http://cdn.heckpsi.com/928_3.jpg)\n\n各大系统厂商在这几年里开始慢慢发现问题的严重性， 1024×768 慢慢变成了过去时，尤其是越来越多的宽屏分辨率的出现，连 4:3 的比例都不是了，屏幕分辨率多得越来越离奇了，1920×1080 的全高清更是比 640×480 不知道大到哪里去了。所以大家似乎都意识到，光靠基于像素的界面再下去，在不同显示器上的显示效果会很糟糕，于是都推出了不同的方案。\n\n比如苹果的 Mac OS X 10.4 Tiger（2005年4月29日上市）就把整个设计模式都进行了质的变化，XCode 2.0 中采用了全新的视觉模型。视觉是完全基于DPI（即每一英寸有多少个像素点）这样一个比例值为基础来设计的。这一关系更是在之后每一代的 OS X 中得到了强化。但是这种翻天覆地的变化带来一个很不好的结果就是：很差的向后兼容性。这意味着为旧版本 Mac OS X 设计的程序很可能不能在新版本的系统上运行。这一点来说非常糟糕。\n\n![](http://cdn.heckpsi.com/928_4.jpg)\n\n尤其是 Windows 这样面对着大量商业用户的操作系统而言，绝对不能这样做。但是，分辨率的问题也要解决。虽然 XP 下也能调节 DPI 来放大或缩小，但是那种放大镜式的调节，显示效果只能用恶心来形容。于是微软在 Windows Vista 上也试图在保证可运行旧程序这一兼容性要求下引入可变化的DPI模式。这个功能无需原有的软件做任何更改，完全是系统级别的放大和缩小的处理。听起来似乎很有道理，但是依然有两点问题。第一、这个功能藏得深得根本找不到，也没有明确的引导。第二、有些应用的显示尤其是字体的显示会直接错位，这点体验很糟糕。\n\n![](http://cdn.heckpsi.com/928_5.gif)\n\n到了 Windows 7 再到 Windows 8 之后，微软不断地完善了这一项功能，至少它现在基本能用了，也成为了一个默认功能。当你的屏幕尺寸比饺小而分辨率很高时，安装完系统就会默认调高你的 DPI 值以获得更好的显示效果，而不会是基于简单的像素把内容显示在很小一坨。但是，这一功能的兼容性，还是有限的。对于一些完完全全基于像素写的旧软件，如果系统强制放大了内容，可能会导致错位，就像在 Windows Vista 上那样，而如今微软选择，彻底不去动它们。于是，就会有各位在高分屏上安装个 Photoshop 7.0 出现了各种小的可怜的图标，以及其它一些旧程序的显示问题。\n\n当然，微软这么做也是实在出于无奈。Windows 的应用范围如此之广，从地铁的闸机到银行的 ATM 机，从电子广告屏到你手中的 PC，都可能是 Windows。如果搞一个像苹果那样的大清洗，估计大家都没有兴趣升级新系统了，这卖不掉可才会变成更大的问题。进退两难之中，又要做好基于dpi的显示功能，又要做好对之前程序的兼容，也许对于旧程序，能运行和使用，但显示效果不是很好也算是一个权宜之策、无奈之举吧。\n\n","slug":"things-about-dpi","published":1,"updated":"2016-05-15T03:20:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscy009n001app8za8fd1nmh","content":"<p>为什么这个软件在其他电脑上运行时很正常，而到我电脑上的界面/字体/图片会显示得很小？这个问题，大概是在13年前第一次被人问及。第一次被问到这个问题的时候是感觉别人的电脑玩 Windows 98 自带的纸牌竟是撑满整个屏幕的，而在这台电脑上却空出了很大的空间，即使是最大化这个窗口，显示的牌的大小也很小。而最近更多的则是一些软件，比如旧版本的 Photoshop 之类图标小得根本没法点究竟是什么原因？</p>\n<p><img src=\"http://cdn.heckpsi.com/928_1.jpg\" alt=\"\"></p>\n<a id=\"more\"></a>\n<p>当然，其实这些问题从原理上来说是殊途同归，同一个问题。而且这个问题是历史遗留问题，这一遗留，已经留了 28 年了。1987 年的一个晚上，IBM 的工程师制定了一种叫做VGA (Video Graphics Array) 的视频传输标准。这是一种模拟信号的传输标准，旨在创造一种统一的视频传输的方式。这个标准下包括了我们目前也依然在使用的 D-Sub 接口（也就是俗称的 VGA 接口），一套通讯的协议，以及当时制定的最基础的视频制式和它的分辨率：640×480。这个标准被广泛应用，以至于当时计算机最常用的分辨率都是 640×480。</p>\n<p>Windows 95 的设计当时默认了一个前提，那就是 PC 使用的是640×480的分辨率，这当时看来似乎没有太大的问题。那么既然大家分辨率差不多，那屏幕尺寸的大小相当于等大地“放大”或“缩小”屏幕上的东西。</p>\n<p><img src=\"http://cdn.heckpsi.com/928_2.png\" alt=\"\"></p>\n<p>为了方便理解这个概念。我们需要进一步阐释一下分辨率的概念。分辨率指屏幕上显示多少个“点”。比如 640×480 值得就是屏幕上每一行显示 640 个点，而一共显示 480 行。如果这个屏幕比较大，那么这个“点”会变得更大一些，以使得总的显示的点数要维持在 640×480 这个数字上以符合标准。虽然显然地，这个点的尺寸越小，屏幕能显示的东西越细腻，显示的效果会越好。但是标准的制定者似乎也想到另一个观点，屏幕的尺寸越大，大家观看屏幕的距离也会变远，那么大屏幕的“点”稍微大一点也不成什么问题。</p>\n<p>所有的设计都是基于这个前提上进行的。所以 Windows 的所有窗口程序都是基于“像素”，也就是“点”的数量这一概念。所有的程序只需要告诉系统，我的窗口是 300×200 大小的，在任何屏幕上显示都会是大约占屏幕1/4的地方，毫无问题。</p>\n<p>但是实际上，屏幕的发展却像另外一个方向行进了。640×480 的分辨率做成的 15 或者 17 寸屏幕，人坐在一个合理的距离时，屏幕上面的点并没有小到肉眼不可辨啊，再加上 D-Sub 接口也完全兼容更高的分辨率，这么看来，显示完全可以向更细腻的方向发展。不久后市面上也出现了被称为 Super VGA（800×600）分辨率的屏幕，并且微软很快为 Windows 95 推出了SVGA的驱动程序，使之显示更为细腻。</p>\n<p>但是这时候就出现了一个问题，原先我定义窗口大小是 640×480 的话能撑满屏幕，而现在却撑不满了。但是实际想想 800×600 虽然比 640×480 大，但却没大多少，对体验的影响并不大，所以没有引起很大的重视。但是后来推出了 XVGA 的屏幕，也就是 1024×768 的分辨率。但是此时其实也没大多少，再加上 640×480 已经基本淘汰，开发者以 800×600 和 1024×768 为标准就可以了。这个时候大概是 Windows XP 开始盛行的时代。</p>\n<p><img src=\"http://cdn.heckpsi.com/928_3.jpg\" alt=\"\"></p>\n<p>各大系统厂商在这几年里开始慢慢发现问题的严重性， 1024×768 慢慢变成了过去时，尤其是越来越多的宽屏分辨率的出现，连 4:3 的比例都不是了，屏幕分辨率多得越来越离奇了，1920×1080 的全高清更是比 640×480 不知道大到哪里去了。所以大家似乎都意识到，光靠基于像素的界面再下去，在不同显示器上的显示效果会很糟糕，于是都推出了不同的方案。</p>\n<p>比如苹果的 Mac OS X 10.4 Tiger（2005年4月29日上市）就把整个设计模式都进行了质的变化，XCode 2.0 中采用了全新的视觉模型。视觉是完全基于DPI（即每一英寸有多少个像素点）这样一个比例值为基础来设计的。这一关系更是在之后每一代的 OS X 中得到了强化。但是这种翻天覆地的变化带来一个很不好的结果就是：很差的向后兼容性。这意味着为旧版本 Mac OS X 设计的程序很可能不能在新版本的系统上运行。这一点来说非常糟糕。</p>\n<p><img src=\"http://cdn.heckpsi.com/928_4.jpg\" alt=\"\"></p>\n<p>尤其是 Windows 这样面对着大量商业用户的操作系统而言，绝对不能这样做。但是，分辨率的问题也要解决。虽然 XP 下也能调节 DPI 来放大或缩小，但是那种放大镜式的调节，显示效果只能用恶心来形容。于是微软在 Windows Vista 上也试图在保证可运行旧程序这一兼容性要求下引入可变化的DPI模式。这个功能无需原有的软件做任何更改，完全是系统级别的放大和缩小的处理。听起来似乎很有道理，但是依然有两点问题。第一、这个功能藏得深得根本找不到，也没有明确的引导。第二、有些应用的显示尤其是字体的显示会直接错位，这点体验很糟糕。</p>\n<p><img src=\"http://cdn.heckpsi.com/928_5.gif\" alt=\"\"></p>\n<p>到了 Windows 7 再到 Windows 8 之后，微软不断地完善了这一项功能，至少它现在基本能用了，也成为了一个默认功能。当你的屏幕尺寸比饺小而分辨率很高时，安装完系统就会默认调高你的 DPI 值以获得更好的显示效果，而不会是基于简单的像素把内容显示在很小一坨。但是，这一功能的兼容性，还是有限的。对于一些完完全全基于像素写的旧软件，如果系统强制放大了内容，可能会导致错位，就像在 Windows Vista 上那样，而如今微软选择，彻底不去动它们。于是，就会有各位在高分屏上安装个 Photoshop 7.0 出现了各种小的可怜的图标，以及其它一些旧程序的显示问题。</p>\n<p>当然，微软这么做也是实在出于无奈。Windows 的应用范围如此之广，从地铁的闸机到银行的 ATM 机，从电子广告屏到你手中的 PC，都可能是 Windows。如果搞一个像苹果那样的大清洗，估计大家都没有兴趣升级新系统了，这卖不掉可才会变成更大的问题。进退两难之中，又要做好基于dpi的显示功能，又要做好对之前程序的兼容，也许对于旧程序，能运行和使用，但显示效果不是很好也算是一个权宜之策、无奈之举吧。</p>\n","excerpt":"<p>为什么这个软件在其他电脑上运行时很正常，而到我电脑上的界面/字体/图片会显示得很小？这个问题，大概是在13年前第一次被人问及。第一次被问到这个问题的时候是感觉别人的电脑玩 Windows 98 自带的纸牌竟是撑满整个屏幕的，而在这台电脑上却空出了很大的空间，即使是最大化这个窗口，显示的牌的大小也很小。而最近更多的则是一些软件，比如旧版本的 Photoshop 之类图标小得根本没法点究竟是什么原因？</p>\n<p><img src=\"http://cdn.heckpsi.com/928_1.jpg\" alt=\"\"></p>","more":"<p>当然，其实这些问题从原理上来说是殊途同归，同一个问题。而且这个问题是历史遗留问题，这一遗留，已经留了 28 年了。1987 年的一个晚上，IBM 的工程师制定了一种叫做VGA (Video Graphics Array) 的视频传输标准。这是一种模拟信号的传输标准，旨在创造一种统一的视频传输的方式。这个标准下包括了我们目前也依然在使用的 D-Sub 接口（也就是俗称的 VGA 接口），一套通讯的协议，以及当时制定的最基础的视频制式和它的分辨率：640×480。这个标准被广泛应用，以至于当时计算机最常用的分辨率都是 640×480。</p>\n<p>Windows 95 的设计当时默认了一个前提，那就是 PC 使用的是640×480的分辨率，这当时看来似乎没有太大的问题。那么既然大家分辨率差不多，那屏幕尺寸的大小相当于等大地“放大”或“缩小”屏幕上的东西。</p>\n<p><img src=\"http://cdn.heckpsi.com/928_2.png\" alt=\"\"></p>\n<p>为了方便理解这个概念。我们需要进一步阐释一下分辨率的概念。分辨率指屏幕上显示多少个“点”。比如 640×480 值得就是屏幕上每一行显示 640 个点，而一共显示 480 行。如果这个屏幕比较大，那么这个“点”会变得更大一些，以使得总的显示的点数要维持在 640×480 这个数字上以符合标准。虽然显然地，这个点的尺寸越小，屏幕能显示的东西越细腻，显示的效果会越好。但是标准的制定者似乎也想到另一个观点，屏幕的尺寸越大，大家观看屏幕的距离也会变远，那么大屏幕的“点”稍微大一点也不成什么问题。</p>\n<p>所有的设计都是基于这个前提上进行的。所以 Windows 的所有窗口程序都是基于“像素”，也就是“点”的数量这一概念。所有的程序只需要告诉系统，我的窗口是 300×200 大小的，在任何屏幕上显示都会是大约占屏幕1/4的地方，毫无问题。</p>\n<p>但是实际上，屏幕的发展却像另外一个方向行进了。640×480 的分辨率做成的 15 或者 17 寸屏幕，人坐在一个合理的距离时，屏幕上面的点并没有小到肉眼不可辨啊，再加上 D-Sub 接口也完全兼容更高的分辨率，这么看来，显示完全可以向更细腻的方向发展。不久后市面上也出现了被称为 Super VGA（800×600）分辨率的屏幕，并且微软很快为 Windows 95 推出了SVGA的驱动程序，使之显示更为细腻。</p>\n<p>但是这时候就出现了一个问题，原先我定义窗口大小是 640×480 的话能撑满屏幕，而现在却撑不满了。但是实际想想 800×600 虽然比 640×480 大，但却没大多少，对体验的影响并不大，所以没有引起很大的重视。但是后来推出了 XVGA 的屏幕，也就是 1024×768 的分辨率。但是此时其实也没大多少，再加上 640×480 已经基本淘汰，开发者以 800×600 和 1024×768 为标准就可以了。这个时候大概是 Windows XP 开始盛行的时代。</p>\n<p><img src=\"http://cdn.heckpsi.com/928_3.jpg\" alt=\"\"></p>\n<p>各大系统厂商在这几年里开始慢慢发现问题的严重性， 1024×768 慢慢变成了过去时，尤其是越来越多的宽屏分辨率的出现，连 4:3 的比例都不是了，屏幕分辨率多得越来越离奇了，1920×1080 的全高清更是比 640×480 不知道大到哪里去了。所以大家似乎都意识到，光靠基于像素的界面再下去，在不同显示器上的显示效果会很糟糕，于是都推出了不同的方案。</p>\n<p>比如苹果的 Mac OS X 10.4 Tiger（2005年4月29日上市）就把整个设计模式都进行了质的变化，XCode 2.0 中采用了全新的视觉模型。视觉是完全基于DPI（即每一英寸有多少个像素点）这样一个比例值为基础来设计的。这一关系更是在之后每一代的 OS X 中得到了强化。但是这种翻天覆地的变化带来一个很不好的结果就是：很差的向后兼容性。这意味着为旧版本 Mac OS X 设计的程序很可能不能在新版本的系统上运行。这一点来说非常糟糕。</p>\n<p><img src=\"http://cdn.heckpsi.com/928_4.jpg\" alt=\"\"></p>\n<p>尤其是 Windows 这样面对着大量商业用户的操作系统而言，绝对不能这样做。但是，分辨率的问题也要解决。虽然 XP 下也能调节 DPI 来放大或缩小，但是那种放大镜式的调节，显示效果只能用恶心来形容。于是微软在 Windows Vista 上也试图在保证可运行旧程序这一兼容性要求下引入可变化的DPI模式。这个功能无需原有的软件做任何更改，完全是系统级别的放大和缩小的处理。听起来似乎很有道理，但是依然有两点问题。第一、这个功能藏得深得根本找不到，也没有明确的引导。第二、有些应用的显示尤其是字体的显示会直接错位，这点体验很糟糕。</p>\n<p><img src=\"http://cdn.heckpsi.com/928_5.gif\" alt=\"\"></p>\n<p>到了 Windows 7 再到 Windows 8 之后，微软不断地完善了这一项功能，至少它现在基本能用了，也成为了一个默认功能。当你的屏幕尺寸比饺小而分辨率很高时，安装完系统就会默认调高你的 DPI 值以获得更好的显示效果，而不会是基于简单的像素把内容显示在很小一坨。但是，这一功能的兼容性，还是有限的。对于一些完完全全基于像素写的旧软件，如果系统强制放大了内容，可能会导致错位，就像在 Windows Vista 上那样，而如今微软选择，彻底不去动它们。于是，就会有各位在高分屏上安装个 Photoshop 7.0 出现了各种小的可怜的图标，以及其它一些旧程序的显示问题。</p>\n<p>当然，微软这么做也是实在出于无奈。Windows 的应用范围如此之广，从地铁的闸机到银行的 ATM 机，从电子广告屏到你手中的 PC，都可能是 Windows。如果搞一个像苹果那样的大清洗，估计大家都没有兴趣升级新系统了，这卖不掉可才会变成更大的问题。进退两难之中，又要做好基于dpi的显示功能，又要做好对之前程序的兼容，也许对于旧程序，能运行和使用，但显示效果不是很好也算是一个权宜之策、无奈之举吧。</p>"},{"title":"流量 “降价” 真假背后的疑团","date":"2015-05-15T14:46:09.000Z","_content":"\n在李克强几次三番的督促下，中国三大电信运营商制定出了他们的流量降价策略。在网民一片叫好的背后，事情真的是那么简单吗？李克强的几句话是真的促成了运营商的降价惠及了广大消费者？还是把朝三暮四和朝四暮三这样偷梁换柱的把戏呢？\n\n要回答这个问题，我们要从一个非常重要的问题出发，流量“降价”究竟谁获利了？\n\n<!--more-->\n\n说到流量降价，我们第一个能想到的当然是消费者获利了。要么是同样多的流量现在更便宜了，或者是同样多的钱可以买到更多的流量了。但实际上真的是这样吗？我们以中国移动的流量改革为例，推出了 10 元 1GB 的夜间流量包、假日流量包，以及 50 元 2GB 的全国流量包。以最后一个全国流量包为例，0.025 元/MB 的资费和之前移动的 4G 资费基本持平，甚至还并不是最便宜的价钱。而前两个套餐基本属于摆设。晚上在家睡觉 Wi-Fi 用的好好的，4G 流量我还嫌 LTE 网络费电呢！从这个角度来看，消费者并没有实际获取到利益，流量什么价钱基本没有变化，日常在流量上的花费不会减少。\n\n终端用户没有获取到实际的利益，那么运营商获利了？可能。如果消费者和朝三暮四故事里那 “众狙皆伏而喜” 的猕猴一样愚蠢那么运营商倒是确实可以多赚钱。因为消费者以为已经便宜了，可能会购买新的根本没有什么用的套餐。但我相信，消费者也不至于那么愚蠢。毕竟这每个月网费可是实实足足的数目，多了少了自己心里最清楚。\n\n那么最终获利的是谁呢？排除掉消费者和运营商，最终获利的很容易判断出来，那就是政府。这点听起来似乎不太对，政府督促运营商网费下降怎么最后获利的是政府了呢？我们来思考一下。李克强督促运营商降价，你觉得李克强是不是在为消费者着想，你是否感觉到了政府的 “作为”，加强了对政府的信赖？但相反，运营商最后没有达到实际的降价你责怪的是李克强吗？不，你责怪的是运营商。你觉得运营商应付国家、忽悠用户，运营商背下了沉重的黑锅而政府却收获了信任，看起来是多么地和谐啊~\n\n但我们仔细分析一下这件事情的来龙去脉究竟是谁才应该背下这口锅？这个问题的核心在于，运营商为什么嘴上答应着降价，实际却没有什么作为呢？翻开中国移动 2014 年的 [年报](http://www.chinamobileltd.com/sc/ir/reports/ar2014.pdf) ，我们似乎可以寻找一点答案。首先，中国移动作为国企，但并不是完全的国有资本，它是股份制的上市公司，采取资本的运作方式，作为公司，它也是要自负盈亏的。\n\n2014 年全年中国移动运营支出 5241 亿人民币，收入 6414 亿人民币。有媒体报道中国移动每天净赚 3 亿这件事确实不假，但看看这个基数，其实也很正常。但问题是，这里面的钱具体是怎么回事呢？收入的最大大头是语音通讯和短信这样的基础通讯业务，收入 3089 亿人民币。而数据业务，也就是我们平时的流量业务，收入 2530 亿人民币。听起来是不是很大，但是我们同时来看一下，支撑流量业务的 4G 基站、传输网等的建设投入了多少？资本支出 2135 亿元。这部分并没有计入运营支出中，如果算上的话，其实 2014 年中国移动是严重亏损的，但不过这些建设都属于资产，除了折旧部分计入成本确实也不该计入进去。流量业务收入 2530 亿，然而建设网络就花去了 2135 亿，丝毫没有见到这是暴利。很多人说，4G 网络建设是一次性投入，但事实上每年还需要维护、耗电，而且近几年 4G 网络基础建设还会继续推进，花钱根本停不下来。\n\n那么第一个问题来了？成本为什么压不下来？\n\n这个问题的答案得问工信部。2008年，工信部以 “平衡三家运营商实力” 为由，将最不受国际接受的 3G 标准 TD-SCDMA 颁发给中国移动，导致大量用户有网无机，根本换不上支持这种制式的手机。同时把最受国际接受的 WCDMA 标准颁发给了当时最弱的中国联通。但 WCDMA 是国外的标准，整个标准框架下包含了大量海外专利，建造成本比较高。所以当时，移动 3G 看似资费便宜，实际没法用，联通 3G 资费较贵，用户不敢用，这导致中国 3G 产业发展实际上非常慢。\n\n然而当工信部颁发了 4G 牌照之后，移动立马停止了这个光会花钱而赚不到钱的 TD-SCDMA 基站的建设，全面推进 4G 网络建设，因为输了 3G 的移动，已经不能再输 4G 了。同样，其它运营商则绞尽脑汁从别的方面着手，比如联通和电信大量试点 FDD-LTE 标准来支持更多海外手机以占据市场。在这种高密集的基站建设下，流量成本只会提升不会下降。但是相反的，4G 流量不但不比 3G 流量贵，反而更便宜。事实上，4G 流量的价格和海外比起来并不昂贵，而是和海外是基本持平的，考虑到之前 3G 事件引发各运营商疯狂地建基站计划，成本比海外更高，盈利空间非常小，很难挤压出降价的区间，并不能以国内消费水平低就一概而论 4G 就是有降价空间的。\n\n那么也就是说，政府在运营商无力降价的情况下要求降价，这点又是做给谁看的呢？\n\n做给猴看的。虽然运营商已经花了很大的努力使得价格降到和海外差不多，但无法更 “接地气”，这问题是谁造成的？是国家政府的决策部门，是颁发牌照负责监管的 “工信部”，做出了错误的决定，导致了严重的后果。但是国家并不承认，而是把责任推脱给运营商，称 “为什么不能更便宜？” 如果我们是自由的市场经济，当然可以便宜。但在一个被看似暴利垄断的通讯行业，在一次次的放权后，每个运营商早已褪去了过去的光环，已经沦落为只不过是给政府打工的的打工仔，究竟是谁不想降价呢？谁降价谁就有更多用户占得更大的市场，谁不想呢？\n\n而消费者确实觉得价格不够接地气，那么他们会责怪谁？再联系到今年整体疲软的中国经济、并不很成功的自贸区试验、试图搞虚拟运营商实际上却没有给他们足够权限、产业转型开展也并不顺利。不作为、无能的政府？很可能。那么在此之前，先做出总理多次批示降价，而运营商不作为这样一出戏出来，煽动舆论压力，转移消费者的怒火，把这种不满发泄在运营商上。这可真是一场好戏啊。\n\n从这种角度上面来看，只有放开真正的市场自由才能从根本上解决问题。否则就算今天 4G 资费是真降，明天 5G 照样给你涨回来。放开运营商的牌照限制？放开基础设施建设的限制？自贸区放开了文化部跟着一起放开？从技术资金上去扶植产业转型而不是靠处罚和税收？只有这些才能从根本上解决问题。\n\n否则的话，那只能是一个个美好的卫星，和一张张美好的空头支票。\n\n","source":"_posts/things-behind-price-down-of-data.md","raw":"---\ntitle: 流量 “降价” 真假背后的疑团\ndate: 2015-05-15 22:46:09\ntags: [通讯]\n---\n\n在李克强几次三番的督促下，中国三大电信运营商制定出了他们的流量降价策略。在网民一片叫好的背后，事情真的是那么简单吗？李克强的几句话是真的促成了运营商的降价惠及了广大消费者？还是把朝三暮四和朝四暮三这样偷梁换柱的把戏呢？\n\n要回答这个问题，我们要从一个非常重要的问题出发，流量“降价”究竟谁获利了？\n\n<!--more-->\n\n说到流量降价，我们第一个能想到的当然是消费者获利了。要么是同样多的流量现在更便宜了，或者是同样多的钱可以买到更多的流量了。但实际上真的是这样吗？我们以中国移动的流量改革为例，推出了 10 元 1GB 的夜间流量包、假日流量包，以及 50 元 2GB 的全国流量包。以最后一个全国流量包为例，0.025 元/MB 的资费和之前移动的 4G 资费基本持平，甚至还并不是最便宜的价钱。而前两个套餐基本属于摆设。晚上在家睡觉 Wi-Fi 用的好好的，4G 流量我还嫌 LTE 网络费电呢！从这个角度来看，消费者并没有实际获取到利益，流量什么价钱基本没有变化，日常在流量上的花费不会减少。\n\n终端用户没有获取到实际的利益，那么运营商获利了？可能。如果消费者和朝三暮四故事里那 “众狙皆伏而喜” 的猕猴一样愚蠢那么运营商倒是确实可以多赚钱。因为消费者以为已经便宜了，可能会购买新的根本没有什么用的套餐。但我相信，消费者也不至于那么愚蠢。毕竟这每个月网费可是实实足足的数目，多了少了自己心里最清楚。\n\n那么最终获利的是谁呢？排除掉消费者和运营商，最终获利的很容易判断出来，那就是政府。这点听起来似乎不太对，政府督促运营商网费下降怎么最后获利的是政府了呢？我们来思考一下。李克强督促运营商降价，你觉得李克强是不是在为消费者着想，你是否感觉到了政府的 “作为”，加强了对政府的信赖？但相反，运营商最后没有达到实际的降价你责怪的是李克强吗？不，你责怪的是运营商。你觉得运营商应付国家、忽悠用户，运营商背下了沉重的黑锅而政府却收获了信任，看起来是多么地和谐啊~\n\n但我们仔细分析一下这件事情的来龙去脉究竟是谁才应该背下这口锅？这个问题的核心在于，运营商为什么嘴上答应着降价，实际却没有什么作为呢？翻开中国移动 2014 年的 [年报](http://www.chinamobileltd.com/sc/ir/reports/ar2014.pdf) ，我们似乎可以寻找一点答案。首先，中国移动作为国企，但并不是完全的国有资本，它是股份制的上市公司，采取资本的运作方式，作为公司，它也是要自负盈亏的。\n\n2014 年全年中国移动运营支出 5241 亿人民币，收入 6414 亿人民币。有媒体报道中国移动每天净赚 3 亿这件事确实不假，但看看这个基数，其实也很正常。但问题是，这里面的钱具体是怎么回事呢？收入的最大大头是语音通讯和短信这样的基础通讯业务，收入 3089 亿人民币。而数据业务，也就是我们平时的流量业务，收入 2530 亿人民币。听起来是不是很大，但是我们同时来看一下，支撑流量业务的 4G 基站、传输网等的建设投入了多少？资本支出 2135 亿元。这部分并没有计入运营支出中，如果算上的话，其实 2014 年中国移动是严重亏损的，但不过这些建设都属于资产，除了折旧部分计入成本确实也不该计入进去。流量业务收入 2530 亿，然而建设网络就花去了 2135 亿，丝毫没有见到这是暴利。很多人说，4G 网络建设是一次性投入，但事实上每年还需要维护、耗电，而且近几年 4G 网络基础建设还会继续推进，花钱根本停不下来。\n\n那么第一个问题来了？成本为什么压不下来？\n\n这个问题的答案得问工信部。2008年，工信部以 “平衡三家运营商实力” 为由，将最不受国际接受的 3G 标准 TD-SCDMA 颁发给中国移动，导致大量用户有网无机，根本换不上支持这种制式的手机。同时把最受国际接受的 WCDMA 标准颁发给了当时最弱的中国联通。但 WCDMA 是国外的标准，整个标准框架下包含了大量海外专利，建造成本比较高。所以当时，移动 3G 看似资费便宜，实际没法用，联通 3G 资费较贵，用户不敢用，这导致中国 3G 产业发展实际上非常慢。\n\n然而当工信部颁发了 4G 牌照之后，移动立马停止了这个光会花钱而赚不到钱的 TD-SCDMA 基站的建设，全面推进 4G 网络建设，因为输了 3G 的移动，已经不能再输 4G 了。同样，其它运营商则绞尽脑汁从别的方面着手，比如联通和电信大量试点 FDD-LTE 标准来支持更多海外手机以占据市场。在这种高密集的基站建设下，流量成本只会提升不会下降。但是相反的，4G 流量不但不比 3G 流量贵，反而更便宜。事实上，4G 流量的价格和海外比起来并不昂贵，而是和海外是基本持平的，考虑到之前 3G 事件引发各运营商疯狂地建基站计划，成本比海外更高，盈利空间非常小，很难挤压出降价的区间，并不能以国内消费水平低就一概而论 4G 就是有降价空间的。\n\n那么也就是说，政府在运营商无力降价的情况下要求降价，这点又是做给谁看的呢？\n\n做给猴看的。虽然运营商已经花了很大的努力使得价格降到和海外差不多，但无法更 “接地气”，这问题是谁造成的？是国家政府的决策部门，是颁发牌照负责监管的 “工信部”，做出了错误的决定，导致了严重的后果。但是国家并不承认，而是把责任推脱给运营商，称 “为什么不能更便宜？” 如果我们是自由的市场经济，当然可以便宜。但在一个被看似暴利垄断的通讯行业，在一次次的放权后，每个运营商早已褪去了过去的光环，已经沦落为只不过是给政府打工的的打工仔，究竟是谁不想降价呢？谁降价谁就有更多用户占得更大的市场，谁不想呢？\n\n而消费者确实觉得价格不够接地气，那么他们会责怪谁？再联系到今年整体疲软的中国经济、并不很成功的自贸区试验、试图搞虚拟运营商实际上却没有给他们足够权限、产业转型开展也并不顺利。不作为、无能的政府？很可能。那么在此之前，先做出总理多次批示降价，而运营商不作为这样一出戏出来，煽动舆论压力，转移消费者的怒火，把这种不满发泄在运营商上。这可真是一场好戏啊。\n\n从这种角度上面来看，只有放开真正的市场自由才能从根本上解决问题。否则就算今天 4G 资费是真降，明天 5G 照样给你涨回来。放开运营商的牌照限制？放开基础设施建设的限制？自贸区放开了文化部跟着一起放开？从技术资金上去扶植产业转型而不是靠处罚和税收？只有这些才能从根本上解决问题。\n\n否则的话，那只能是一个个美好的卫星，和一张张美好的空头支票。\n\n","slug":"things-behind-price-down-of-data","published":1,"updated":"2016-04-23T13:11:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscy009r001bpp8zi0p57gzm","content":"<p>在李克强几次三番的督促下，中国三大电信运营商制定出了他们的流量降价策略。在网民一片叫好的背后，事情真的是那么简单吗？李克强的几句话是真的促成了运营商的降价惠及了广大消费者？还是把朝三暮四和朝四暮三这样偷梁换柱的把戏呢？</p>\n<p>要回答这个问题，我们要从一个非常重要的问题出发，流量“降价”究竟谁获利了？</p>\n<a id=\"more\"></a>\n<p>说到流量降价，我们第一个能想到的当然是消费者获利了。要么是同样多的流量现在更便宜了，或者是同样多的钱可以买到更多的流量了。但实际上真的是这样吗？我们以中国移动的流量改革为例，推出了 10 元 1GB 的夜间流量包、假日流量包，以及 50 元 2GB 的全国流量包。以最后一个全国流量包为例，0.025 元/MB 的资费和之前移动的 4G 资费基本持平，甚至还并不是最便宜的价钱。而前两个套餐基本属于摆设。晚上在家睡觉 Wi-Fi 用的好好的，4G 流量我还嫌 LTE 网络费电呢！从这个角度来看，消费者并没有实际获取到利益，流量什么价钱基本没有变化，日常在流量上的花费不会减少。</p>\n<p>终端用户没有获取到实际的利益，那么运营商获利了？可能。如果消费者和朝三暮四故事里那 “众狙皆伏而喜” 的猕猴一样愚蠢那么运营商倒是确实可以多赚钱。因为消费者以为已经便宜了，可能会购买新的根本没有什么用的套餐。但我相信，消费者也不至于那么愚蠢。毕竟这每个月网费可是实实足足的数目，多了少了自己心里最清楚。</p>\n<p>那么最终获利的是谁呢？排除掉消费者和运营商，最终获利的很容易判断出来，那就是政府。这点听起来似乎不太对，政府督促运营商网费下降怎么最后获利的是政府了呢？我们来思考一下。李克强督促运营商降价，你觉得李克强是不是在为消费者着想，你是否感觉到了政府的 “作为”，加强了对政府的信赖？但相反，运营商最后没有达到实际的降价你责怪的是李克强吗？不，你责怪的是运营商。你觉得运营商应付国家、忽悠用户，运营商背下了沉重的黑锅而政府却收获了信任，看起来是多么地和谐啊~</p>\n<p>但我们仔细分析一下这件事情的来龙去脉究竟是谁才应该背下这口锅？这个问题的核心在于，运营商为什么嘴上答应着降价，实际却没有什么作为呢？翻开中国移动 2014 年的 <a href=\"http://www.chinamobileltd.com/sc/ir/reports/ar2014.pdf\" target=\"_blank\" rel=\"external\">年报</a> ，我们似乎可以寻找一点答案。首先，中国移动作为国企，但并不是完全的国有资本，它是股份制的上市公司，采取资本的运作方式，作为公司，它也是要自负盈亏的。</p>\n<p>2014 年全年中国移动运营支出 5241 亿人民币，收入 6414 亿人民币。有媒体报道中国移动每天净赚 3 亿这件事确实不假，但看看这个基数，其实也很正常。但问题是，这里面的钱具体是怎么回事呢？收入的最大大头是语音通讯和短信这样的基础通讯业务，收入 3089 亿人民币。而数据业务，也就是我们平时的流量业务，收入 2530 亿人民币。听起来是不是很大，但是我们同时来看一下，支撑流量业务的 4G 基站、传输网等的建设投入了多少？资本支出 2135 亿元。这部分并没有计入运营支出中，如果算上的话，其实 2014 年中国移动是严重亏损的，但不过这些建设都属于资产，除了折旧部分计入成本确实也不该计入进去。流量业务收入 2530 亿，然而建设网络就花去了 2135 亿，丝毫没有见到这是暴利。很多人说，4G 网络建设是一次性投入，但事实上每年还需要维护、耗电，而且近几年 4G 网络基础建设还会继续推进，花钱根本停不下来。</p>\n<p>那么第一个问题来了？成本为什么压不下来？</p>\n<p>这个问题的答案得问工信部。2008年，工信部以 “平衡三家运营商实力” 为由，将最不受国际接受的 3G 标准 TD-SCDMA 颁发给中国移动，导致大量用户有网无机，根本换不上支持这种制式的手机。同时把最受国际接受的 WCDMA 标准颁发给了当时最弱的中国联通。但 WCDMA 是国外的标准，整个标准框架下包含了大量海外专利，建造成本比较高。所以当时，移动 3G 看似资费便宜，实际没法用，联通 3G 资费较贵，用户不敢用，这导致中国 3G 产业发展实际上非常慢。</p>\n<p>然而当工信部颁发了 4G 牌照之后，移动立马停止了这个光会花钱而赚不到钱的 TD-SCDMA 基站的建设，全面推进 4G 网络建设，因为输了 3G 的移动，已经不能再输 4G 了。同样，其它运营商则绞尽脑汁从别的方面着手，比如联通和电信大量试点 FDD-LTE 标准来支持更多海外手机以占据市场。在这种高密集的基站建设下，流量成本只会提升不会下降。但是相反的，4G 流量不但不比 3G 流量贵，反而更便宜。事实上，4G 流量的价格和海外比起来并不昂贵，而是和海外是基本持平的，考虑到之前 3G 事件引发各运营商疯狂地建基站计划，成本比海外更高，盈利空间非常小，很难挤压出降价的区间，并不能以国内消费水平低就一概而论 4G 就是有降价空间的。</p>\n<p>那么也就是说，政府在运营商无力降价的情况下要求降价，这点又是做给谁看的呢？</p>\n<p>做给猴看的。虽然运营商已经花了很大的努力使得价格降到和海外差不多，但无法更 “接地气”，这问题是谁造成的？是国家政府的决策部门，是颁发牌照负责监管的 “工信部”，做出了错误的决定，导致了严重的后果。但是国家并不承认，而是把责任推脱给运营商，称 “为什么不能更便宜？” 如果我们是自由的市场经济，当然可以便宜。但在一个被看似暴利垄断的通讯行业，在一次次的放权后，每个运营商早已褪去了过去的光环，已经沦落为只不过是给政府打工的的打工仔，究竟是谁不想降价呢？谁降价谁就有更多用户占得更大的市场，谁不想呢？</p>\n<p>而消费者确实觉得价格不够接地气，那么他们会责怪谁？再联系到今年整体疲软的中国经济、并不很成功的自贸区试验、试图搞虚拟运营商实际上却没有给他们足够权限、产业转型开展也并不顺利。不作为、无能的政府？很可能。那么在此之前，先做出总理多次批示降价，而运营商不作为这样一出戏出来，煽动舆论压力，转移消费者的怒火，把这种不满发泄在运营商上。这可真是一场好戏啊。</p>\n<p>从这种角度上面来看，只有放开真正的市场自由才能从根本上解决问题。否则就算今天 4G 资费是真降，明天 5G 照样给你涨回来。放开运营商的牌照限制？放开基础设施建设的限制？自贸区放开了文化部跟着一起放开？从技术资金上去扶植产业转型而不是靠处罚和税收？只有这些才能从根本上解决问题。</p>\n<p>否则的话，那只能是一个个美好的卫星，和一张张美好的空头支票。</p>\n","excerpt":"<p>在李克强几次三番的督促下，中国三大电信运营商制定出了他们的流量降价策略。在网民一片叫好的背后，事情真的是那么简单吗？李克强的几句话是真的促成了运营商的降价惠及了广大消费者？还是把朝三暮四和朝四暮三这样偷梁换柱的把戏呢？</p>\n<p>要回答这个问题，我们要从一个非常重要的问题出发，流量“降价”究竟谁获利了？</p>","more":"<p>说到流量降价，我们第一个能想到的当然是消费者获利了。要么是同样多的流量现在更便宜了，或者是同样多的钱可以买到更多的流量了。但实际上真的是这样吗？我们以中国移动的流量改革为例，推出了 10 元 1GB 的夜间流量包、假日流量包，以及 50 元 2GB 的全国流量包。以最后一个全国流量包为例，0.025 元/MB 的资费和之前移动的 4G 资费基本持平，甚至还并不是最便宜的价钱。而前两个套餐基本属于摆设。晚上在家睡觉 Wi-Fi 用的好好的，4G 流量我还嫌 LTE 网络费电呢！从这个角度来看，消费者并没有实际获取到利益，流量什么价钱基本没有变化，日常在流量上的花费不会减少。</p>\n<p>终端用户没有获取到实际的利益，那么运营商获利了？可能。如果消费者和朝三暮四故事里那 “众狙皆伏而喜” 的猕猴一样愚蠢那么运营商倒是确实可以多赚钱。因为消费者以为已经便宜了，可能会购买新的根本没有什么用的套餐。但我相信，消费者也不至于那么愚蠢。毕竟这每个月网费可是实实足足的数目，多了少了自己心里最清楚。</p>\n<p>那么最终获利的是谁呢？排除掉消费者和运营商，最终获利的很容易判断出来，那就是政府。这点听起来似乎不太对，政府督促运营商网费下降怎么最后获利的是政府了呢？我们来思考一下。李克强督促运营商降价，你觉得李克强是不是在为消费者着想，你是否感觉到了政府的 “作为”，加强了对政府的信赖？但相反，运营商最后没有达到实际的降价你责怪的是李克强吗？不，你责怪的是运营商。你觉得运营商应付国家、忽悠用户，运营商背下了沉重的黑锅而政府却收获了信任，看起来是多么地和谐啊~</p>\n<p>但我们仔细分析一下这件事情的来龙去脉究竟是谁才应该背下这口锅？这个问题的核心在于，运营商为什么嘴上答应着降价，实际却没有什么作为呢？翻开中国移动 2014 年的 <a href=\"http://www.chinamobileltd.com/sc/ir/reports/ar2014.pdf\">年报</a> ，我们似乎可以寻找一点答案。首先，中国移动作为国企，但并不是完全的国有资本，它是股份制的上市公司，采取资本的运作方式，作为公司，它也是要自负盈亏的。</p>\n<p>2014 年全年中国移动运营支出 5241 亿人民币，收入 6414 亿人民币。有媒体报道中国移动每天净赚 3 亿这件事确实不假，但看看这个基数，其实也很正常。但问题是，这里面的钱具体是怎么回事呢？收入的最大大头是语音通讯和短信这样的基础通讯业务，收入 3089 亿人民币。而数据业务，也就是我们平时的流量业务，收入 2530 亿人民币。听起来是不是很大，但是我们同时来看一下，支撑流量业务的 4G 基站、传输网等的建设投入了多少？资本支出 2135 亿元。这部分并没有计入运营支出中，如果算上的话，其实 2014 年中国移动是严重亏损的，但不过这些建设都属于资产，除了折旧部分计入成本确实也不该计入进去。流量业务收入 2530 亿，然而建设网络就花去了 2135 亿，丝毫没有见到这是暴利。很多人说，4G 网络建设是一次性投入，但事实上每年还需要维护、耗电，而且近几年 4G 网络基础建设还会继续推进，花钱根本停不下来。</p>\n<p>那么第一个问题来了？成本为什么压不下来？</p>\n<p>这个问题的答案得问工信部。2008年，工信部以 “平衡三家运营商实力” 为由，将最不受国际接受的 3G 标准 TD-SCDMA 颁发给中国移动，导致大量用户有网无机，根本换不上支持这种制式的手机。同时把最受国际接受的 WCDMA 标准颁发给了当时最弱的中国联通。但 WCDMA 是国外的标准，整个标准框架下包含了大量海外专利，建造成本比较高。所以当时，移动 3G 看似资费便宜，实际没法用，联通 3G 资费较贵，用户不敢用，这导致中国 3G 产业发展实际上非常慢。</p>\n<p>然而当工信部颁发了 4G 牌照之后，移动立马停止了这个光会花钱而赚不到钱的 TD-SCDMA 基站的建设，全面推进 4G 网络建设，因为输了 3G 的移动，已经不能再输 4G 了。同样，其它运营商则绞尽脑汁从别的方面着手，比如联通和电信大量试点 FDD-LTE 标准来支持更多海外手机以占据市场。在这种高密集的基站建设下，流量成本只会提升不会下降。但是相反的，4G 流量不但不比 3G 流量贵，反而更便宜。事实上，4G 流量的价格和海外比起来并不昂贵，而是和海外是基本持平的，考虑到之前 3G 事件引发各运营商疯狂地建基站计划，成本比海外更高，盈利空间非常小，很难挤压出降价的区间，并不能以国内消费水平低就一概而论 4G 就是有降价空间的。</p>\n<p>那么也就是说，政府在运营商无力降价的情况下要求降价，这点又是做给谁看的呢？</p>\n<p>做给猴看的。虽然运营商已经花了很大的努力使得价格降到和海外差不多，但无法更 “接地气”，这问题是谁造成的？是国家政府的决策部门，是颁发牌照负责监管的 “工信部”，做出了错误的决定，导致了严重的后果。但是国家并不承认，而是把责任推脱给运营商，称 “为什么不能更便宜？” 如果我们是自由的市场经济，当然可以便宜。但在一个被看似暴利垄断的通讯行业，在一次次的放权后，每个运营商早已褪去了过去的光环，已经沦落为只不过是给政府打工的的打工仔，究竟是谁不想降价呢？谁降价谁就有更多用户占得更大的市场，谁不想呢？</p>\n<p>而消费者确实觉得价格不够接地气，那么他们会责怪谁？再联系到今年整体疲软的中国经济、并不很成功的自贸区试验、试图搞虚拟运营商实际上却没有给他们足够权限、产业转型开展也并不顺利。不作为、无能的政府？很可能。那么在此之前，先做出总理多次批示降价，而运营商不作为这样一出戏出来，煽动舆论压力，转移消费者的怒火，把这种不满发泄在运营商上。这可真是一场好戏啊。</p>\n<p>从这种角度上面来看，只有放开真正的市场自由才能从根本上解决问题。否则就算今天 4G 资费是真降，明天 5G 照样给你涨回来。放开运营商的牌照限制？放开基础设施建设的限制？自贸区放开了文化部跟着一起放开？从技术资金上去扶植产业转型而不是靠处罚和税收？只有这些才能从根本上解决问题。</p>\n<p>否则的话，那只能是一个个美好的卫星，和一张张美好的空头支票。</p>"},{"title":"DDoS 攻击究竟是什么东西？","date":"2015-01-17T07:35:37.000Z","_content":"\n最近既然这个名词很火，而很多参与这件事的人甚至都不知道这是什么东西，这对社会可能造成潜在的危害，所以有必要特意来说一下。\n\nDDoS，中文名字应该叫做 分布式拒绝服务攻击。不过这个中文名字听了就好像听不懂一样。啥是分布式？啥是拒绝服务攻击？那么要弄清DDoS之前，先要弄清一个概念，那就是DoS。\n\n<!--more-->\n这里说的DoS并不是DOS操作系统的DOS，Deny of Service，拒绝服务。这个攻击之所以能够成功，其实是得益于我们“愚蠢”却又是最常用和的互联网协议——包括IP协议、HTTP协议、ARP协议等。我们以HTTP协议为例，如果把这协议通俗化的话，可以用下面几个例子给大家看看：\n\n\n```\n用户：我想看baidu.com的内容\n服务器：接受。baidu.com的内容是XXXXXXXXX。\n\n用户：我想看baidu.com/qwqewqeqw的内容\n服务器：拒绝。找不到这样的文件。\n\n用户：我想发送“大家好”到weibo.com。\n服务器：拒绝。你没有登录。\n```\n\n大致就是这个样子的，就好像两个人在对话一样。但是大家有没有注意到一点，无论用户说什么，说的东西是对是错，服务器必须要回答。而DoS利用的正是这一个特性。DoS所做的工作就是：\n\n```\n攻击者：cxdasdascsca\n服务器：拒绝。我没听懂你在说啥？\n\n攻击者：dsasdasdasda\n服务器：拒绝。我没听懂你在说啥？\n\n......\n```\n\n\n在早期的攻击当中，这种攻击就是一种双方拼资源的一种攻击。攻击者只要说话说得足够快，让服务器不停说“拒绝。我没听懂你在说啥？”，直到服务器反应不过来，死机了，就算成功了。因为服务器每次先会拒绝你的请求，所以这种攻击被叫做 拒绝服务攻击（DoS）。\n\n但是随着计算机技术的发展，服务器和常用的家庭计算机在性能上已经出现了很大的差距。也就是说，用家庭计算机去攻击服务器，对服务器的处理来说绰绰有余，没有什么问题。至此，DoS攻击发展出了一种新的形式，也就是DDoS攻击，分布式拒绝服务攻击，多了分布式三个字。其实，这个攻击说白了就是一个人弄不死你，弄个几千个人来弄死你咯~ 攻击者一般会使用成百上千台机器，对服务器发动拒绝服务攻击。想象一下，无论什么样的人，假如周围围了成百上千人不停在你耳边说着你听不懂的语言，而且协议还要求你必须一个个回复拒绝他们，这种场面是不是很惨，你是不是没办法正常处理应该要处理的事物了。\n\n其实，DDoS攻击的风靡还取决于其他一些因素。首先，它无关乎网站是不是有漏洞，单纯的是一种野蛮的不让你正常服务的攻击，技术门槛低。其次，是近年来一些黑客手里往往掌握了上千台肉鸡的资源（所谓肉鸡，就是中了木马病毒的机器）。黑客可以利用这些机器发动攻击，而不需要自己直接参与，对于自身来说更容易隐藏，并且不需要什么资源上的要求（反正这些电脑不是自己的）。前段时间，索尼的PSN网络遭袭，遭到的正是这样子的攻击。\n\nDDoS攻击其实依然在随着时间的推移发展。变化出了许多进一步的攻击形式。比如说SYN Flood、ICMP、Smurf等攻击，但都是万变不离其宗，其本质还是用大规模的干扰信息引起服务器的奔溃。只不过是利用的协议不同，或者在数据包上进行改进，从而使得攻击的效率进一步提高。\n\n最近由于一些事件，导致一些别有用心的人分发一些经由他们修改的看似DDoS攻击实则恶意程序的软件（虽然据我们所知，这样的软件**目前**还只是**少部分**）。我想各位还是请记住接下来说的几句话：\n\t黑客技术是一项水很深的技术，如果你对这项技术不了解，请不要趟这摊浑水。\n\t黑客从来不会鼓动其他人尤其是非技术人员一起参与。\n\t攻击之前你真的知道自己在攻击什么东西吗？你确定它真的在按照你的意图工作吗？\n\t时刻知道自己在干什么，并对此负责。","source":"_posts/what-is-ddos.md","raw":"---\ntitle: DDoS 攻击究竟是什么东西？\ndate: 2015-01-17 15:35:37\ntags: [科普,DDoS,网络]\n---\n\n最近既然这个名词很火，而很多参与这件事的人甚至都不知道这是什么东西，这对社会可能造成潜在的危害，所以有必要特意来说一下。\n\nDDoS，中文名字应该叫做 分布式拒绝服务攻击。不过这个中文名字听了就好像听不懂一样。啥是分布式？啥是拒绝服务攻击？那么要弄清DDoS之前，先要弄清一个概念，那就是DoS。\n\n<!--more-->\n这里说的DoS并不是DOS操作系统的DOS，Deny of Service，拒绝服务。这个攻击之所以能够成功，其实是得益于我们“愚蠢”却又是最常用和的互联网协议——包括IP协议、HTTP协议、ARP协议等。我们以HTTP协议为例，如果把这协议通俗化的话，可以用下面几个例子给大家看看：\n\n\n```\n用户：我想看baidu.com的内容\n服务器：接受。baidu.com的内容是XXXXXXXXX。\n\n用户：我想看baidu.com/qwqewqeqw的内容\n服务器：拒绝。找不到这样的文件。\n\n用户：我想发送“大家好”到weibo.com。\n服务器：拒绝。你没有登录。\n```\n\n大致就是这个样子的，就好像两个人在对话一样。但是大家有没有注意到一点，无论用户说什么，说的东西是对是错，服务器必须要回答。而DoS利用的正是这一个特性。DoS所做的工作就是：\n\n```\n攻击者：cxdasdascsca\n服务器：拒绝。我没听懂你在说啥？\n\n攻击者：dsasdasdasda\n服务器：拒绝。我没听懂你在说啥？\n\n......\n```\n\n\n在早期的攻击当中，这种攻击就是一种双方拼资源的一种攻击。攻击者只要说话说得足够快，让服务器不停说“拒绝。我没听懂你在说啥？”，直到服务器反应不过来，死机了，就算成功了。因为服务器每次先会拒绝你的请求，所以这种攻击被叫做 拒绝服务攻击（DoS）。\n\n但是随着计算机技术的发展，服务器和常用的家庭计算机在性能上已经出现了很大的差距。也就是说，用家庭计算机去攻击服务器，对服务器的处理来说绰绰有余，没有什么问题。至此，DoS攻击发展出了一种新的形式，也就是DDoS攻击，分布式拒绝服务攻击，多了分布式三个字。其实，这个攻击说白了就是一个人弄不死你，弄个几千个人来弄死你咯~ 攻击者一般会使用成百上千台机器，对服务器发动拒绝服务攻击。想象一下，无论什么样的人，假如周围围了成百上千人不停在你耳边说着你听不懂的语言，而且协议还要求你必须一个个回复拒绝他们，这种场面是不是很惨，你是不是没办法正常处理应该要处理的事物了。\n\n其实，DDoS攻击的风靡还取决于其他一些因素。首先，它无关乎网站是不是有漏洞，单纯的是一种野蛮的不让你正常服务的攻击，技术门槛低。其次，是近年来一些黑客手里往往掌握了上千台肉鸡的资源（所谓肉鸡，就是中了木马病毒的机器）。黑客可以利用这些机器发动攻击，而不需要自己直接参与，对于自身来说更容易隐藏，并且不需要什么资源上的要求（反正这些电脑不是自己的）。前段时间，索尼的PSN网络遭袭，遭到的正是这样子的攻击。\n\nDDoS攻击其实依然在随着时间的推移发展。变化出了许多进一步的攻击形式。比如说SYN Flood、ICMP、Smurf等攻击，但都是万变不离其宗，其本质还是用大规模的干扰信息引起服务器的奔溃。只不过是利用的协议不同，或者在数据包上进行改进，从而使得攻击的效率进一步提高。\n\n最近由于一些事件，导致一些别有用心的人分发一些经由他们修改的看似DDoS攻击实则恶意程序的软件（虽然据我们所知，这样的软件**目前**还只是**少部分**）。我想各位还是请记住接下来说的几句话：\n\t黑客技术是一项水很深的技术，如果你对这项技术不了解，请不要趟这摊浑水。\n\t黑客从来不会鼓动其他人尤其是非技术人员一起参与。\n\t攻击之前你真的知道自己在攻击什么东西吗？你确定它真的在按照你的意图工作吗？\n\t时刻知道自己在干什么，并对此负责。","slug":"what-is-ddos","published":1,"updated":"2016-04-22T02:56:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscy009t001dpp8z6ilfkown","content":"<p>最近既然这个名词很火，而很多参与这件事的人甚至都不知道这是什么东西，这对社会可能造成潜在的危害，所以有必要特意来说一下。</p>\n<p>DDoS，中文名字应该叫做 分布式拒绝服务攻击。不过这个中文名字听了就好像听不懂一样。啥是分布式？啥是拒绝服务攻击？那么要弄清DDoS之前，先要弄清一个概念，那就是DoS。</p>\n<a id=\"more\"></a>\n<p>这里说的DoS并不是DOS操作系统的DOS，Deny of Service，拒绝服务。这个攻击之所以能够成功，其实是得益于我们“愚蠢”却又是最常用和的互联网协议——包括IP协议、HTTP协议、ARP协议等。我们以HTTP协议为例，如果把这协议通俗化的话，可以用下面几个例子给大家看看：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用户：我想看baidu.com的内容</span><br><span class=\"line\">服务器：接受。baidu.com的内容是XXXXXXXXX。</span><br><span class=\"line\"></span><br><span class=\"line\">用户：我想看baidu.com/qwqewqeqw的内容</span><br><span class=\"line\">服务器：拒绝。找不到这样的文件。</span><br><span class=\"line\"></span><br><span class=\"line\">用户：我想发送“大家好”到weibo.com。</span><br><span class=\"line\">服务器：拒绝。你没有登录。</span><br></pre></td></tr></table></figure>\n<p>大致就是这个样子的，就好像两个人在对话一样。但是大家有没有注意到一点，无论用户说什么，说的东西是对是错，服务器必须要回答。而DoS利用的正是这一个特性。DoS所做的工作就是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">攻击者：cxdasdascsca</span><br><span class=\"line\">服务器：拒绝。我没听懂你在说啥？</span><br><span class=\"line\"></span><br><span class=\"line\">攻击者：dsasdasdasda</span><br><span class=\"line\">服务器：拒绝。我没听懂你在说啥？</span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n<p>在早期的攻击当中，这种攻击就是一种双方拼资源的一种攻击。攻击者只要说话说得足够快，让服务器不停说“拒绝。我没听懂你在说啥？”，直到服务器反应不过来，死机了，就算成功了。因为服务器每次先会拒绝你的请求，所以这种攻击被叫做 拒绝服务攻击（DoS）。</p>\n<p>但是随着计算机技术的发展，服务器和常用的家庭计算机在性能上已经出现了很大的差距。也就是说，用家庭计算机去攻击服务器，对服务器的处理来说绰绰有余，没有什么问题。至此，DoS攻击发展出了一种新的形式，也就是DDoS攻击，分布式拒绝服务攻击，多了分布式三个字。其实，这个攻击说白了就是一个人弄不死你，弄个几千个人来弄死你咯~ 攻击者一般会使用成百上千台机器，对服务器发动拒绝服务攻击。想象一下，无论什么样的人，假如周围围了成百上千人不停在你耳边说着你听不懂的语言，而且协议还要求你必须一个个回复拒绝他们，这种场面是不是很惨，你是不是没办法正常处理应该要处理的事物了。</p>\n<p>其实，DDoS攻击的风靡还取决于其他一些因素。首先，它无关乎网站是不是有漏洞，单纯的是一种野蛮的不让你正常服务的攻击，技术门槛低。其次，是近年来一些黑客手里往往掌握了上千台肉鸡的资源（所谓肉鸡，就是中了木马病毒的机器）。黑客可以利用这些机器发动攻击，而不需要自己直接参与，对于自身来说更容易隐藏，并且不需要什么资源上的要求（反正这些电脑不是自己的）。前段时间，索尼的PSN网络遭袭，遭到的正是这样子的攻击。</p>\n<p>DDoS攻击其实依然在随着时间的推移发展。变化出了许多进一步的攻击形式。比如说SYN Flood、ICMP、Smurf等攻击，但都是万变不离其宗，其本质还是用大规模的干扰信息引起服务器的奔溃。只不过是利用的协议不同，或者在数据包上进行改进，从而使得攻击的效率进一步提高。</p>\n<p>最近由于一些事件，导致一些别有用心的人分发一些经由他们修改的看似DDoS攻击实则恶意程序的软件（虽然据我们所知，这样的软件<strong>目前</strong>还只是<strong>少部分</strong>）。我想各位还是请记住接下来说的几句话：<br>    黑客技术是一项水很深的技术，如果你对这项技术不了解，请不要趟这摊浑水。<br>    黑客从来不会鼓动其他人尤其是非技术人员一起参与。<br>    攻击之前你真的知道自己在攻击什么东西吗？你确定它真的在按照你的意图工作吗？<br>    时刻知道自己在干什么，并对此负责。</p>\n","excerpt":"<p>最近既然这个名词很火，而很多参与这件事的人甚至都不知道这是什么东西，这对社会可能造成潜在的危害，所以有必要特意来说一下。</p>\n<p>DDoS，中文名字应该叫做 分布式拒绝服务攻击。不过这个中文名字听了就好像听不懂一样。啥是分布式？啥是拒绝服务攻击？那么要弄清DDoS之前，先要弄清一个概念，那就是DoS。</p>","more":"<p>这里说的DoS并不是DOS操作系统的DOS，Deny of Service，拒绝服务。这个攻击之所以能够成功，其实是得益于我们“愚蠢”却又是最常用和的互联网协议——包括IP协议、HTTP协议、ARP协议等。我们以HTTP协议为例，如果把这协议通俗化的话，可以用下面几个例子给大家看看：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用户：我想看baidu.com的内容</span><br><span class=\"line\">服务器：接受。baidu.com的内容是XXXXXXXXX。</span><br><span class=\"line\"></span><br><span class=\"line\">用户：我想看baidu.com/qwqewqeqw的内容</span><br><span class=\"line\">服务器：拒绝。找不到这样的文件。</span><br><span class=\"line\"></span><br><span class=\"line\">用户：我想发送“大家好”到weibo.com。</span><br><span class=\"line\">服务器：拒绝。你没有登录。</span><br></pre></td></tr></table></figure>\n<p>大致就是这个样子的，就好像两个人在对话一样。但是大家有没有注意到一点，无论用户说什么，说的东西是对是错，服务器必须要回答。而DoS利用的正是这一个特性。DoS所做的工作就是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">攻击者：cxdasdascsca</span><br><span class=\"line\">服务器：拒绝。我没听懂你在说啥？</span><br><span class=\"line\"></span><br><span class=\"line\">攻击者：dsasdasdasda</span><br><span class=\"line\">服务器：拒绝。我没听懂你在说啥？</span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n<p>在早期的攻击当中，这种攻击就是一种双方拼资源的一种攻击。攻击者只要说话说得足够快，让服务器不停说“拒绝。我没听懂你在说啥？”，直到服务器反应不过来，死机了，就算成功了。因为服务器每次先会拒绝你的请求，所以这种攻击被叫做 拒绝服务攻击（DoS）。</p>\n<p>但是随着计算机技术的发展，服务器和常用的家庭计算机在性能上已经出现了很大的差距。也就是说，用家庭计算机去攻击服务器，对服务器的处理来说绰绰有余，没有什么问题。至此，DoS攻击发展出了一种新的形式，也就是DDoS攻击，分布式拒绝服务攻击，多了分布式三个字。其实，这个攻击说白了就是一个人弄不死你，弄个几千个人来弄死你咯~ 攻击者一般会使用成百上千台机器，对服务器发动拒绝服务攻击。想象一下，无论什么样的人，假如周围围了成百上千人不停在你耳边说着你听不懂的语言，而且协议还要求你必须一个个回复拒绝他们，这种场面是不是很惨，你是不是没办法正常处理应该要处理的事物了。</p>\n<p>其实，DDoS攻击的风靡还取决于其他一些因素。首先，它无关乎网站是不是有漏洞，单纯的是一种野蛮的不让你正常服务的攻击，技术门槛低。其次，是近年来一些黑客手里往往掌握了上千台肉鸡的资源（所谓肉鸡，就是中了木马病毒的机器）。黑客可以利用这些机器发动攻击，而不需要自己直接参与，对于自身来说更容易隐藏，并且不需要什么资源上的要求（反正这些电脑不是自己的）。前段时间，索尼的PSN网络遭袭，遭到的正是这样子的攻击。</p>\n<p>DDoS攻击其实依然在随着时间的推移发展。变化出了许多进一步的攻击形式。比如说SYN Flood、ICMP、Smurf等攻击，但都是万变不离其宗，其本质还是用大规模的干扰信息引起服务器的奔溃。只不过是利用的协议不同，或者在数据包上进行改进，从而使得攻击的效率进一步提高。</p>\n<p>最近由于一些事件，导致一些别有用心的人分发一些经由他们修改的看似DDoS攻击实则恶意程序的软件（虽然据我们所知，这样的软件<strong>目前</strong>还只是<strong>少部分</strong>）。我想各位还是请记住接下来说的几句话：<br>    黑客技术是一项水很深的技术，如果你对这项技术不了解，请不要趟这摊浑水。<br>    黑客从来不会鼓动其他人尤其是非技术人员一起参与。<br>    攻击之前你真的知道自己在攻击什么东西吗？你确定它真的在按照你的意图工作吗？<br>    时刻知道自己在干什么，并对此负责。</p>"},{"title":"支持平权支持的是什么？","date":"2015-06-27T12:15:12.000Z","_content":"\n<div class=\"tip\">\n\n平权运动，无论是女权运动也好、黑人解放运动也好，还是同性婚姻合法化也好，其实归根究底平的是两件事 —— 人权（民权）。\n\n</div>\n\n说到人权，我们很容易想到 1776 年美国的《美国独立宣言》、1789 年法国的《人权与公民权宣言》和 1948年联合国大会批准的《世界人权宣言》。其实追溯起来，最早的有关人权的法案可以追溯到公元前六世纪的《居鲁士文书》，即居鲁士大帝宣布释放所有奴隶回乡。当我们谈到人权的时候，我们想到的通常是这些法案和文书。但是实际上人权本身和任何法案和文书都没有关系，也就是说人权本身具有普世性，每个人都应该享有人权，法律只不过是约束的一种形式而已。\n\n<!--more-->\n\n#### 平权\n\n《美国独立宣言》中的一句话很好的概括了人权的内容：All men are created equal. 人人生而平等。人权指的是个人或群体作为人类本身即享有的权利，每个人都应该享受相等的权利。不过需要注意的是，无论是《美国独立宣言》还是《人权与共民权宣言》当时都是将人权限定在男性公民上，即把女性和奴隶排除在外。然而正如我们之前所说，法律不过是约束的形式，这并不影响女性和奴隶理应享受和其他人一样的权利。人权的一般定义中包括了：生命权、自由权、财产权、尊严权、获助权、公证权和受教育权利。展开的话其实内容更加丰富。而民权则是人权更进一步的内容，即 “公民” 的法定权利。通常我们通常将它和人权放在一起谈。因为他们之间在实际情况下的界限并不是非常分明。\n\n支持平权的基础是承认人本身的差异性。人类存在男性、女性、跨性别人。你不能只认准男性作为人类的代表，从而歧视女性和跨性别人。就好像世界上存在单眼皮的人和双眼皮的人，他们都是人类组成的一部分，你不能认准某一种眼皮的人是 “正确” 的，而去歧视另一部分人。这就是所谓平权的意义，使得地球上人人享有的人权相等。\n\n举个例子来说，在美国女权主义运动的过程中，一些女权组织禁止男性在他们的组织内工作。然而，这并不是平权的一部分，因为在平权过程中，男性应该和女性享有同等的工作权利，而不是以女性可以工作来替代男性可以工作。\n\n同样地，在近年来非常受到关注的同性婚姻合法化运动中，人们希望同性恋能够和异性恋一样享受相同的婚姻家庭权利。正因为婚姻家庭权利是人权，是每个人都应该享受的权利，无关于家庭的结合是同性还是异性。（在此事件上的许多美国反对者的观点通常打的是对于家庭的定义、对于婚姻的定义，因为在这两者的定义上，人通常认为异性结合的才是婚姻或者家庭，而且这上面也没有明确的定义，这确实是一个值得斟酌的点，也是争论的焦点。这也是为什么美国最高法院在昨天以 5：4 这样微弱的差距通过了同性婚姻法案。）\n\n#### 那为什么还会要区分 XX权 呢？\n\n于是问题来了，既然追求的核心是平权，那为什么我还要区分对待。比如将女权、同性婚姻权分离出来来看呢？\n\n这个问题事实上问的相当有水平。因为当我们把这些权利分开来争取的时候，往往容易 “犯错误”。比如上面说过的追求女权的过程中并没有以平权的要求在争取，而是甚至以女权高于男权这样错误的争取方式。这种争取方式其实在现在国内外很多单独的人权组织中都有出现。就好像你不能批评黑人，不能批评女人，不能批评同性恋，不能批评华人，一旦你批评了，明天人权组织就出来说你是歧视他们。\n\n但事实上平权并不是这样一回事。承认人本身的差异性是平权的根本原因。人和人之间就是存在差异的，就好像黑人从基因上更容易使他们合成白肌，所以黑人就是在运动天赋上有优势，这是不可否认的事实。你不能说追求平等，所以就必须承认各个人种在体力上是完全相等的，这是不正确的，我们只争取权利上的平等，而不是一切的平等，追求的是存在差异的各个不同的人之间平等的权利。所以每个群体肯定也有自己的弱点，我们自然可以批评。这无关于人权。\n\n类似上面的问题还有 为什么女性可以放产假？\n\n因为我们承认女性和男性生理上的差异，认识到她们作为女性本身需要这种权利。女权指的是这个，而不是男女平权之后，女性应该和担任相同的工作、享受相同的假期，这本身才是对女性权利的歧视。\n\n那么我们认清了这个问题，我们来回答为什么还要区分各种人群追求的权利。因为各个人群受到歧视的地方是不同的，所以要进行区分。举例来说，对于女性，她们的生育权、堕胎权、家庭暴力问题、享受产假的权利、性暴力问题等上面更为关注，而这些问题是其他群体不会或者不容易遇到的，所以需要分开来具体看，具体争取。\n\n另一点则是出于具体的原因。比如比尔盖茨梅琳达基金会近年来长期呼吁同性恋平权的一大原因是男同性性行为是目前许多地区（包括中国）传播艾滋病的一大途径。出于人生命权的考虑，我们可以优先呼吁男同性恋平权。男同性恋不会因为社会的不承认而不存在，相反，社会的不承认会使得他们的关系从地上走到地下，缺乏基本的安全措施。如果男同性恋能更好被社会承认，男同性恋的性行为可以更好地被规范，可以大大降低国内艾滋病的发病率。\n\n#### 既然我们支持的是平权，那么为什么我们还要支持说类似于 我是XX我自豪 这样的言论呢？\n\n我是 XX 我自豪（XX Proud）。这个问题也是平权中经常被问到的问题。比如，你可以说：我是黑人我自豪，或者我是同性恋我自豪。这通常被认为是政治正确的。但如果你说我是白人我自豪，或者我是异性恋我自豪则会被认为是歧视。\n\n这其实是因为上述例子中黑人或者同性恋在当前社会下是弱势群体。鼓励说我是 XX 我自豪并不是认为 XX 比其他人群拥有更高的等级，而是其在弱势的情况下，社会的舆论下依然愿意公开承认自己，承认自己的不同，承认自己与别人的差异，这一点非常勇敢和理性，所以才值得被鼓励。这句话其实更应该理解成 我不因为我是 XX 而自卑。\n\n承认人和人本身的不同，愿意公开承认人和人本身的不同。这一点才是被鼓励的。\n\n#### 然而现实是极其残酷的\n\n现实永远是很残酷的，各种平权运动的进展通常都不顺利。我们在一开始说过，人权是具有普世性的，法律不过是约束其的手段。即使《同性婚姻法案》在美国被通过，并不代表美国人民就完全接受了同性恋。这就好像当年林肯 1862 年签署了《奴隶解放宣言》之后，黑人依然长期被歧视。一直到 20 世纪中叶美国一系列民权运动者的努力下，黑人才逐渐获得越发平等的权利。私以为中国的女权也处于一个法律保护但文化思想上接受程度非常糟糕的程度。\n\n社会的接受比法律的接受更加重要，也更加难争取。这就好像很多孩子看了两部 BL 的作品就天天把基挂在嘴边，好像非常支持同性恋一样，但等他们看到俩大叔抱在一起的时候却做出恶心的表情。你可以问自己这样的问题：如果你有一个哥哥或者弟弟而他是一名同性恋，你是否能接受。如果单纯在法律上被接受然而在心理上没有接受的话，平权并不是真正的成功。刚刷人人的时候看到有人举例说可能孩子以后会要挟说 “不给我买肾6，我就找个同性结婚去。” 而这正是这个问题的实质。无论是孩子还是父母都不从心理上接受同性恋是正常的，所以才可以进行要挟。\n\n心理上的接受是很多人难以逾越的一道坎，这加剧了平权运动推进的难度。加上人们长期以来的经验认识更是容易加剧这种印象。就好像有人会说出 “女人天生就不应该外出工作。” 这样子的话，这句话缺乏基本的逻辑支持，但是却是这个人的固有印象。人们曾经也把物体掉落和重量相关当作固有印象，但是通过实验可以很好的证明他们的错误。但权利这个问题非常的抽象，矫正一个人的观念非常难。甚至 “少数者” 在许多情况下会被理解成病态，就像同性恋在长期都被认为是一种疾病，性别认知障碍也长时间被认为是一种疾病。这对于他们的平权难度更加高。\n\n#### 相信，现实也许是非常美好的\n\n每个人有各自的不同，有各自的差异。人类在过去只有繁重体力劳动，女性在当时很难争取到工作权是客观原因。而到现在，我们的工作愈发多样，人的生活本身也愈发多样。你的性别、你的肤色、你的性取向似乎都不会影响你找一份适合的工作。有了工作，人有基本的生存的能力，我始终相信坚持下去什么都会有的。\n\n**平权一定是会有的吧。**\n\nHeckPsi 长期支持 LGBT 平权、女性平权及其它人权平等。","source":"_posts/what-is-equal-rights.md","raw":"---\ntitle: 支持平权支持的是什么？\ndate: 2015-06-27 20:15:12\ntags: [LGBT,女权,权利]\n---\n\n<div class=\"tip\">\n\n平权运动，无论是女权运动也好、黑人解放运动也好，还是同性婚姻合法化也好，其实归根究底平的是两件事 —— 人权（民权）。\n\n</div>\n\n说到人权，我们很容易想到 1776 年美国的《美国独立宣言》、1789 年法国的《人权与公民权宣言》和 1948年联合国大会批准的《世界人权宣言》。其实追溯起来，最早的有关人权的法案可以追溯到公元前六世纪的《居鲁士文书》，即居鲁士大帝宣布释放所有奴隶回乡。当我们谈到人权的时候，我们想到的通常是这些法案和文书。但是实际上人权本身和任何法案和文书都没有关系，也就是说人权本身具有普世性，每个人都应该享有人权，法律只不过是约束的一种形式而已。\n\n<!--more-->\n\n#### 平权\n\n《美国独立宣言》中的一句话很好的概括了人权的内容：All men are created equal. 人人生而平等。人权指的是个人或群体作为人类本身即享有的权利，每个人都应该享受相等的权利。不过需要注意的是，无论是《美国独立宣言》还是《人权与共民权宣言》当时都是将人权限定在男性公民上，即把女性和奴隶排除在外。然而正如我们之前所说，法律不过是约束的形式，这并不影响女性和奴隶理应享受和其他人一样的权利。人权的一般定义中包括了：生命权、自由权、财产权、尊严权、获助权、公证权和受教育权利。展开的话其实内容更加丰富。而民权则是人权更进一步的内容，即 “公民” 的法定权利。通常我们通常将它和人权放在一起谈。因为他们之间在实际情况下的界限并不是非常分明。\n\n支持平权的基础是承认人本身的差异性。人类存在男性、女性、跨性别人。你不能只认准男性作为人类的代表，从而歧视女性和跨性别人。就好像世界上存在单眼皮的人和双眼皮的人，他们都是人类组成的一部分，你不能认准某一种眼皮的人是 “正确” 的，而去歧视另一部分人。这就是所谓平权的意义，使得地球上人人享有的人权相等。\n\n举个例子来说，在美国女权主义运动的过程中，一些女权组织禁止男性在他们的组织内工作。然而，这并不是平权的一部分，因为在平权过程中，男性应该和女性享有同等的工作权利，而不是以女性可以工作来替代男性可以工作。\n\n同样地，在近年来非常受到关注的同性婚姻合法化运动中，人们希望同性恋能够和异性恋一样享受相同的婚姻家庭权利。正因为婚姻家庭权利是人权，是每个人都应该享受的权利，无关于家庭的结合是同性还是异性。（在此事件上的许多美国反对者的观点通常打的是对于家庭的定义、对于婚姻的定义，因为在这两者的定义上，人通常认为异性结合的才是婚姻或者家庭，而且这上面也没有明确的定义，这确实是一个值得斟酌的点，也是争论的焦点。这也是为什么美国最高法院在昨天以 5：4 这样微弱的差距通过了同性婚姻法案。）\n\n#### 那为什么还会要区分 XX权 呢？\n\n于是问题来了，既然追求的核心是平权，那为什么我还要区分对待。比如将女权、同性婚姻权分离出来来看呢？\n\n这个问题事实上问的相当有水平。因为当我们把这些权利分开来争取的时候，往往容易 “犯错误”。比如上面说过的追求女权的过程中并没有以平权的要求在争取，而是甚至以女权高于男权这样错误的争取方式。这种争取方式其实在现在国内外很多单独的人权组织中都有出现。就好像你不能批评黑人，不能批评女人，不能批评同性恋，不能批评华人，一旦你批评了，明天人权组织就出来说你是歧视他们。\n\n但事实上平权并不是这样一回事。承认人本身的差异性是平权的根本原因。人和人之间就是存在差异的，就好像黑人从基因上更容易使他们合成白肌，所以黑人就是在运动天赋上有优势，这是不可否认的事实。你不能说追求平等，所以就必须承认各个人种在体力上是完全相等的，这是不正确的，我们只争取权利上的平等，而不是一切的平等，追求的是存在差异的各个不同的人之间平等的权利。所以每个群体肯定也有自己的弱点，我们自然可以批评。这无关于人权。\n\n类似上面的问题还有 为什么女性可以放产假？\n\n因为我们承认女性和男性生理上的差异，认识到她们作为女性本身需要这种权利。女权指的是这个，而不是男女平权之后，女性应该和担任相同的工作、享受相同的假期，这本身才是对女性权利的歧视。\n\n那么我们认清了这个问题，我们来回答为什么还要区分各种人群追求的权利。因为各个人群受到歧视的地方是不同的，所以要进行区分。举例来说，对于女性，她们的生育权、堕胎权、家庭暴力问题、享受产假的权利、性暴力问题等上面更为关注，而这些问题是其他群体不会或者不容易遇到的，所以需要分开来具体看，具体争取。\n\n另一点则是出于具体的原因。比如比尔盖茨梅琳达基金会近年来长期呼吁同性恋平权的一大原因是男同性性行为是目前许多地区（包括中国）传播艾滋病的一大途径。出于人生命权的考虑，我们可以优先呼吁男同性恋平权。男同性恋不会因为社会的不承认而不存在，相反，社会的不承认会使得他们的关系从地上走到地下，缺乏基本的安全措施。如果男同性恋能更好被社会承认，男同性恋的性行为可以更好地被规范，可以大大降低国内艾滋病的发病率。\n\n#### 既然我们支持的是平权，那么为什么我们还要支持说类似于 我是XX我自豪 这样的言论呢？\n\n我是 XX 我自豪（XX Proud）。这个问题也是平权中经常被问到的问题。比如，你可以说：我是黑人我自豪，或者我是同性恋我自豪。这通常被认为是政治正确的。但如果你说我是白人我自豪，或者我是异性恋我自豪则会被认为是歧视。\n\n这其实是因为上述例子中黑人或者同性恋在当前社会下是弱势群体。鼓励说我是 XX 我自豪并不是认为 XX 比其他人群拥有更高的等级，而是其在弱势的情况下，社会的舆论下依然愿意公开承认自己，承认自己的不同，承认自己与别人的差异，这一点非常勇敢和理性，所以才值得被鼓励。这句话其实更应该理解成 我不因为我是 XX 而自卑。\n\n承认人和人本身的不同，愿意公开承认人和人本身的不同。这一点才是被鼓励的。\n\n#### 然而现实是极其残酷的\n\n现实永远是很残酷的，各种平权运动的进展通常都不顺利。我们在一开始说过，人权是具有普世性的，法律不过是约束其的手段。即使《同性婚姻法案》在美国被通过，并不代表美国人民就完全接受了同性恋。这就好像当年林肯 1862 年签署了《奴隶解放宣言》之后，黑人依然长期被歧视。一直到 20 世纪中叶美国一系列民权运动者的努力下，黑人才逐渐获得越发平等的权利。私以为中国的女权也处于一个法律保护但文化思想上接受程度非常糟糕的程度。\n\n社会的接受比法律的接受更加重要，也更加难争取。这就好像很多孩子看了两部 BL 的作品就天天把基挂在嘴边，好像非常支持同性恋一样，但等他们看到俩大叔抱在一起的时候却做出恶心的表情。你可以问自己这样的问题：如果你有一个哥哥或者弟弟而他是一名同性恋，你是否能接受。如果单纯在法律上被接受然而在心理上没有接受的话，平权并不是真正的成功。刚刷人人的时候看到有人举例说可能孩子以后会要挟说 “不给我买肾6，我就找个同性结婚去。” 而这正是这个问题的实质。无论是孩子还是父母都不从心理上接受同性恋是正常的，所以才可以进行要挟。\n\n心理上的接受是很多人难以逾越的一道坎，这加剧了平权运动推进的难度。加上人们长期以来的经验认识更是容易加剧这种印象。就好像有人会说出 “女人天生就不应该外出工作。” 这样子的话，这句话缺乏基本的逻辑支持，但是却是这个人的固有印象。人们曾经也把物体掉落和重量相关当作固有印象，但是通过实验可以很好的证明他们的错误。但权利这个问题非常的抽象，矫正一个人的观念非常难。甚至 “少数者” 在许多情况下会被理解成病态，就像同性恋在长期都被认为是一种疾病，性别认知障碍也长时间被认为是一种疾病。这对于他们的平权难度更加高。\n\n#### 相信，现实也许是非常美好的\n\n每个人有各自的不同，有各自的差异。人类在过去只有繁重体力劳动，女性在当时很难争取到工作权是客观原因。而到现在，我们的工作愈发多样，人的生活本身也愈发多样。你的性别、你的肤色、你的性取向似乎都不会影响你找一份适合的工作。有了工作，人有基本的生存的能力，我始终相信坚持下去什么都会有的。\n\n**平权一定是会有的吧。**\n\nHeckPsi 长期支持 LGBT 平权、女性平权及其它人权平等。","slug":"what-is-equal-rights","published":1,"updated":"2016-04-23T13:16:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscy009v001epp8zbqxdeekg","content":"<div class=\"tip\"><br><br>平权运动，无论是女权运动也好、黑人解放运动也好，还是同性婚姻合法化也好，其实归根究底平的是两件事 —— 人权（民权）。<br><br></div>\n\n<p>说到人权，我们很容易想到 1776 年美国的《美国独立宣言》、1789 年法国的《人权与公民权宣言》和 1948年联合国大会批准的《世界人权宣言》。其实追溯起来，最早的有关人权的法案可以追溯到公元前六世纪的《居鲁士文书》，即居鲁士大帝宣布释放所有奴隶回乡。当我们谈到人权的时候，我们想到的通常是这些法案和文书。但是实际上人权本身和任何法案和文书都没有关系，也就是说人权本身具有普世性，每个人都应该享有人权，法律只不过是约束的一种形式而已。</p>\n<a id=\"more\"></a>\n<h4 id=\"平权\"><a href=\"#平权\" class=\"headerlink\" title=\"平权\"></a>平权</h4><p>《美国独立宣言》中的一句话很好的概括了人权的内容：All men are created equal. 人人生而平等。人权指的是个人或群体作为人类本身即享有的权利，每个人都应该享受相等的权利。不过需要注意的是，无论是《美国独立宣言》还是《人权与共民权宣言》当时都是将人权限定在男性公民上，即把女性和奴隶排除在外。然而正如我们之前所说，法律不过是约束的形式，这并不影响女性和奴隶理应享受和其他人一样的权利。人权的一般定义中包括了：生命权、自由权、财产权、尊严权、获助权、公证权和受教育权利。展开的话其实内容更加丰富。而民权则是人权更进一步的内容，即 “公民” 的法定权利。通常我们通常将它和人权放在一起谈。因为他们之间在实际情况下的界限并不是非常分明。</p>\n<p>支持平权的基础是承认人本身的差异性。人类存在男性、女性、跨性别人。你不能只认准男性作为人类的代表，从而歧视女性和跨性别人。就好像世界上存在单眼皮的人和双眼皮的人，他们都是人类组成的一部分，你不能认准某一种眼皮的人是 “正确” 的，而去歧视另一部分人。这就是所谓平权的意义，使得地球上人人享有的人权相等。</p>\n<p>举个例子来说，在美国女权主义运动的过程中，一些女权组织禁止男性在他们的组织内工作。然而，这并不是平权的一部分，因为在平权过程中，男性应该和女性享有同等的工作权利，而不是以女性可以工作来替代男性可以工作。</p>\n<p>同样地，在近年来非常受到关注的同性婚姻合法化运动中，人们希望同性恋能够和异性恋一样享受相同的婚姻家庭权利。正因为婚姻家庭权利是人权，是每个人都应该享受的权利，无关于家庭的结合是同性还是异性。（在此事件上的许多美国反对者的观点通常打的是对于家庭的定义、对于婚姻的定义，因为在这两者的定义上，人通常认为异性结合的才是婚姻或者家庭，而且这上面也没有明确的定义，这确实是一个值得斟酌的点，也是争论的焦点。这也是为什么美国最高法院在昨天以 5：4 这样微弱的差距通过了同性婚姻法案。）</p>\n<h4 id=\"那为什么还会要区分-XX权-呢？\"><a href=\"#那为什么还会要区分-XX权-呢？\" class=\"headerlink\" title=\"那为什么还会要区分 XX权 呢？\"></a>那为什么还会要区分 XX权 呢？</h4><p>于是问题来了，既然追求的核心是平权，那为什么我还要区分对待。比如将女权、同性婚姻权分离出来来看呢？</p>\n<p>这个问题事实上问的相当有水平。因为当我们把这些权利分开来争取的时候，往往容易 “犯错误”。比如上面说过的追求女权的过程中并没有以平权的要求在争取，而是甚至以女权高于男权这样错误的争取方式。这种争取方式其实在现在国内外很多单独的人权组织中都有出现。就好像你不能批评黑人，不能批评女人，不能批评同性恋，不能批评华人，一旦你批评了，明天人权组织就出来说你是歧视他们。</p>\n<p>但事实上平权并不是这样一回事。承认人本身的差异性是平权的根本原因。人和人之间就是存在差异的，就好像黑人从基因上更容易使他们合成白肌，所以黑人就是在运动天赋上有优势，这是不可否认的事实。你不能说追求平等，所以就必须承认各个人种在体力上是完全相等的，这是不正确的，我们只争取权利上的平等，而不是一切的平等，追求的是存在差异的各个不同的人之间平等的权利。所以每个群体肯定也有自己的弱点，我们自然可以批评。这无关于人权。</p>\n<p>类似上面的问题还有 为什么女性可以放产假？</p>\n<p>因为我们承认女性和男性生理上的差异，认识到她们作为女性本身需要这种权利。女权指的是这个，而不是男女平权之后，女性应该和担任相同的工作、享受相同的假期，这本身才是对女性权利的歧视。</p>\n<p>那么我们认清了这个问题，我们来回答为什么还要区分各种人群追求的权利。因为各个人群受到歧视的地方是不同的，所以要进行区分。举例来说，对于女性，她们的生育权、堕胎权、家庭暴力问题、享受产假的权利、性暴力问题等上面更为关注，而这些问题是其他群体不会或者不容易遇到的，所以需要分开来具体看，具体争取。</p>\n<p>另一点则是出于具体的原因。比如比尔盖茨梅琳达基金会近年来长期呼吁同性恋平权的一大原因是男同性性行为是目前许多地区（包括中国）传播艾滋病的一大途径。出于人生命权的考虑，我们可以优先呼吁男同性恋平权。男同性恋不会因为社会的不承认而不存在，相反，社会的不承认会使得他们的关系从地上走到地下，缺乏基本的安全措施。如果男同性恋能更好被社会承认，男同性恋的性行为可以更好地被规范，可以大大降低国内艾滋病的发病率。</p>\n<h4 id=\"既然我们支持的是平权，那么为什么我们还要支持说类似于-我是XX我自豪-这样的言论呢？\"><a href=\"#既然我们支持的是平权，那么为什么我们还要支持说类似于-我是XX我自豪-这样的言论呢？\" class=\"headerlink\" title=\"既然我们支持的是平权，那么为什么我们还要支持说类似于 我是XX我自豪 这样的言论呢？\"></a>既然我们支持的是平权，那么为什么我们还要支持说类似于 我是XX我自豪 这样的言论呢？</h4><p>我是 XX 我自豪（XX Proud）。这个问题也是平权中经常被问到的问题。比如，你可以说：我是黑人我自豪，或者我是同性恋我自豪。这通常被认为是政治正确的。但如果你说我是白人我自豪，或者我是异性恋我自豪则会被认为是歧视。</p>\n<p>这其实是因为上述例子中黑人或者同性恋在当前社会下是弱势群体。鼓励说我是 XX 我自豪并不是认为 XX 比其他人群拥有更高的等级，而是其在弱势的情况下，社会的舆论下依然愿意公开承认自己，承认自己的不同，承认自己与别人的差异，这一点非常勇敢和理性，所以才值得被鼓励。这句话其实更应该理解成 我不因为我是 XX 而自卑。</p>\n<p>承认人和人本身的不同，愿意公开承认人和人本身的不同。这一点才是被鼓励的。</p>\n<h4 id=\"然而现实是极其残酷的\"><a href=\"#然而现实是极其残酷的\" class=\"headerlink\" title=\"然而现实是极其残酷的\"></a>然而现实是极其残酷的</h4><p>现实永远是很残酷的，各种平权运动的进展通常都不顺利。我们在一开始说过，人权是具有普世性的，法律不过是约束其的手段。即使《同性婚姻法案》在美国被通过，并不代表美国人民就完全接受了同性恋。这就好像当年林肯 1862 年签署了《奴隶解放宣言》之后，黑人依然长期被歧视。一直到 20 世纪中叶美国一系列民权运动者的努力下，黑人才逐渐获得越发平等的权利。私以为中国的女权也处于一个法律保护但文化思想上接受程度非常糟糕的程度。</p>\n<p>社会的接受比法律的接受更加重要，也更加难争取。这就好像很多孩子看了两部 BL 的作品就天天把基挂在嘴边，好像非常支持同性恋一样，但等他们看到俩大叔抱在一起的时候却做出恶心的表情。你可以问自己这样的问题：如果你有一个哥哥或者弟弟而他是一名同性恋，你是否能接受。如果单纯在法律上被接受然而在心理上没有接受的话，平权并不是真正的成功。刚刷人人的时候看到有人举例说可能孩子以后会要挟说 “不给我买肾6，我就找个同性结婚去。” 而这正是这个问题的实质。无论是孩子还是父母都不从心理上接受同性恋是正常的，所以才可以进行要挟。</p>\n<p>心理上的接受是很多人难以逾越的一道坎，这加剧了平权运动推进的难度。加上人们长期以来的经验认识更是容易加剧这种印象。就好像有人会说出 “女人天生就不应该外出工作。” 这样子的话，这句话缺乏基本的逻辑支持，但是却是这个人的固有印象。人们曾经也把物体掉落和重量相关当作固有印象，但是通过实验可以很好的证明他们的错误。但权利这个问题非常的抽象，矫正一个人的观念非常难。甚至 “少数者” 在许多情况下会被理解成病态，就像同性恋在长期都被认为是一种疾病，性别认知障碍也长时间被认为是一种疾病。这对于他们的平权难度更加高。</p>\n<h4 id=\"相信，现实也许是非常美好的\"><a href=\"#相信，现实也许是非常美好的\" class=\"headerlink\" title=\"相信，现实也许是非常美好的\"></a>相信，现实也许是非常美好的</h4><p>每个人有各自的不同，有各自的差异。人类在过去只有繁重体力劳动，女性在当时很难争取到工作权是客观原因。而到现在，我们的工作愈发多样，人的生活本身也愈发多样。你的性别、你的肤色、你的性取向似乎都不会影响你找一份适合的工作。有了工作，人有基本的生存的能力，我始终相信坚持下去什么都会有的。</p>\n<p><strong>平权一定是会有的吧。</strong></p>\n<p>HeckPsi 长期支持 LGBT 平权、女性平权及其它人权平等。</p>\n","excerpt":"<div class=\"tip\"><br><br>平权运动，无论是女权运动也好、黑人解放运动也好，还是同性婚姻合法化也好，其实归根究底平的是两件事 —— 人权（民权）。<br><br></div>\n\n<p>说到人权，我们很容易想到 1776 年美国的《美国独立宣言》、1789 年法国的《人权与公民权宣言》和 1948年联合国大会批准的《世界人权宣言》。其实追溯起来，最早的有关人权的法案可以追溯到公元前六世纪的《居鲁士文书》，即居鲁士大帝宣布释放所有奴隶回乡。当我们谈到人权的时候，我们想到的通常是这些法案和文书。但是实际上人权本身和任何法案和文书都没有关系，也就是说人权本身具有普世性，每个人都应该享有人权，法律只不过是约束的一种形式而已。</p>","more":"<h4 id=\"平权\"><a href=\"#平权\" class=\"headerlink\" title=\"平权\"></a>平权</h4><p>《美国独立宣言》中的一句话很好的概括了人权的内容：All men are created equal. 人人生而平等。人权指的是个人或群体作为人类本身即享有的权利，每个人都应该享受相等的权利。不过需要注意的是，无论是《美国独立宣言》还是《人权与共民权宣言》当时都是将人权限定在男性公民上，即把女性和奴隶排除在外。然而正如我们之前所说，法律不过是约束的形式，这并不影响女性和奴隶理应享受和其他人一样的权利。人权的一般定义中包括了：生命权、自由权、财产权、尊严权、获助权、公证权和受教育权利。展开的话其实内容更加丰富。而民权则是人权更进一步的内容，即 “公民” 的法定权利。通常我们通常将它和人权放在一起谈。因为他们之间在实际情况下的界限并不是非常分明。</p>\n<p>支持平权的基础是承认人本身的差异性。人类存在男性、女性、跨性别人。你不能只认准男性作为人类的代表，从而歧视女性和跨性别人。就好像世界上存在单眼皮的人和双眼皮的人，他们都是人类组成的一部分，你不能认准某一种眼皮的人是 “正确” 的，而去歧视另一部分人。这就是所谓平权的意义，使得地球上人人享有的人权相等。</p>\n<p>举个例子来说，在美国女权主义运动的过程中，一些女权组织禁止男性在他们的组织内工作。然而，这并不是平权的一部分，因为在平权过程中，男性应该和女性享有同等的工作权利，而不是以女性可以工作来替代男性可以工作。</p>\n<p>同样地，在近年来非常受到关注的同性婚姻合法化运动中，人们希望同性恋能够和异性恋一样享受相同的婚姻家庭权利。正因为婚姻家庭权利是人权，是每个人都应该享受的权利，无关于家庭的结合是同性还是异性。（在此事件上的许多美国反对者的观点通常打的是对于家庭的定义、对于婚姻的定义，因为在这两者的定义上，人通常认为异性结合的才是婚姻或者家庭，而且这上面也没有明确的定义，这确实是一个值得斟酌的点，也是争论的焦点。这也是为什么美国最高法院在昨天以 5：4 这样微弱的差距通过了同性婚姻法案。）</p>\n<h4 id=\"那为什么还会要区分-XX权-呢？\"><a href=\"#那为什么还会要区分-XX权-呢？\" class=\"headerlink\" title=\"那为什么还会要区分 XX权 呢？\"></a>那为什么还会要区分 XX权 呢？</h4><p>于是问题来了，既然追求的核心是平权，那为什么我还要区分对待。比如将女权、同性婚姻权分离出来来看呢？</p>\n<p>这个问题事实上问的相当有水平。因为当我们把这些权利分开来争取的时候，往往容易 “犯错误”。比如上面说过的追求女权的过程中并没有以平权的要求在争取，而是甚至以女权高于男权这样错误的争取方式。这种争取方式其实在现在国内外很多单独的人权组织中都有出现。就好像你不能批评黑人，不能批评女人，不能批评同性恋，不能批评华人，一旦你批评了，明天人权组织就出来说你是歧视他们。</p>\n<p>但事实上平权并不是这样一回事。承认人本身的差异性是平权的根本原因。人和人之间就是存在差异的，就好像黑人从基因上更容易使他们合成白肌，所以黑人就是在运动天赋上有优势，这是不可否认的事实。你不能说追求平等，所以就必须承认各个人种在体力上是完全相等的，这是不正确的，我们只争取权利上的平等，而不是一切的平等，追求的是存在差异的各个不同的人之间平等的权利。所以每个群体肯定也有自己的弱点，我们自然可以批评。这无关于人权。</p>\n<p>类似上面的问题还有 为什么女性可以放产假？</p>\n<p>因为我们承认女性和男性生理上的差异，认识到她们作为女性本身需要这种权利。女权指的是这个，而不是男女平权之后，女性应该和担任相同的工作、享受相同的假期，这本身才是对女性权利的歧视。</p>\n<p>那么我们认清了这个问题，我们来回答为什么还要区分各种人群追求的权利。因为各个人群受到歧视的地方是不同的，所以要进行区分。举例来说，对于女性，她们的生育权、堕胎权、家庭暴力问题、享受产假的权利、性暴力问题等上面更为关注，而这些问题是其他群体不会或者不容易遇到的，所以需要分开来具体看，具体争取。</p>\n<p>另一点则是出于具体的原因。比如比尔盖茨梅琳达基金会近年来长期呼吁同性恋平权的一大原因是男同性性行为是目前许多地区（包括中国）传播艾滋病的一大途径。出于人生命权的考虑，我们可以优先呼吁男同性恋平权。男同性恋不会因为社会的不承认而不存在，相反，社会的不承认会使得他们的关系从地上走到地下，缺乏基本的安全措施。如果男同性恋能更好被社会承认，男同性恋的性行为可以更好地被规范，可以大大降低国内艾滋病的发病率。</p>\n<h4 id=\"既然我们支持的是平权，那么为什么我们还要支持说类似于-我是XX我自豪-这样的言论呢？\"><a href=\"#既然我们支持的是平权，那么为什么我们还要支持说类似于-我是XX我自豪-这样的言论呢？\" class=\"headerlink\" title=\"既然我们支持的是平权，那么为什么我们还要支持说类似于 我是XX我自豪 这样的言论呢？\"></a>既然我们支持的是平权，那么为什么我们还要支持说类似于 我是XX我自豪 这样的言论呢？</h4><p>我是 XX 我自豪（XX Proud）。这个问题也是平权中经常被问到的问题。比如，你可以说：我是黑人我自豪，或者我是同性恋我自豪。这通常被认为是政治正确的。但如果你说我是白人我自豪，或者我是异性恋我自豪则会被认为是歧视。</p>\n<p>这其实是因为上述例子中黑人或者同性恋在当前社会下是弱势群体。鼓励说我是 XX 我自豪并不是认为 XX 比其他人群拥有更高的等级，而是其在弱势的情况下，社会的舆论下依然愿意公开承认自己，承认自己的不同，承认自己与别人的差异，这一点非常勇敢和理性，所以才值得被鼓励。这句话其实更应该理解成 我不因为我是 XX 而自卑。</p>\n<p>承认人和人本身的不同，愿意公开承认人和人本身的不同。这一点才是被鼓励的。</p>\n<h4 id=\"然而现实是极其残酷的\"><a href=\"#然而现实是极其残酷的\" class=\"headerlink\" title=\"然而现实是极其残酷的\"></a>然而现实是极其残酷的</h4><p>现实永远是很残酷的，各种平权运动的进展通常都不顺利。我们在一开始说过，人权是具有普世性的，法律不过是约束其的手段。即使《同性婚姻法案》在美国被通过，并不代表美国人民就完全接受了同性恋。这就好像当年林肯 1862 年签署了《奴隶解放宣言》之后，黑人依然长期被歧视。一直到 20 世纪中叶美国一系列民权运动者的努力下，黑人才逐渐获得越发平等的权利。私以为中国的女权也处于一个法律保护但文化思想上接受程度非常糟糕的程度。</p>\n<p>社会的接受比法律的接受更加重要，也更加难争取。这就好像很多孩子看了两部 BL 的作品就天天把基挂在嘴边，好像非常支持同性恋一样，但等他们看到俩大叔抱在一起的时候却做出恶心的表情。你可以问自己这样的问题：如果你有一个哥哥或者弟弟而他是一名同性恋，你是否能接受。如果单纯在法律上被接受然而在心理上没有接受的话，平权并不是真正的成功。刚刷人人的时候看到有人举例说可能孩子以后会要挟说 “不给我买肾6，我就找个同性结婚去。” 而这正是这个问题的实质。无论是孩子还是父母都不从心理上接受同性恋是正常的，所以才可以进行要挟。</p>\n<p>心理上的接受是很多人难以逾越的一道坎，这加剧了平权运动推进的难度。加上人们长期以来的经验认识更是容易加剧这种印象。就好像有人会说出 “女人天生就不应该外出工作。” 这样子的话，这句话缺乏基本的逻辑支持，但是却是这个人的固有印象。人们曾经也把物体掉落和重量相关当作固有印象，但是通过实验可以很好的证明他们的错误。但权利这个问题非常的抽象，矫正一个人的观念非常难。甚至 “少数者” 在许多情况下会被理解成病态，就像同性恋在长期都被认为是一种疾病，性别认知障碍也长时间被认为是一种疾病。这对于他们的平权难度更加高。</p>\n<h4 id=\"相信，现实也许是非常美好的\"><a href=\"#相信，现实也许是非常美好的\" class=\"headerlink\" title=\"相信，现实也许是非常美好的\"></a>相信，现实也许是非常美好的</h4><p>每个人有各自的不同，有各自的差异。人类在过去只有繁重体力劳动，女性在当时很难争取到工作权是客观原因。而到现在，我们的工作愈发多样，人的生活本身也愈发多样。你的性别、你的肤色、你的性取向似乎都不会影响你找一份适合的工作。有了工作，人有基本的生存的能力，我始终相信坚持下去什么都会有的。</p>\n<p><strong>平权一定是会有的吧。</strong></p>\n<p>HeckPsi 长期支持 LGBT 平权、女性平权及其它人权平等。</p>"},{"title":"撞库是什么？说说12306是怎么泄露用户数据的","date":"2014-12-26T06:00:27.000Z","_content":"\n最近12306的数据库泄露事件闹得沸沸扬扬。事情还没调查清楚，12306就发出文章，极力撇清和自己的关系，说不是从自己这里泄露出去的，自己数据库里用户的密码都是加密过的，泄露的密码是明文的，然后把罪责推卸给那些抢票软件。\n\n但是这个理由站得住脚吗？其实不能。根据目前业内的普遍看法，这次的泄露是典型的撞库攻击，和12306完全脱离不了关系。\n\n那么，什么是撞库呢？\n\n<!--more-->\n\n简单说，撞库就是拿一个已经被攻破的数据库的数据去攻击另一个数据库。\n\n比如说，网站A的数据库存储着1000万用户的数据，这家网站的安全做得很差——用户的密码并没有被加密。而且，更不巧的是，这个网站被成功攻击，数据库里的所有数据都被骇客下载了下来。虽然说这个网站和12306订票网站一点关系都没有，但是用户的信息是存在一定的，甚至是很大的关联的，比如说用户使用了相同的邮箱注册了网站A和12306的订票网站。然而，这其中，更有人（许多人），用的是相同的密码注册的两个网站（甚至是所有的网站）。于是骇客尝试用网站A里的用户的邮箱和密码去登录12306订票系统。发现其中30%的用户（那可是有整整300万哦~）使用的是相同的邮箱和密码注册的12306订票系统。\n\n于是骇客拿着这300万可用的登录账号和密码就可以到订票网站内去查询更多的个人隐私信息，包括个人的地址、电话、身份证号码等只有12306才收集的个人隐私信息。\n\n这种攻击模式就被叫做撞库。事实上，12306订票网站这次撞库事件一共泄露了13万人的个人信息。说大不大，说小不小。\n\n那么，对于这种攻击，应该通过什么方法来防范呢？\n\n对于用户，应该尽量避免使用相同的密码，即使做不到不同网站都有不同的密码，也请尽量按照网站对个人隐私的影响使用3-4个不同的密码，并且定期更换。一旦发生这样的撞库事件，并查询到自己被黑，请尽快更换自己的密码。\n\n而对于服务提供商，撞库攻击真的是不可避免的吗？一派胡言~。防范的方法多如牛毛。\n\n首先，应该加强验证码机制以及IP验证机制，大大拖慢骇客对数百万的登录信息验证的时间。\n\n其次，对于个人隐私信息应该一次输入不予查看。比如身份证号码，显示在网页上的就应该是31010xxxxxxxxxxx17这样，使得骇客即使登录也获得不到有价值的信息。而这一点，在支付宝等安全系数比较高的网站上早已是这么实行的了。\n\n所以说，这次12306无论从什么角度来看都是脱离不了关系，这种以密码加了密这样的理由来不承认自己在网站安全上的失责实在是不负责任的做法。（一个连SSL证书都不肯买的公司，我们是无法奢望这家公司对安全有任何兴趣的。）\n\n","source":"_posts/what-is-hit-library.md","raw":"---\ntitle: 撞库是什么？说说12306是怎么泄露用户数据的\ndate: 2014-12-26 14:00:27\ntags: [12306,科普]\n---\n\n最近12306的数据库泄露事件闹得沸沸扬扬。事情还没调查清楚，12306就发出文章，极力撇清和自己的关系，说不是从自己这里泄露出去的，自己数据库里用户的密码都是加密过的，泄露的密码是明文的，然后把罪责推卸给那些抢票软件。\n\n但是这个理由站得住脚吗？其实不能。根据目前业内的普遍看法，这次的泄露是典型的撞库攻击，和12306完全脱离不了关系。\n\n那么，什么是撞库呢？\n\n<!--more-->\n\n简单说，撞库就是拿一个已经被攻破的数据库的数据去攻击另一个数据库。\n\n比如说，网站A的数据库存储着1000万用户的数据，这家网站的安全做得很差——用户的密码并没有被加密。而且，更不巧的是，这个网站被成功攻击，数据库里的所有数据都被骇客下载了下来。虽然说这个网站和12306订票网站一点关系都没有，但是用户的信息是存在一定的，甚至是很大的关联的，比如说用户使用了相同的邮箱注册了网站A和12306的订票网站。然而，这其中，更有人（许多人），用的是相同的密码注册的两个网站（甚至是所有的网站）。于是骇客尝试用网站A里的用户的邮箱和密码去登录12306订票系统。发现其中30%的用户（那可是有整整300万哦~）使用的是相同的邮箱和密码注册的12306订票系统。\n\n于是骇客拿着这300万可用的登录账号和密码就可以到订票网站内去查询更多的个人隐私信息，包括个人的地址、电话、身份证号码等只有12306才收集的个人隐私信息。\n\n这种攻击模式就被叫做撞库。事实上，12306订票网站这次撞库事件一共泄露了13万人的个人信息。说大不大，说小不小。\n\n那么，对于这种攻击，应该通过什么方法来防范呢？\n\n对于用户，应该尽量避免使用相同的密码，即使做不到不同网站都有不同的密码，也请尽量按照网站对个人隐私的影响使用3-4个不同的密码，并且定期更换。一旦发生这样的撞库事件，并查询到自己被黑，请尽快更换自己的密码。\n\n而对于服务提供商，撞库攻击真的是不可避免的吗？一派胡言~。防范的方法多如牛毛。\n\n首先，应该加强验证码机制以及IP验证机制，大大拖慢骇客对数百万的登录信息验证的时间。\n\n其次，对于个人隐私信息应该一次输入不予查看。比如身份证号码，显示在网页上的就应该是31010xxxxxxxxxxx17这样，使得骇客即使登录也获得不到有价值的信息。而这一点，在支付宝等安全系数比较高的网站上早已是这么实行的了。\n\n所以说，这次12306无论从什么角度来看都是脱离不了关系，这种以密码加了密这样的理由来不承认自己在网站安全上的失责实在是不负责任的做法。（一个连SSL证书都不肯买的公司，我们是无法奢望这家公司对安全有任何兴趣的。）\n\n","slug":"what-is-hit-library","published":1,"updated":"2016-04-23T12:46:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscy009w001gpp8zepaj6ppe","content":"<p>最近12306的数据库泄露事件闹得沸沸扬扬。事情还没调查清楚，12306就发出文章，极力撇清和自己的关系，说不是从自己这里泄露出去的，自己数据库里用户的密码都是加密过的，泄露的密码是明文的，然后把罪责推卸给那些抢票软件。</p>\n<p>但是这个理由站得住脚吗？其实不能。根据目前业内的普遍看法，这次的泄露是典型的撞库攻击，和12306完全脱离不了关系。</p>\n<p>那么，什么是撞库呢？</p>\n<a id=\"more\"></a>\n<p>简单说，撞库就是拿一个已经被攻破的数据库的数据去攻击另一个数据库。</p>\n<p>比如说，网站A的数据库存储着1000万用户的数据，这家网站的安全做得很差——用户的密码并没有被加密。而且，更不巧的是，这个网站被成功攻击，数据库里的所有数据都被骇客下载了下来。虽然说这个网站和12306订票网站一点关系都没有，但是用户的信息是存在一定的，甚至是很大的关联的，比如说用户使用了相同的邮箱注册了网站A和12306的订票网站。然而，这其中，更有人（许多人），用的是相同的密码注册的两个网站（甚至是所有的网站）。于是骇客尝试用网站A里的用户的邮箱和密码去登录12306订票系统。发现其中30%的用户（那可是有整整300万哦~）使用的是相同的邮箱和密码注册的12306订票系统。</p>\n<p>于是骇客拿着这300万可用的登录账号和密码就可以到订票网站内去查询更多的个人隐私信息，包括个人的地址、电话、身份证号码等只有12306才收集的个人隐私信息。</p>\n<p>这种攻击模式就被叫做撞库。事实上，12306订票网站这次撞库事件一共泄露了13万人的个人信息。说大不大，说小不小。</p>\n<p>那么，对于这种攻击，应该通过什么方法来防范呢？</p>\n<p>对于用户，应该尽量避免使用相同的密码，即使做不到不同网站都有不同的密码，也请尽量按照网站对个人隐私的影响使用3-4个不同的密码，并且定期更换。一旦发生这样的撞库事件，并查询到自己被黑，请尽快更换自己的密码。</p>\n<p>而对于服务提供商，撞库攻击真的是不可避免的吗？一派胡言~。防范的方法多如牛毛。</p>\n<p>首先，应该加强验证码机制以及IP验证机制，大大拖慢骇客对数百万的登录信息验证的时间。</p>\n<p>其次，对于个人隐私信息应该一次输入不予查看。比如身份证号码，显示在网页上的就应该是31010xxxxxxxxxxx17这样，使得骇客即使登录也获得不到有价值的信息。而这一点，在支付宝等安全系数比较高的网站上早已是这么实行的了。</p>\n<p>所以说，这次12306无论从什么角度来看都是脱离不了关系，这种以密码加了密这样的理由来不承认自己在网站安全上的失责实在是不负责任的做法。（一个连SSL证书都不肯买的公司，我们是无法奢望这家公司对安全有任何兴趣的。）</p>\n","excerpt":"<p>最近12306的数据库泄露事件闹得沸沸扬扬。事情还没调查清楚，12306就发出文章，极力撇清和自己的关系，说不是从自己这里泄露出去的，自己数据库里用户的密码都是加密过的，泄露的密码是明文的，然后把罪责推卸给那些抢票软件。</p>\n<p>但是这个理由站得住脚吗？其实不能。根据目前业内的普遍看法，这次的泄露是典型的撞库攻击，和12306完全脱离不了关系。</p>\n<p>那么，什么是撞库呢？</p>","more":"<p>简单说，撞库就是拿一个已经被攻破的数据库的数据去攻击另一个数据库。</p>\n<p>比如说，网站A的数据库存储着1000万用户的数据，这家网站的安全做得很差——用户的密码并没有被加密。而且，更不巧的是，这个网站被成功攻击，数据库里的所有数据都被骇客下载了下来。虽然说这个网站和12306订票网站一点关系都没有，但是用户的信息是存在一定的，甚至是很大的关联的，比如说用户使用了相同的邮箱注册了网站A和12306的订票网站。然而，这其中，更有人（许多人），用的是相同的密码注册的两个网站（甚至是所有的网站）。于是骇客尝试用网站A里的用户的邮箱和密码去登录12306订票系统。发现其中30%的用户（那可是有整整300万哦~）使用的是相同的邮箱和密码注册的12306订票系统。</p>\n<p>于是骇客拿着这300万可用的登录账号和密码就可以到订票网站内去查询更多的个人隐私信息，包括个人的地址、电话、身份证号码等只有12306才收集的个人隐私信息。</p>\n<p>这种攻击模式就被叫做撞库。事实上，12306订票网站这次撞库事件一共泄露了13万人的个人信息。说大不大，说小不小。</p>\n<p>那么，对于这种攻击，应该通过什么方法来防范呢？</p>\n<p>对于用户，应该尽量避免使用相同的密码，即使做不到不同网站都有不同的密码，也请尽量按照网站对个人隐私的影响使用3-4个不同的密码，并且定期更换。一旦发生这样的撞库事件，并查询到自己被黑，请尽快更换自己的密码。</p>\n<p>而对于服务提供商，撞库攻击真的是不可避免的吗？一派胡言~。防范的方法多如牛毛。</p>\n<p>首先，应该加强验证码机制以及IP验证机制，大大拖慢骇客对数百万的登录信息验证的时间。</p>\n<p>其次，对于个人隐私信息应该一次输入不予查看。比如身份证号码，显示在网页上的就应该是31010xxxxxxxxxxx17这样，使得骇客即使登录也获得不到有价值的信息。而这一点，在支付宝等安全系数比较高的网站上早已是这么实行的了。</p>\n<p>所以说，这次12306无论从什么角度来看都是脱离不了关系，这种以密码加了密这样的理由来不承认自己在网站安全上的失责实在是不负责任的做法。（一个连SSL证书都不肯买的公司，我们是无法奢望这家公司对安全有任何兴趣的。）</p>"},{"title":"为何有应用宁可使用一套奇丑无比的界面，也不愿意跟进 Material Design？","date":"2015-03-29T04:51:12.000Z","_content":"\n这个问题其实是相当复杂的。从 Google 的发布会提出 Material Design 的设计规范以来，许多人都为 Material Design 所惊艳到。但事实上，大多数应用都无法很好及时跟进这一设计标准。这一点，尤其是在国内，显得更为的突出。我自己实践 Material Design 也有了一段时间，我觉得至少有三点原因。\n\n<!--more-->\n\n### 一、Material Design 设计语言非常复杂，学习成本高，实现难度大。\n\n于 Material Design 复杂的设计语言相比，我敢说，学习难度比你跟进 iOS 的平面化的开发标准要困难十倍以上。Material Design 并不是使用 Google 提供的这些控件、图片设计出来的东西就是 Material Design 了。Material Design 的核心是一个高度抽象化的设计逻辑是对真实事物的逻辑层面的模拟，比起 iOS 以前那种单纯视觉上的拟物比起来，这是一种非常高层次的拟物概念，理解起来确实比较费事。\n\n举个例子来说，\n当你有一个如同这样的页面布局。\n\n![](http://cdn.heckpsi.com/1003_1.jpg)\n\n这样的页面布局下，当用户手指从下向上滚动屏幕的时候，我们先想象一下，这个布局应该如何跟随调整？通常情况下，我们会选择整页内容一起向上滚动。但实际上，这种方法并不是很正确。\n\n我们仔细观察这个布局，去掉状态栏，这个页面也有五个不同的“色块”组成的独立元素。他们分别是 用来选择操作的顶栏Toolbar，然后是 Featured Image，然后是 Topic，下方的 Detail，和一个标记状态的 Button。\n\n然后我们把这五个东西想象成五张真实存在的纸片，他们堆叠在一起。\n\n当你移动下面的 Detail 页的时候，其他元素其实应该有着不同的相对运动才对，而不是整体上移。比如 Featured Image 不动，下面的纸片从它上方运动覆盖移动过去，而推到顶时，Topic 页可以成为这页的标题，而下方的 Detail 也继续移动。这个设计来自于 Google I/O 2014 App 的设计。（此应用源代码可以到 [GitHub](https://github.com/romainguy/google-io-2014) 下载\n\n这样的设计逻辑并不是来自于哪个现成的模板，而是针对你应用的不同布局不同考虑的，甚至是像素级的细节考虑，对设计者的要求很高，对程序实现的要求同样也很高。这是 Material Design 中许多细腻的 “激动人心的细节” 背后深藏的设计逻辑。更何况，我只能说，我举的这个例子也是 Material Design 复杂语言的一个很小的部分而已。\n\nMaterial Design 的设备兼容性是比较差的，当然比起当年 Holo 设计在 Android 2.x 上的完全不兼容不同，Material Design 是可以做到 4.x 的半兼容的。所谓半兼容，指的是使用 Google 提供的控件和兼容包，可以基本显示。但是比如状态栏的颜色的设置、各个控件的 elevation 阴影、selectableBackground 的按钮响应动画都会失效。\n\n### 二、Material Design 的设备兼容性不够好。\n\n![](http://cdn.heckpsi.com/1003_3.jpg)\n\n（如上图这样的 Elevation 效果，在 Android 4.x 上会被直接“压扁”显示）\n\n而与 Android 2.x 更是完全不兼容了。开发者即使愿意忍痛让 4.x 用户看一个不完整的设计，也不能满足 2.x 用户的兼容需求。\n\n虽然这种苛刻的兼容需求对于大多数应用来说都不是很有关系，但是比如像 QQ（最低兼容至 Android 1.6）、微信（最低兼容至 Android 2.2）这样的应用，他们的市场的广度迫使他们不能尝试这样的事情，毕竟在中国，使用 Android 2.x 的手机的用户依然还是有相当一部分的。\n\n在这样的背景下，Material Design 在 QQ、微信、淘宝 这样的应用上，短时间是不可能实现的。他们处于兼容性的考量，需要使用系统最基础的控件以及利用这些控件组合的自定义控件，而不能去使用高版本才拥有的特性。这样的应用又卡、又慢、又丑也是有一定客观原因的。\n\n### 三、Material Design 的一些其他劣势。\n\n当然上述的两点原因并不是一些大厂商不使用 Material Design，宁可用自己设计的极丑无比的界面的唯一原因。还有一些细碎的原因，也是左右这个设计普及受阻的砝码。比如像阿里、腾讯、百度这样的企业，他们并不是设计驱动的，而是商业驱动的。如果跟进 Material Design，势必会影响他们的一些商业利益。\n\n比如说，页面的逻辑会受到牵制，他们再也无法放一些活动、广告的按钮放在用户最易点击的地方，颜色也不能总是整片整片的大红大绿。一些页面的访问频次会随着逻辑层级变深而降低。这也是当时 微信 5.2 测试版刚开始试图 Holo 化又叫停的重要原因。\n\n![](http://cdn.heckpsi.com/1003_4.jpg)\n\n（微信 5.2 内测版截图，图源网络）\n更有一些想法是希望 Android 和 iOS 能拥有一样的 UI，使得用户降低学习成本，更快上手，更好赚钱。所以在 Android 上出现底栏两层皮、三层皮什么的就是出于这样的想法。\n\n在目前中国市场上，用户对设计的品味还处于一个比较初级的阶段，对设计几乎没有要求。而你就算有要求，你为了使用应用也愿意去做这样的妥协。开发者做跟进花费的代价远小于他们的收益。恐怕这是许多公司宁可设计一套奇丑无比的 UI，也不愿意跟进 Material Design 的核心原因。\n\n","source":"_posts/why-material-design-pushes-difficult-in-china.md","raw":"---\ntitle: 为何有应用宁可使用一套奇丑无比的界面，也不愿意跟进 Material Design？\ndate: 2015-03-29 12:51:12\ntags: [设计,Google,Android]\n---\n\n这个问题其实是相当复杂的。从 Google 的发布会提出 Material Design 的设计规范以来，许多人都为 Material Design 所惊艳到。但事实上，大多数应用都无法很好及时跟进这一设计标准。这一点，尤其是在国内，显得更为的突出。我自己实践 Material Design 也有了一段时间，我觉得至少有三点原因。\n\n<!--more-->\n\n### 一、Material Design 设计语言非常复杂，学习成本高，实现难度大。\n\n于 Material Design 复杂的设计语言相比，我敢说，学习难度比你跟进 iOS 的平面化的开发标准要困难十倍以上。Material Design 并不是使用 Google 提供的这些控件、图片设计出来的东西就是 Material Design 了。Material Design 的核心是一个高度抽象化的设计逻辑是对真实事物的逻辑层面的模拟，比起 iOS 以前那种单纯视觉上的拟物比起来，这是一种非常高层次的拟物概念，理解起来确实比较费事。\n\n举个例子来说，\n当你有一个如同这样的页面布局。\n\n![](http://cdn.heckpsi.com/1003_1.jpg)\n\n这样的页面布局下，当用户手指从下向上滚动屏幕的时候，我们先想象一下，这个布局应该如何跟随调整？通常情况下，我们会选择整页内容一起向上滚动。但实际上，这种方法并不是很正确。\n\n我们仔细观察这个布局，去掉状态栏，这个页面也有五个不同的“色块”组成的独立元素。他们分别是 用来选择操作的顶栏Toolbar，然后是 Featured Image，然后是 Topic，下方的 Detail，和一个标记状态的 Button。\n\n然后我们把这五个东西想象成五张真实存在的纸片，他们堆叠在一起。\n\n当你移动下面的 Detail 页的时候，其他元素其实应该有着不同的相对运动才对，而不是整体上移。比如 Featured Image 不动，下面的纸片从它上方运动覆盖移动过去，而推到顶时，Topic 页可以成为这页的标题，而下方的 Detail 也继续移动。这个设计来自于 Google I/O 2014 App 的设计。（此应用源代码可以到 [GitHub](https://github.com/romainguy/google-io-2014) 下载\n\n这样的设计逻辑并不是来自于哪个现成的模板，而是针对你应用的不同布局不同考虑的，甚至是像素级的细节考虑，对设计者的要求很高，对程序实现的要求同样也很高。这是 Material Design 中许多细腻的 “激动人心的细节” 背后深藏的设计逻辑。更何况，我只能说，我举的这个例子也是 Material Design 复杂语言的一个很小的部分而已。\n\nMaterial Design 的设备兼容性是比较差的，当然比起当年 Holo 设计在 Android 2.x 上的完全不兼容不同，Material Design 是可以做到 4.x 的半兼容的。所谓半兼容，指的是使用 Google 提供的控件和兼容包，可以基本显示。但是比如状态栏的颜色的设置、各个控件的 elevation 阴影、selectableBackground 的按钮响应动画都会失效。\n\n### 二、Material Design 的设备兼容性不够好。\n\n![](http://cdn.heckpsi.com/1003_3.jpg)\n\n（如上图这样的 Elevation 效果，在 Android 4.x 上会被直接“压扁”显示）\n\n而与 Android 2.x 更是完全不兼容了。开发者即使愿意忍痛让 4.x 用户看一个不完整的设计，也不能满足 2.x 用户的兼容需求。\n\n虽然这种苛刻的兼容需求对于大多数应用来说都不是很有关系，但是比如像 QQ（最低兼容至 Android 1.6）、微信（最低兼容至 Android 2.2）这样的应用，他们的市场的广度迫使他们不能尝试这样的事情，毕竟在中国，使用 Android 2.x 的手机的用户依然还是有相当一部分的。\n\n在这样的背景下，Material Design 在 QQ、微信、淘宝 这样的应用上，短时间是不可能实现的。他们处于兼容性的考量，需要使用系统最基础的控件以及利用这些控件组合的自定义控件，而不能去使用高版本才拥有的特性。这样的应用又卡、又慢、又丑也是有一定客观原因的。\n\n### 三、Material Design 的一些其他劣势。\n\n当然上述的两点原因并不是一些大厂商不使用 Material Design，宁可用自己设计的极丑无比的界面的唯一原因。还有一些细碎的原因，也是左右这个设计普及受阻的砝码。比如像阿里、腾讯、百度这样的企业，他们并不是设计驱动的，而是商业驱动的。如果跟进 Material Design，势必会影响他们的一些商业利益。\n\n比如说，页面的逻辑会受到牵制，他们再也无法放一些活动、广告的按钮放在用户最易点击的地方，颜色也不能总是整片整片的大红大绿。一些页面的访问频次会随着逻辑层级变深而降低。这也是当时 微信 5.2 测试版刚开始试图 Holo 化又叫停的重要原因。\n\n![](http://cdn.heckpsi.com/1003_4.jpg)\n\n（微信 5.2 内测版截图，图源网络）\n更有一些想法是希望 Android 和 iOS 能拥有一样的 UI，使得用户降低学习成本，更快上手，更好赚钱。所以在 Android 上出现底栏两层皮、三层皮什么的就是出于这样的想法。\n\n在目前中国市场上，用户对设计的品味还处于一个比较初级的阶段，对设计几乎没有要求。而你就算有要求，你为了使用应用也愿意去做这样的妥协。开发者做跟进花费的代价远小于他们的收益。恐怕这是许多公司宁可设计一套奇丑无比的 UI，也不愿意跟进 Material Design 的核心原因。\n\n","slug":"why-material-design-pushes-difficult-in-china","published":1,"updated":"2016-05-15T03:20:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscy009y001ipp8z2e4j30j2","content":"<p>这个问题其实是相当复杂的。从 Google 的发布会提出 Material Design 的设计规范以来，许多人都为 Material Design 所惊艳到。但事实上，大多数应用都无法很好及时跟进这一设计标准。这一点，尤其是在国内，显得更为的突出。我自己实践 Material Design 也有了一段时间，我觉得至少有三点原因。</p>\n<a id=\"more\"></a>\n<h3 id=\"一、Material-Design-设计语言非常复杂，学习成本高，实现难度大。\"><a href=\"#一、Material-Design-设计语言非常复杂，学习成本高，实现难度大。\" class=\"headerlink\" title=\"一、Material Design 设计语言非常复杂，学习成本高，实现难度大。\"></a>一、Material Design 设计语言非常复杂，学习成本高，实现难度大。</h3><p>于 Material Design 复杂的设计语言相比，我敢说，学习难度比你跟进 iOS 的平面化的开发标准要困难十倍以上。Material Design 并不是使用 Google 提供的这些控件、图片设计出来的东西就是 Material Design 了。Material Design 的核心是一个高度抽象化的设计逻辑是对真实事物的逻辑层面的模拟，比起 iOS 以前那种单纯视觉上的拟物比起来，这是一种非常高层次的拟物概念，理解起来确实比较费事。</p>\n<p>举个例子来说，<br>当你有一个如同这样的页面布局。</p>\n<p><img src=\"http://cdn.heckpsi.com/1003_1.jpg\" alt=\"\"></p>\n<p>这样的页面布局下，当用户手指从下向上滚动屏幕的时候，我们先想象一下，这个布局应该如何跟随调整？通常情况下，我们会选择整页内容一起向上滚动。但实际上，这种方法并不是很正确。</p>\n<p>我们仔细观察这个布局，去掉状态栏，这个页面也有五个不同的“色块”组成的独立元素。他们分别是 用来选择操作的顶栏Toolbar，然后是 Featured Image，然后是 Topic，下方的 Detail，和一个标记状态的 Button。</p>\n<p>然后我们把这五个东西想象成五张真实存在的纸片，他们堆叠在一起。</p>\n<p>当你移动下面的 Detail 页的时候，其他元素其实应该有着不同的相对运动才对，而不是整体上移。比如 Featured Image 不动，下面的纸片从它上方运动覆盖移动过去，而推到顶时，Topic 页可以成为这页的标题，而下方的 Detail 也继续移动。这个设计来自于 Google I/O 2014 App 的设计。（此应用源代码可以到 <a href=\"https://github.com/romainguy/google-io-2014\" target=\"_blank\" rel=\"external\">GitHub</a> 下载</p>\n<p>这样的设计逻辑并不是来自于哪个现成的模板，而是针对你应用的不同布局不同考虑的，甚至是像素级的细节考虑，对设计者的要求很高，对程序实现的要求同样也很高。这是 Material Design 中许多细腻的 “激动人心的细节” 背后深藏的设计逻辑。更何况，我只能说，我举的这个例子也是 Material Design 复杂语言的一个很小的部分而已。</p>\n<p>Material Design 的设备兼容性是比较差的，当然比起当年 Holo 设计在 Android 2.x 上的完全不兼容不同，Material Design 是可以做到 4.x 的半兼容的。所谓半兼容，指的是使用 Google 提供的控件和兼容包，可以基本显示。但是比如状态栏的颜色的设置、各个控件的 elevation 阴影、selectableBackground 的按钮响应动画都会失效。</p>\n<h3 id=\"二、Material-Design-的设备兼容性不够好。\"><a href=\"#二、Material-Design-的设备兼容性不够好。\" class=\"headerlink\" title=\"二、Material Design 的设备兼容性不够好。\"></a>二、Material Design 的设备兼容性不够好。</h3><p><img src=\"http://cdn.heckpsi.com/1003_3.jpg\" alt=\"\"></p>\n<p>（如上图这样的 Elevation 效果，在 Android 4.x 上会被直接“压扁”显示）</p>\n<p>而与 Android 2.x 更是完全不兼容了。开发者即使愿意忍痛让 4.x 用户看一个不完整的设计，也不能满足 2.x 用户的兼容需求。</p>\n<p>虽然这种苛刻的兼容需求对于大多数应用来说都不是很有关系，但是比如像 QQ（最低兼容至 Android 1.6）、微信（最低兼容至 Android 2.2）这样的应用，他们的市场的广度迫使他们不能尝试这样的事情，毕竟在中国，使用 Android 2.x 的手机的用户依然还是有相当一部分的。</p>\n<p>在这样的背景下，Material Design 在 QQ、微信、淘宝 这样的应用上，短时间是不可能实现的。他们处于兼容性的考量，需要使用系统最基础的控件以及利用这些控件组合的自定义控件，而不能去使用高版本才拥有的特性。这样的应用又卡、又慢、又丑也是有一定客观原因的。</p>\n<h3 id=\"三、Material-Design-的一些其他劣势。\"><a href=\"#三、Material-Design-的一些其他劣势。\" class=\"headerlink\" title=\"三、Material Design 的一些其他劣势。\"></a>三、Material Design 的一些其他劣势。</h3><p>当然上述的两点原因并不是一些大厂商不使用 Material Design，宁可用自己设计的极丑无比的界面的唯一原因。还有一些细碎的原因，也是左右这个设计普及受阻的砝码。比如像阿里、腾讯、百度这样的企业，他们并不是设计驱动的，而是商业驱动的。如果跟进 Material Design，势必会影响他们的一些商业利益。</p>\n<p>比如说，页面的逻辑会受到牵制，他们再也无法放一些活动、广告的按钮放在用户最易点击的地方，颜色也不能总是整片整片的大红大绿。一些页面的访问频次会随着逻辑层级变深而降低。这也是当时 微信 5.2 测试版刚开始试图 Holo 化又叫停的重要原因。</p>\n<p><img src=\"http://cdn.heckpsi.com/1003_4.jpg\" alt=\"\"></p>\n<p>（微信 5.2 内测版截图，图源网络）<br>更有一些想法是希望 Android 和 iOS 能拥有一样的 UI，使得用户降低学习成本，更快上手，更好赚钱。所以在 Android 上出现底栏两层皮、三层皮什么的就是出于这样的想法。</p>\n<p>在目前中国市场上，用户对设计的品味还处于一个比较初级的阶段，对设计几乎没有要求。而你就算有要求，你为了使用应用也愿意去做这样的妥协。开发者做跟进花费的代价远小于他们的收益。恐怕这是许多公司宁可设计一套奇丑无比的 UI，也不愿意跟进 Material Design 的核心原因。</p>\n","excerpt":"<p>这个问题其实是相当复杂的。从 Google 的发布会提出 Material Design 的设计规范以来，许多人都为 Material Design 所惊艳到。但事实上，大多数应用都无法很好及时跟进这一设计标准。这一点，尤其是在国内，显得更为的突出。我自己实践 Material Design 也有了一段时间，我觉得至少有三点原因。</p>","more":"<h3 id=\"一、Material-Design-设计语言非常复杂，学习成本高，实现难度大。\"><a href=\"#一、Material-Design-设计语言非常复杂，学习成本高，实现难度大。\" class=\"headerlink\" title=\"一、Material Design 设计语言非常复杂，学习成本高，实现难度大。\"></a>一、Material Design 设计语言非常复杂，学习成本高，实现难度大。</h3><p>于 Material Design 复杂的设计语言相比，我敢说，学习难度比你跟进 iOS 的平面化的开发标准要困难十倍以上。Material Design 并不是使用 Google 提供的这些控件、图片设计出来的东西就是 Material Design 了。Material Design 的核心是一个高度抽象化的设计逻辑是对真实事物的逻辑层面的模拟，比起 iOS 以前那种单纯视觉上的拟物比起来，这是一种非常高层次的拟物概念，理解起来确实比较费事。</p>\n<p>举个例子来说，<br>当你有一个如同这样的页面布局。</p>\n<p><img src=\"http://cdn.heckpsi.com/1003_1.jpg\" alt=\"\"></p>\n<p>这样的页面布局下，当用户手指从下向上滚动屏幕的时候，我们先想象一下，这个布局应该如何跟随调整？通常情况下，我们会选择整页内容一起向上滚动。但实际上，这种方法并不是很正确。</p>\n<p>我们仔细观察这个布局，去掉状态栏，这个页面也有五个不同的“色块”组成的独立元素。他们分别是 用来选择操作的顶栏Toolbar，然后是 Featured Image，然后是 Topic，下方的 Detail，和一个标记状态的 Button。</p>\n<p>然后我们把这五个东西想象成五张真实存在的纸片，他们堆叠在一起。</p>\n<p>当你移动下面的 Detail 页的时候，其他元素其实应该有着不同的相对运动才对，而不是整体上移。比如 Featured Image 不动，下面的纸片从它上方运动覆盖移动过去，而推到顶时，Topic 页可以成为这页的标题，而下方的 Detail 也继续移动。这个设计来自于 Google I/O 2014 App 的设计。（此应用源代码可以到 <a href=\"https://github.com/romainguy/google-io-2014\">GitHub</a> 下载</p>\n<p>这样的设计逻辑并不是来自于哪个现成的模板，而是针对你应用的不同布局不同考虑的，甚至是像素级的细节考虑，对设计者的要求很高，对程序实现的要求同样也很高。这是 Material Design 中许多细腻的 “激动人心的细节” 背后深藏的设计逻辑。更何况，我只能说，我举的这个例子也是 Material Design 复杂语言的一个很小的部分而已。</p>\n<p>Material Design 的设备兼容性是比较差的，当然比起当年 Holo 设计在 Android 2.x 上的完全不兼容不同，Material Design 是可以做到 4.x 的半兼容的。所谓半兼容，指的是使用 Google 提供的控件和兼容包，可以基本显示。但是比如状态栏的颜色的设置、各个控件的 elevation 阴影、selectableBackground 的按钮响应动画都会失效。</p>\n<h3 id=\"二、Material-Design-的设备兼容性不够好。\"><a href=\"#二、Material-Design-的设备兼容性不够好。\" class=\"headerlink\" title=\"二、Material Design 的设备兼容性不够好。\"></a>二、Material Design 的设备兼容性不够好。</h3><p><img src=\"http://cdn.heckpsi.com/1003_3.jpg\" alt=\"\"></p>\n<p>（如上图这样的 Elevation 效果，在 Android 4.x 上会被直接“压扁”显示）</p>\n<p>而与 Android 2.x 更是完全不兼容了。开发者即使愿意忍痛让 4.x 用户看一个不完整的设计，也不能满足 2.x 用户的兼容需求。</p>\n<p>虽然这种苛刻的兼容需求对于大多数应用来说都不是很有关系，但是比如像 QQ（最低兼容至 Android 1.6）、微信（最低兼容至 Android 2.2）这样的应用，他们的市场的广度迫使他们不能尝试这样的事情，毕竟在中国，使用 Android 2.x 的手机的用户依然还是有相当一部分的。</p>\n<p>在这样的背景下，Material Design 在 QQ、微信、淘宝 这样的应用上，短时间是不可能实现的。他们处于兼容性的考量，需要使用系统最基础的控件以及利用这些控件组合的自定义控件，而不能去使用高版本才拥有的特性。这样的应用又卡、又慢、又丑也是有一定客观原因的。</p>\n<h3 id=\"三、Material-Design-的一些其他劣势。\"><a href=\"#三、Material-Design-的一些其他劣势。\" class=\"headerlink\" title=\"三、Material Design 的一些其他劣势。\"></a>三、Material Design 的一些其他劣势。</h3><p>当然上述的两点原因并不是一些大厂商不使用 Material Design，宁可用自己设计的极丑无比的界面的唯一原因。还有一些细碎的原因，也是左右这个设计普及受阻的砝码。比如像阿里、腾讯、百度这样的企业，他们并不是设计驱动的，而是商业驱动的。如果跟进 Material Design，势必会影响他们的一些商业利益。</p>\n<p>比如说，页面的逻辑会受到牵制，他们再也无法放一些活动、广告的按钮放在用户最易点击的地方，颜色也不能总是整片整片的大红大绿。一些页面的访问频次会随着逻辑层级变深而降低。这也是当时 微信 5.2 测试版刚开始试图 Holo 化又叫停的重要原因。</p>\n<p><img src=\"http://cdn.heckpsi.com/1003_4.jpg\" alt=\"\"></p>\n<p>（微信 5.2 内测版截图，图源网络）<br>更有一些想法是希望 Android 和 iOS 能拥有一样的 UI，使得用户降低学习成本，更快上手，更好赚钱。所以在 Android 上出现底栏两层皮、三层皮什么的就是出于这样的想法。</p>\n<p>在目前中国市场上，用户对设计的品味还处于一个比较初级的阶段，对设计几乎没有要求。而你就算有要求，你为了使用应用也愿意去做这样的妥协。开发者做跟进花费的代价远小于他们的收益。恐怕这是许多公司宁可设计一套奇丑无比的 UI，也不愿意跟进 Material Design 的核心原因。</p>"},{"title":"什么是真正的视网膜屏幕","date":"2013-08-24T03:21:50.000Z","_content":"\n编译自 Why Retina Isn't Enough 作者：John Brownlee 日期：2012年7月15日\n\n<!--more-->\n\n注：文中所说的 20/20 视力是英国标准，大约是中国所采用的标准对数视力表的 4.9-5.0 或 0.9-1.0\n\n借以此文来回应前面某主页菌所说的 538 PPI 远超了人类极限。人类的极限还远得很...\n\n为什么Retina是不够的呢？\n\n在这一点上，大家都知道，史蒂夫·乔布斯，表演大师，他早在 2010 年推出 iPhone 4 的 Retina 显示屏就捏造了事实。\n\n史蒂夫·乔布斯当时是这样说的：\n\n研究表明，当你持有距离你眼睛大约 25 或 30 厘米的东西，人类视网膜的极限能力能够区分 300PPI。\n\n苹果定义这样一个 Retina 显示屏，而当 New iPad 在 3 月发布时，蒂姆·库克自己澄清了定义的视网膜上的一点：\n\n您可能还记得，与 iPhone 保持在一个正常的距离，你的视网膜无法分辨单个像素。当 iPad 保持在一个正常的距离 [38厘米]，它是相同的结果。\n\n换句话说，因为一般人使用平板比他们的电话离眼睛更远，新的 iPad 并不需要有 iPhone 的小像素，这意味着新 iPad 像素密度 264 PPI。同样，人坐在更远的地方使用他们的 MacBook Pro 笔记本电脑，这意味着他们的视网膜显示只需要 220 PPI。\n\n到目前为止，一切都不错。只有一个问题：史蒂夫·乔布斯说，人眼从 25 厘米观看显示器，无法分辨单个像素密度高达 300 PPI 的说法本身就是错误的。真正的数字是接近 900 PPI 。苹果的 Retina 显示屏只有三分之一的密度。\n\n为什么苹果的“视网膜”是不是真正的视网膜\n\n苹果使用的 Retina 作为一个营销术语，它是伟大的。但是，这也意味着，它涉及到的分辨率是不正确。从现在起过十年，我们将发现所有自己的 Mac，iPhone 和 iPad 屏幕那么差，看着 iPhone 4S 或新的 MacBook Pro 将会像现在去看 2002 年的 1024 x 768 的 CRT 是那样曾经令我们兴奋的东西。\n\n要理解为什么远没有达到标准是比较复杂的。你需要了解史蒂夫·乔布斯如何想出了他最初的 Retina 定义：总之，他基于对一个人有 20/20 的视力。似乎是合理的，因为 20/20 是拥有完美视力的代名词。\n\n唯一的问题是什么？ 20/20 是不完美的视力。\n\n苹果视网膜的定义是根据老年人的视野来定义的\n\n当我们谈论一个人的视力 20/20，我们实际上指的是什么？如果一个人有 20/20 的视力，这意味着一个人站在 6 米远看清英制视力表第八排内容。这曾被认为是标准视力。\n\n不过，虽然 20/20 的视力传统上是指“标准视力”大多数的研究表明，正常的视力实际上是远远优于 20/20。事实上，视力正常的人通常直到他们60岁或70岁才会降低到 20/20！\n\n明白了吗？苹果视网膜的定义是根据老年人的视野。\n\n人眼的分辨率是多少？\n\n你的眼睛能看到的最小的像素有多小？比你想象的更小。\n那么，什么是视觉的限制？要讨论这个问题，我们首先需要一个技术名词解释：视角。\n大家可以看下面这个E字，它由15个像素组成，包括11个黑色像素和4个白色像素，在与这个E字的距离到达某个特定值时，你的眼睛就无法看出那两条在黑色像素之间的白线，此时E字两端在观察眼内结点形成的夹角就是视角。如果你的视力水平是“20/20”，代表你的视角是1分，也就是1/60度。\n\n![](http://cdn.heckpsi.com/E-eye-sight-test.jpg)\n\n但是，正如我们已经看到的，20/20 的视力并不意味着完美的视觉，可以说甚至低于全世界一半人的视力。像素太大。如何变小，才能得到真正的 Retina 显示屏？\n\n不幸的是，人眼可以看到的极限目前还不能确定。根据 DisplayMate 的总裁 Raymond Soneira 说，一个完美的人类视网膜的分辨率为每像素 0.6 弧分。索内拉的分辨率虽然没有被普遍接受。其他人不同意，认为眼睛是强大得多。  J.Blackware 在美国光学学会早在 1946 年，确定了人眼的分辨率是实际上更接近 0.35 弧分。一个真正的 Retina 显示屏，像素要比 iPhone 4S 的 Retina 小 65%。一些研究人类视觉的限制认为还会更小一些。\n然而，科学家们还是普遍同意大多数人视线的限制，它不能分辨单个像素的小于 0.3 弧分，徘徊在 0.3 和 0.4 之间是大多数人的视觉极限水平。\n\n换句话说，无可争议地符合人眼的分辨率，被认为是真正的视网膜的屏幕，它需要有从平均收视距离不大于 0.3 弧分大小的像素。因此计算可得真正的视网膜屏幕的对照表\n\n| Model               | Screen Size (Inches) | Average Distance | Retina Res (Apple) | True Retina Res | PPI  |\n| ------------------- | -------------------- | ---------------- | ------------------ | --------------- | ---- |\n| iPhone              | 3.5                  | 12               | 960 x 640          | 2772 x 1848     | 952  |\n| iPad                | 9.7                  | 15               | 2048 x 1536        | 5968 x 4486     | 769  |\n| 11-inch MacBook Air | 11.6                 | 22               | 2732 x 1536        | 5184 x 2916     | 513  |\n| 13-Inch MacBook Air | 13.3                 | 22               | 2880 x 1800        | 5872 x 3670     | 520  |\n| 15-Inch MacBook Pro | 15.4                 | 24               | 2880 x 1800        | 6096 x 3810     | 467  |\n| 21-Inch iMac        | 21.5                 | 28               | 3840 x 2160        | 7408 x 4168     | 395  |\n| 27-Inch iMac        | 27                   | 28               | 5120 x 2880        | 9120 x 5130     | 388  |\n\n译者：可见，要想达到一款手机日常使用达到人类视网膜极限需要达到952PPI，这是现在技术所不能达到的。而我们确实需要真正的视网膜屏幕，因为显然物体越精细，越是显得真实。完美的显示屏要能达到和人眼看到真实的图像一模一样，这是显示器的目标，而且还很遥远。\n\n译者注：请无视我的翻译腔。\n\n","source":"_posts/why-retina-isnt-enough.md","raw":"---\ntitle: 什么是真正的视网膜屏幕\ndate: 2013-08-24 11:21:50\ntags: [Apple,屏幕]\n---\n\n编译自 Why Retina Isn't Enough 作者：John Brownlee 日期：2012年7月15日\n\n<!--more-->\n\n注：文中所说的 20/20 视力是英国标准，大约是中国所采用的标准对数视力表的 4.9-5.0 或 0.9-1.0\n\n借以此文来回应前面某主页菌所说的 538 PPI 远超了人类极限。人类的极限还远得很...\n\n为什么Retina是不够的呢？\n\n在这一点上，大家都知道，史蒂夫·乔布斯，表演大师，他早在 2010 年推出 iPhone 4 的 Retina 显示屏就捏造了事实。\n\n史蒂夫·乔布斯当时是这样说的：\n\n研究表明，当你持有距离你眼睛大约 25 或 30 厘米的东西，人类视网膜的极限能力能够区分 300PPI。\n\n苹果定义这样一个 Retina 显示屏，而当 New iPad 在 3 月发布时，蒂姆·库克自己澄清了定义的视网膜上的一点：\n\n您可能还记得，与 iPhone 保持在一个正常的距离，你的视网膜无法分辨单个像素。当 iPad 保持在一个正常的距离 [38厘米]，它是相同的结果。\n\n换句话说，因为一般人使用平板比他们的电话离眼睛更远，新的 iPad 并不需要有 iPhone 的小像素，这意味着新 iPad 像素密度 264 PPI。同样，人坐在更远的地方使用他们的 MacBook Pro 笔记本电脑，这意味着他们的视网膜显示只需要 220 PPI。\n\n到目前为止，一切都不错。只有一个问题：史蒂夫·乔布斯说，人眼从 25 厘米观看显示器，无法分辨单个像素密度高达 300 PPI 的说法本身就是错误的。真正的数字是接近 900 PPI 。苹果的 Retina 显示屏只有三分之一的密度。\n\n为什么苹果的“视网膜”是不是真正的视网膜\n\n苹果使用的 Retina 作为一个营销术语，它是伟大的。但是，这也意味着，它涉及到的分辨率是不正确。从现在起过十年，我们将发现所有自己的 Mac，iPhone 和 iPad 屏幕那么差，看着 iPhone 4S 或新的 MacBook Pro 将会像现在去看 2002 年的 1024 x 768 的 CRT 是那样曾经令我们兴奋的东西。\n\n要理解为什么远没有达到标准是比较复杂的。你需要了解史蒂夫·乔布斯如何想出了他最初的 Retina 定义：总之，他基于对一个人有 20/20 的视力。似乎是合理的，因为 20/20 是拥有完美视力的代名词。\n\n唯一的问题是什么？ 20/20 是不完美的视力。\n\n苹果视网膜的定义是根据老年人的视野来定义的\n\n当我们谈论一个人的视力 20/20，我们实际上指的是什么？如果一个人有 20/20 的视力，这意味着一个人站在 6 米远看清英制视力表第八排内容。这曾被认为是标准视力。\n\n不过，虽然 20/20 的视力传统上是指“标准视力”大多数的研究表明，正常的视力实际上是远远优于 20/20。事实上，视力正常的人通常直到他们60岁或70岁才会降低到 20/20！\n\n明白了吗？苹果视网膜的定义是根据老年人的视野。\n\n人眼的分辨率是多少？\n\n你的眼睛能看到的最小的像素有多小？比你想象的更小。\n那么，什么是视觉的限制？要讨论这个问题，我们首先需要一个技术名词解释：视角。\n大家可以看下面这个E字，它由15个像素组成，包括11个黑色像素和4个白色像素，在与这个E字的距离到达某个特定值时，你的眼睛就无法看出那两条在黑色像素之间的白线，此时E字两端在观察眼内结点形成的夹角就是视角。如果你的视力水平是“20/20”，代表你的视角是1分，也就是1/60度。\n\n![](http://cdn.heckpsi.com/E-eye-sight-test.jpg)\n\n但是，正如我们已经看到的，20/20 的视力并不意味着完美的视觉，可以说甚至低于全世界一半人的视力。像素太大。如何变小，才能得到真正的 Retina 显示屏？\n\n不幸的是，人眼可以看到的极限目前还不能确定。根据 DisplayMate 的总裁 Raymond Soneira 说，一个完美的人类视网膜的分辨率为每像素 0.6 弧分。索内拉的分辨率虽然没有被普遍接受。其他人不同意，认为眼睛是强大得多。  J.Blackware 在美国光学学会早在 1946 年，确定了人眼的分辨率是实际上更接近 0.35 弧分。一个真正的 Retina 显示屏，像素要比 iPhone 4S 的 Retina 小 65%。一些研究人类视觉的限制认为还会更小一些。\n然而，科学家们还是普遍同意大多数人视线的限制，它不能分辨单个像素的小于 0.3 弧分，徘徊在 0.3 和 0.4 之间是大多数人的视觉极限水平。\n\n换句话说，无可争议地符合人眼的分辨率，被认为是真正的视网膜的屏幕，它需要有从平均收视距离不大于 0.3 弧分大小的像素。因此计算可得真正的视网膜屏幕的对照表\n\n| Model               | Screen Size (Inches) | Average Distance | Retina Res (Apple) | True Retina Res | PPI  |\n| ------------------- | -------------------- | ---------------- | ------------------ | --------------- | ---- |\n| iPhone              | 3.5                  | 12               | 960 x 640          | 2772 x 1848     | 952  |\n| iPad                | 9.7                  | 15               | 2048 x 1536        | 5968 x 4486     | 769  |\n| 11-inch MacBook Air | 11.6                 | 22               | 2732 x 1536        | 5184 x 2916     | 513  |\n| 13-Inch MacBook Air | 13.3                 | 22               | 2880 x 1800        | 5872 x 3670     | 520  |\n| 15-Inch MacBook Pro | 15.4                 | 24               | 2880 x 1800        | 6096 x 3810     | 467  |\n| 21-Inch iMac        | 21.5                 | 28               | 3840 x 2160        | 7408 x 4168     | 395  |\n| 27-Inch iMac        | 27                   | 28               | 5120 x 2880        | 9120 x 5130     | 388  |\n\n译者：可见，要想达到一款手机日常使用达到人类视网膜极限需要达到952PPI，这是现在技术所不能达到的。而我们确实需要真正的视网膜屏幕，因为显然物体越精细，越是显得真实。完美的显示屏要能达到和人眼看到真实的图像一模一样，这是显示器的目标，而且还很遥远。\n\n译者注：请无视我的翻译腔。\n\n","slug":"why-retina-isnt-enough","published":1,"updated":"2016-05-15T03:20:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscy00a1001lpp8zmtcwtnyz","content":"<p>编译自 Why Retina Isn’t Enough 作者：John Brownlee 日期：2012年7月15日</p>\n<a id=\"more\"></a>\n<p>注：文中所说的 20/20 视力是英国标准，大约是中国所采用的标准对数视力表的 4.9-5.0 或 0.9-1.0</p>\n<p>借以此文来回应前面某主页菌所说的 538 PPI 远超了人类极限。人类的极限还远得很…</p>\n<p>为什么Retina是不够的呢？</p>\n<p>在这一点上，大家都知道，史蒂夫·乔布斯，表演大师，他早在 2010 年推出 iPhone 4 的 Retina 显示屏就捏造了事实。</p>\n<p>史蒂夫·乔布斯当时是这样说的：</p>\n<p>研究表明，当你持有距离你眼睛大约 25 或 30 厘米的东西，人类视网膜的极限能力能够区分 300PPI。</p>\n<p>苹果定义这样一个 Retina 显示屏，而当 New iPad 在 3 月发布时，蒂姆·库克自己澄清了定义的视网膜上的一点：</p>\n<p>您可能还记得，与 iPhone 保持在一个正常的距离，你的视网膜无法分辨单个像素。当 iPad 保持在一个正常的距离 [38厘米]，它是相同的结果。</p>\n<p>换句话说，因为一般人使用平板比他们的电话离眼睛更远，新的 iPad 并不需要有 iPhone 的小像素，这意味着新 iPad 像素密度 264 PPI。同样，人坐在更远的地方使用他们的 MacBook Pro 笔记本电脑，这意味着他们的视网膜显示只需要 220 PPI。</p>\n<p>到目前为止，一切都不错。只有一个问题：史蒂夫·乔布斯说，人眼从 25 厘米观看显示器，无法分辨单个像素密度高达 300 PPI 的说法本身就是错误的。真正的数字是接近 900 PPI 。苹果的 Retina 显示屏只有三分之一的密度。</p>\n<p>为什么苹果的“视网膜”是不是真正的视网膜</p>\n<p>苹果使用的 Retina 作为一个营销术语，它是伟大的。但是，这也意味着，它涉及到的分辨率是不正确。从现在起过十年，我们将发现所有自己的 Mac，iPhone 和 iPad 屏幕那么差，看着 iPhone 4S 或新的 MacBook Pro 将会像现在去看 2002 年的 1024 x 768 的 CRT 是那样曾经令我们兴奋的东西。</p>\n<p>要理解为什么远没有达到标准是比较复杂的。你需要了解史蒂夫·乔布斯如何想出了他最初的 Retina 定义：总之，他基于对一个人有 20/20 的视力。似乎是合理的，因为 20/20 是拥有完美视力的代名词。</p>\n<p>唯一的问题是什么？ 20/20 是不完美的视力。</p>\n<p>苹果视网膜的定义是根据老年人的视野来定义的</p>\n<p>当我们谈论一个人的视力 20/20，我们实际上指的是什么？如果一个人有 20/20 的视力，这意味着一个人站在 6 米远看清英制视力表第八排内容。这曾被认为是标准视力。</p>\n<p>不过，虽然 20/20 的视力传统上是指“标准视力”大多数的研究表明，正常的视力实际上是远远优于 20/20。事实上，视力正常的人通常直到他们60岁或70岁才会降低到 20/20！</p>\n<p>明白了吗？苹果视网膜的定义是根据老年人的视野。</p>\n<p>人眼的分辨率是多少？</p>\n<p>你的眼睛能看到的最小的像素有多小？比你想象的更小。<br>那么，什么是视觉的限制？要讨论这个问题，我们首先需要一个技术名词解释：视角。<br>大家可以看下面这个E字，它由15个像素组成，包括11个黑色像素和4个白色像素，在与这个E字的距离到达某个特定值时，你的眼睛就无法看出那两条在黑色像素之间的白线，此时E字两端在观察眼内结点形成的夹角就是视角。如果你的视力水平是“20/20”，代表你的视角是1分，也就是1/60度。</p>\n<p><img src=\"http://cdn.heckpsi.com/E-eye-sight-test.jpg\" alt=\"\"></p>\n<p>但是，正如我们已经看到的，20/20 的视力并不意味着完美的视觉，可以说甚至低于全世界一半人的视力。像素太大。如何变小，才能得到真正的 Retina 显示屏？</p>\n<p>不幸的是，人眼可以看到的极限目前还不能确定。根据 DisplayMate 的总裁 Raymond Soneira 说，一个完美的人类视网膜的分辨率为每像素 0.6 弧分。索内拉的分辨率虽然没有被普遍接受。其他人不同意，认为眼睛是强大得多。  J.Blackware 在美国光学学会早在 1946 年，确定了人眼的分辨率是实际上更接近 0.35 弧分。一个真正的 Retina 显示屏，像素要比 iPhone 4S 的 Retina 小 65%。一些研究人类视觉的限制认为还会更小一些。<br>然而，科学家们还是普遍同意大多数人视线的限制，它不能分辨单个像素的小于 0.3 弧分，徘徊在 0.3 和 0.4 之间是大多数人的视觉极限水平。</p>\n<p>换句话说，无可争议地符合人眼的分辨率，被认为是真正的视网膜的屏幕，它需要有从平均收视距离不大于 0.3 弧分大小的像素。因此计算可得真正的视网膜屏幕的对照表</p>\n<table>\n<thead>\n<tr>\n<th>Model</th>\n<th>Screen Size (Inches)</th>\n<th>Average Distance</th>\n<th>Retina Res (Apple)</th>\n<th>True Retina Res</th>\n<th>PPI</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>iPhone</td>\n<td>3.5</td>\n<td>12</td>\n<td>960 x 640</td>\n<td>2772 x 1848</td>\n<td>952</td>\n</tr>\n<tr>\n<td>iPad</td>\n<td>9.7</td>\n<td>15</td>\n<td>2048 x 1536</td>\n<td>5968 x 4486</td>\n<td>769</td>\n</tr>\n<tr>\n<td>11-inch MacBook Air</td>\n<td>11.6</td>\n<td>22</td>\n<td>2732 x 1536</td>\n<td>5184 x 2916</td>\n<td>513</td>\n</tr>\n<tr>\n<td>13-Inch MacBook Air</td>\n<td>13.3</td>\n<td>22</td>\n<td>2880 x 1800</td>\n<td>5872 x 3670</td>\n<td>520</td>\n</tr>\n<tr>\n<td>15-Inch MacBook Pro</td>\n<td>15.4</td>\n<td>24</td>\n<td>2880 x 1800</td>\n<td>6096 x 3810</td>\n<td>467</td>\n</tr>\n<tr>\n<td>21-Inch iMac</td>\n<td>21.5</td>\n<td>28</td>\n<td>3840 x 2160</td>\n<td>7408 x 4168</td>\n<td>395</td>\n</tr>\n<tr>\n<td>27-Inch iMac</td>\n<td>27</td>\n<td>28</td>\n<td>5120 x 2880</td>\n<td>9120 x 5130</td>\n<td>388</td>\n</tr>\n</tbody>\n</table>\n<p>译者：可见，要想达到一款手机日常使用达到人类视网膜极限需要达到952PPI，这是现在技术所不能达到的。而我们确实需要真正的视网膜屏幕，因为显然物体越精细，越是显得真实。完美的显示屏要能达到和人眼看到真实的图像一模一样，这是显示器的目标，而且还很遥远。</p>\n<p>译者注：请无视我的翻译腔。</p>\n","excerpt":"<p>编译自 Why Retina Isn’t Enough 作者：John Brownlee 日期：2012年7月15日</p>","more":"<p>注：文中所说的 20/20 视力是英国标准，大约是中国所采用的标准对数视力表的 4.9-5.0 或 0.9-1.0</p>\n<p>借以此文来回应前面某主页菌所说的 538 PPI 远超了人类极限。人类的极限还远得很…</p>\n<p>为什么Retina是不够的呢？</p>\n<p>在这一点上，大家都知道，史蒂夫·乔布斯，表演大师，他早在 2010 年推出 iPhone 4 的 Retina 显示屏就捏造了事实。</p>\n<p>史蒂夫·乔布斯当时是这样说的：</p>\n<p>研究表明，当你持有距离你眼睛大约 25 或 30 厘米的东西，人类视网膜的极限能力能够区分 300PPI。</p>\n<p>苹果定义这样一个 Retina 显示屏，而当 New iPad 在 3 月发布时，蒂姆·库克自己澄清了定义的视网膜上的一点：</p>\n<p>您可能还记得，与 iPhone 保持在一个正常的距离，你的视网膜无法分辨单个像素。当 iPad 保持在一个正常的距离 [38厘米]，它是相同的结果。</p>\n<p>换句话说，因为一般人使用平板比他们的电话离眼睛更远，新的 iPad 并不需要有 iPhone 的小像素，这意味着新 iPad 像素密度 264 PPI。同样，人坐在更远的地方使用他们的 MacBook Pro 笔记本电脑，这意味着他们的视网膜显示只需要 220 PPI。</p>\n<p>到目前为止，一切都不错。只有一个问题：史蒂夫·乔布斯说，人眼从 25 厘米观看显示器，无法分辨单个像素密度高达 300 PPI 的说法本身就是错误的。真正的数字是接近 900 PPI 。苹果的 Retina 显示屏只有三分之一的密度。</p>\n<p>为什么苹果的“视网膜”是不是真正的视网膜</p>\n<p>苹果使用的 Retina 作为一个营销术语，它是伟大的。但是，这也意味着，它涉及到的分辨率是不正确。从现在起过十年，我们将发现所有自己的 Mac，iPhone 和 iPad 屏幕那么差，看着 iPhone 4S 或新的 MacBook Pro 将会像现在去看 2002 年的 1024 x 768 的 CRT 是那样曾经令我们兴奋的东西。</p>\n<p>要理解为什么远没有达到标准是比较复杂的。你需要了解史蒂夫·乔布斯如何想出了他最初的 Retina 定义：总之，他基于对一个人有 20/20 的视力。似乎是合理的，因为 20/20 是拥有完美视力的代名词。</p>\n<p>唯一的问题是什么？ 20/20 是不完美的视力。</p>\n<p>苹果视网膜的定义是根据老年人的视野来定义的</p>\n<p>当我们谈论一个人的视力 20/20，我们实际上指的是什么？如果一个人有 20/20 的视力，这意味着一个人站在 6 米远看清英制视力表第八排内容。这曾被认为是标准视力。</p>\n<p>不过，虽然 20/20 的视力传统上是指“标准视力”大多数的研究表明，正常的视力实际上是远远优于 20/20。事实上，视力正常的人通常直到他们60岁或70岁才会降低到 20/20！</p>\n<p>明白了吗？苹果视网膜的定义是根据老年人的视野。</p>\n<p>人眼的分辨率是多少？</p>\n<p>你的眼睛能看到的最小的像素有多小？比你想象的更小。<br>那么，什么是视觉的限制？要讨论这个问题，我们首先需要一个技术名词解释：视角。<br>大家可以看下面这个E字，它由15个像素组成，包括11个黑色像素和4个白色像素，在与这个E字的距离到达某个特定值时，你的眼睛就无法看出那两条在黑色像素之间的白线，此时E字两端在观察眼内结点形成的夹角就是视角。如果你的视力水平是“20/20”，代表你的视角是1分，也就是1/60度。</p>\n<p><img src=\"http://cdn.heckpsi.com/E-eye-sight-test.jpg\" alt=\"\"></p>\n<p>但是，正如我们已经看到的，20/20 的视力并不意味着完美的视觉，可以说甚至低于全世界一半人的视力。像素太大。如何变小，才能得到真正的 Retina 显示屏？</p>\n<p>不幸的是，人眼可以看到的极限目前还不能确定。根据 DisplayMate 的总裁 Raymond Soneira 说，一个完美的人类视网膜的分辨率为每像素 0.6 弧分。索内拉的分辨率虽然没有被普遍接受。其他人不同意，认为眼睛是强大得多。  J.Blackware 在美国光学学会早在 1946 年，确定了人眼的分辨率是实际上更接近 0.35 弧分。一个真正的 Retina 显示屏，像素要比 iPhone 4S 的 Retina 小 65%。一些研究人类视觉的限制认为还会更小一些。<br>然而，科学家们还是普遍同意大多数人视线的限制，它不能分辨单个像素的小于 0.3 弧分，徘徊在 0.3 和 0.4 之间是大多数人的视觉极限水平。</p>\n<p>换句话说，无可争议地符合人眼的分辨率，被认为是真正的视网膜的屏幕，它需要有从平均收视距离不大于 0.3 弧分大小的像素。因此计算可得真正的视网膜屏幕的对照表</p>\n<table>\n<thead>\n<tr>\n<th>Model</th>\n<th>Screen Size (Inches)</th>\n<th>Average Distance</th>\n<th>Retina Res (Apple)</th>\n<th>True Retina Res</th>\n<th>PPI</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>iPhone</td>\n<td>3.5</td>\n<td>12</td>\n<td>960 x 640</td>\n<td>2772 x 1848</td>\n<td>952</td>\n</tr>\n<tr>\n<td>iPad</td>\n<td>9.7</td>\n<td>15</td>\n<td>2048 x 1536</td>\n<td>5968 x 4486</td>\n<td>769</td>\n</tr>\n<tr>\n<td>11-inch MacBook Air</td>\n<td>11.6</td>\n<td>22</td>\n<td>2732 x 1536</td>\n<td>5184 x 2916</td>\n<td>513</td>\n</tr>\n<tr>\n<td>13-Inch MacBook Air</td>\n<td>13.3</td>\n<td>22</td>\n<td>2880 x 1800</td>\n<td>5872 x 3670</td>\n<td>520</td>\n</tr>\n<tr>\n<td>15-Inch MacBook Pro</td>\n<td>15.4</td>\n<td>24</td>\n<td>2880 x 1800</td>\n<td>6096 x 3810</td>\n<td>467</td>\n</tr>\n<tr>\n<td>21-Inch iMac</td>\n<td>21.5</td>\n<td>28</td>\n<td>3840 x 2160</td>\n<td>7408 x 4168</td>\n<td>395</td>\n</tr>\n<tr>\n<td>27-Inch iMac</td>\n<td>27</td>\n<td>28</td>\n<td>5120 x 2880</td>\n<td>9120 x 5130</td>\n<td>388</td>\n</tr>\n</tbody>\n</table>\n<p>译者：可见，要想达到一款手机日常使用达到人类视网膜极限需要达到952PPI，这是现在技术所不能达到的。而我们确实需要真正的视网膜屏幕，因为显然物体越精细，越是显得真实。完美的显示屏要能达到和人眼看到真实的图像一模一样，这是显示器的目标，而且还很遥远。</p>\n<p>译者注：请无视我的翻译腔。</p>"},{"title":"围绕 MacBook Pro 打造的工作站设计日志","date":"2016-06-21T12:41:31.000Z","_content":"\n### 为什么\n\n#### 为什么我一定要用 macOS？\n\n这个问题需要放在一上来就被解释清楚，尤其当你发现这个 setup 的性价比其实非常低。然而这么设计自然有它存在的意义。首先，这和我的工作性质有关。我的日常开发同时涉及后端、前端和设计。尤其是我的后端围绕着 Ruby 展开。Ruby 的 native extensions 在 Windows 上不免没有那么好用，甚至在兼容性上有一些问题。使用一个 POSIX 兼容的操作系统是非常必要的。然而涉及前端的用户界面设计时，我还需要用到 Illustrator、Photoshop、Sketch 等一些软件。哪怕不使用 Sketch，剩下的软件也没有 Linux 的兼容版本。这使得 macOS 是我能避免频繁切换操作系统的唯一选择。\n\n<!--more-->\n\n#### 为什么不使用台式机的选项？\n\n在组建这个工作站系统的一开始，我希望围绕一款苹果的台式机来开始。苹果目前仍然在销售的台式机有 Mac Mini、Mac Pro 和 iMac，其中 iMac 带一块 27 寸的 5K 屏幕。但是 Mac Mini 和 iMac 本质上使用的仍然是移动级别的 CPU。而 Mac Pro 由于长久没有更新，目前的购买选项性价实在太差，并且 Mac Pro 的风道虽然设计非常合理，但是很多使用经验表明，数个月后当灰尘覆盖底部后风道会收到极严重的影响，故不作考虑。\n\n### 如何\n\n#### 屏幕设置\n\n![Screen Setup](http://cdn.heckpsi.com/screen-setup.jpg)\n\n中间是 34 英寸 21:9 带鱼屏幕，用来做视频剪辑等素材复杂的工作时能很好胜任。写代码时也能同时照顾多个文件。右侧 24 英寸 16:9 屏幕竖放，用于看适合竖着看的内容，比如开发文档、论文，不看的时候把聊天窗口丢在右侧避免对主要工作视线的干扰。上方 23 英寸 16:9 屏幕，用于连接 PC，用于偶尔需要看的 Visual Studio 上的项目，或者玩一些 PC 独占的游戏等。\n\n这里我使用了 Synergy 软件，来给两台电脑共享键盘和鼠标。由于 Synergy 跨平台支持，只要简单配置屏幕的位置，就能提供鼠标、键盘和剪贴板的双机共享了。\n\n#### 性能\n\n当两块高分辨率的屏幕插入 MacBook Pro 后，你能看到显著的性能下滑，发热非常明显。如果试图利用 21:9 屏幕的优势玩一些 macOS 系统兼容的游戏比如 欧洲卡车模拟器 的时候哪怕在全低画质下也不能流畅运行。如果跑视频渲染、压片等操作时，同样的性能问题明显。相反在一些 CPU 密集的应用场景下，比如编译程序的时候，反而没有太大的问题。而内存上，16GB 也基本够使用，虽然如果是 32GB 或者 64GB 的配置的话，性能上更游刃有余一些。\n\n综上我们可以发现，主要问题出在 MacBook Pro 的显卡上。那么想到的方案自然就是外置显卡。不过，凡是做过 expressCard 外置显卡的人都知道，对显卡性能的损失是非常严重的。这是因为 expressCard 虽然是总线接口，但是其带宽只有 PCI-E x1。然而 MacBook Pro 所提供的雷电接口，在 Thunderbolt 2.0 协议下就有 20Gbps 的带宽，这相当于 PCI-E x4 的带宽，哪怕使用 GTX 970 这样的显卡，也只有 10% 的性能损失。\n\n我使用的外置 PCI-E 盒子是 AKiTiO 的产品。外包装上明显标注，不支持显卡。这是因为显卡需要额外的供电，而盒子只能提供 60W 的供电，远小于显卡的需求，直接插上用可能会把显卡烧坏。所以我们将显卡盒外壳拆开后，单独接一个 400W 电源到显卡的 8pin 上。只不过，只这么操作，电源并不会认为自己开机了，所以不会供电。我们还需要用回形针把电源 24pin 的 13 引脚短接到地线，来模拟一个开机的情况。在我用了一天后，我发现 Dell 曾经为他们的迷你电脑推出过一款电源，其输出正是 12V 的 8pin，并且功率高达 220W，这是 Dell DA-2 电源适配器。所以如果不想魔改电源的话，可以使用这一解决方案。\n\n驱动上的话，NVIDIA 只为 Mac Pro 推出过显卡驱动，而不是 MacBook Pro。当然，操作系统层面的事情，当然我们可以魔改驱动，有一个一键安装的脚本项目在此 [automate-eGPU](https://github.com/goalque/automate-eGPU)。不过由于新的 Mac 的安全策略，你还需要 Command + R 开机进入恢复模式，在实用工具-终端中输入命令关闭驱动签名校验，才能正常使用，这一点这个一键脚本也会做出相应的提示。\n\n至此，我们解决了显卡性能上的问题。\n\n#### 存储\n\n买 256GB 版本 MacBook Pro 省下来的钱就是脑袋里进的水。为了解决把笔记本变为工作站后增加的大量数据，不得不寻找外置的存储方案进行妥协。最常见的解决方案当然就是移动硬盘。但事实上，移动硬盘通过 USB 3.0 连接，经常容易发生连接不稳定的情况，从而导致一些存储意外发生，我曾因这些原因导致过数据丢失一次。直到我见到了 Transcend 的 256GB 扩容存储卡，其长度比一般卡还要短一些，插入 MacBook Pro 中能几乎贴合于卡槽，从而避免了携带和使用上的不安全。唯一麻烦的是拿出来的时候需要使用一把面包刀或者尖锐的支架才能让卡与机器分离。\n\n#### 噪音\n\n虽然我们把显卡外置了，理论上机器散热没有任何压力。但实际上，Thunderbolt 2 的连接处由于非常巨大的数据交换，实际上左侧发热相对还是有点严重。考虑到，MacBook Pro 不止通过风道具有很强的散热能力，其铝合金外壳本身也被设计成其散热的一部分，我们大可通过降低外壳温度来降低整体温度。我选择了目前还只有在日本市场销售的 USB 水冷套件，为我的 MacBook Pro 做进一步降温。\n\n#### 外设\n\n关于键盘，不多说，参考之前的文章[《一款祖传的机械键盘》](http://blog.heckpsi.com/2016/05/14/customized-machanical-keyboard/)。在我使用的那么多的鼠标中，没有一款鼠标能比 Logitech M558 更适合 Mac 了，说实话 Apple Magic Mouse 还是省省吧，那东西就是个能挪动的触摸板。M558 从设计到重量甚至是电池，简直就是天生为 MacBook 准备的。而且，很便宜，并不是 Logitech 的高端产品。\n\n#### 便携\n\n虽然我们对整个 setup 进行了巨大的改动。但是其便携性没有遭到下降。我只需要关机后断开先开连接，就能带出门。而我的数据、执行了一半的工作流都能随身携带。续航也能维持在 8 - 9 小时的 MacBook Pro 的正常续航水平，而选择的 60% 键盘和 Logitech M558 也都很适合携带。这是单独搭建的工作站无法得到的优秀体验。\n\n### 购物列表\n\n| 选项                            | 价格（人民币元） | 备注        |\n| ----------------------------- | -------- | --------- |\n| MacBook Pro 15''              | 14288    | 国行        |\n| Transcent JetDrive Lite 256GB | 1099     |           |\n| x86 兼容机                       | 5000     |           |\n| AOC Q3477FQ                   | 2399     |           |\n| AKiTiO Thunderbolt 2 PCI-E    | 1200     | 二手        |\n| NVIDIA GTX 970 ITX            | 1700     | 二手        |\n| Dell DA-2 Adapter             | 32       | 二手        |\n| ViewSonic VA2462H             | 899      |           |\n| ViewSonic VA2349S             | 699      |           |\n| 乐歌 D3 显示器支架                   | 199      |           |\n| 乐歌 L1 显示器支架                   | 79       |           |\n| Logitech M558                 | 169      |           |\n| 客制化机械键盘                       | 1290     |           |\n| 笔记本水冷套价 USBWATC2              | 583.73   | 日本 Amazon |\n| **总计**                        | 29604.73 |           |\n\n### 缺点\n\n- **当 CPU 和内存遇到了瓶颈**：由于使用的是移动的 CPU 和内存，虽然都算不错，但在一些任务上依然会遇到瓶颈，比如机器学习或者大型编译。于是我在房间里准备了一台 22 核 44 线程 64GB 内存的服务器，让 Mac 可以随时随地远程登录来执行这部分任务。\n- **内置的屏幕无法关闭**：当系统默认显卡切换为 GTX 970 时，把屏幕盖子盖上后，虽然屏幕已不作显示，但操作系统仍然认为该屏幕存在并耗费资源进行渲染。这可以被认为是 macOS 的一个 bug。暂时没有解决方案。\n- **Synergy 在多屏下检测有误**：Synergy 跨机器的检测逻辑是你达到了屏幕的边缘，而这个边缘是指你最边缘的那块屏幕的边缘。比如我的设置中，我无法向 Synergy 正确描述我 PC 的位置。从而不能使得跨机器的使用完全符合直觉。\n- **音频**：由于盖上盖子的 MacBook Pro 发出的声音很奇怪会破音。而几块屏幕的声音几乎就是只能用「听个响」来形容，所以需要外接一个音响。同时 PC 和 MacBook Pro 的音频不能在同一个音响输出。我试图使用 3.5mm音频线一分二母 立体声音频转接线，但实际上还存在一点问题，仍然在解决中。\n\n### 以后的搭建\n\n由于这些都是在我卧室床头搭建的，以满足我起床就能写代码，写累了就睡的要求。当然我还购买了一把没有腿的椅子，这样我能长时间坐在床上而不至于腰背疼痛。那么既然是卧室，还需要点娱乐设施。所以打算把窗帘拆了改装成投影幕，加装投影仪供 PS4 使用，在 120 英寸的屏幕上畅玩 PS4。目前仍然在筹划中，如果搭建完了，会给大家分享相关的日志。","source":"_posts/workstation-setup-guide.md","raw":"---\ntitle: 围绕 MacBook Pro 打造的工作站设计日志\ndate: 2016-06-21 20:41:31\ntags: [日志]\n---\n\n### 为什么\n\n#### 为什么我一定要用 macOS？\n\n这个问题需要放在一上来就被解释清楚，尤其当你发现这个 setup 的性价比其实非常低。然而这么设计自然有它存在的意义。首先，这和我的工作性质有关。我的日常开发同时涉及后端、前端和设计。尤其是我的后端围绕着 Ruby 展开。Ruby 的 native extensions 在 Windows 上不免没有那么好用，甚至在兼容性上有一些问题。使用一个 POSIX 兼容的操作系统是非常必要的。然而涉及前端的用户界面设计时，我还需要用到 Illustrator、Photoshop、Sketch 等一些软件。哪怕不使用 Sketch，剩下的软件也没有 Linux 的兼容版本。这使得 macOS 是我能避免频繁切换操作系统的唯一选择。\n\n<!--more-->\n\n#### 为什么不使用台式机的选项？\n\n在组建这个工作站系统的一开始，我希望围绕一款苹果的台式机来开始。苹果目前仍然在销售的台式机有 Mac Mini、Mac Pro 和 iMac，其中 iMac 带一块 27 寸的 5K 屏幕。但是 Mac Mini 和 iMac 本质上使用的仍然是移动级别的 CPU。而 Mac Pro 由于长久没有更新，目前的购买选项性价实在太差，并且 Mac Pro 的风道虽然设计非常合理，但是很多使用经验表明，数个月后当灰尘覆盖底部后风道会收到极严重的影响，故不作考虑。\n\n### 如何\n\n#### 屏幕设置\n\n![Screen Setup](http://cdn.heckpsi.com/screen-setup.jpg)\n\n中间是 34 英寸 21:9 带鱼屏幕，用来做视频剪辑等素材复杂的工作时能很好胜任。写代码时也能同时照顾多个文件。右侧 24 英寸 16:9 屏幕竖放，用于看适合竖着看的内容，比如开发文档、论文，不看的时候把聊天窗口丢在右侧避免对主要工作视线的干扰。上方 23 英寸 16:9 屏幕，用于连接 PC，用于偶尔需要看的 Visual Studio 上的项目，或者玩一些 PC 独占的游戏等。\n\n这里我使用了 Synergy 软件，来给两台电脑共享键盘和鼠标。由于 Synergy 跨平台支持，只要简单配置屏幕的位置，就能提供鼠标、键盘和剪贴板的双机共享了。\n\n#### 性能\n\n当两块高分辨率的屏幕插入 MacBook Pro 后，你能看到显著的性能下滑，发热非常明显。如果试图利用 21:9 屏幕的优势玩一些 macOS 系统兼容的游戏比如 欧洲卡车模拟器 的时候哪怕在全低画质下也不能流畅运行。如果跑视频渲染、压片等操作时，同样的性能问题明显。相反在一些 CPU 密集的应用场景下，比如编译程序的时候，反而没有太大的问题。而内存上，16GB 也基本够使用，虽然如果是 32GB 或者 64GB 的配置的话，性能上更游刃有余一些。\n\n综上我们可以发现，主要问题出在 MacBook Pro 的显卡上。那么想到的方案自然就是外置显卡。不过，凡是做过 expressCard 外置显卡的人都知道，对显卡性能的损失是非常严重的。这是因为 expressCard 虽然是总线接口，但是其带宽只有 PCI-E x1。然而 MacBook Pro 所提供的雷电接口，在 Thunderbolt 2.0 协议下就有 20Gbps 的带宽，这相当于 PCI-E x4 的带宽，哪怕使用 GTX 970 这样的显卡，也只有 10% 的性能损失。\n\n我使用的外置 PCI-E 盒子是 AKiTiO 的产品。外包装上明显标注，不支持显卡。这是因为显卡需要额外的供电，而盒子只能提供 60W 的供电，远小于显卡的需求，直接插上用可能会把显卡烧坏。所以我们将显卡盒外壳拆开后，单独接一个 400W 电源到显卡的 8pin 上。只不过，只这么操作，电源并不会认为自己开机了，所以不会供电。我们还需要用回形针把电源 24pin 的 13 引脚短接到地线，来模拟一个开机的情况。在我用了一天后，我发现 Dell 曾经为他们的迷你电脑推出过一款电源，其输出正是 12V 的 8pin，并且功率高达 220W，这是 Dell DA-2 电源适配器。所以如果不想魔改电源的话，可以使用这一解决方案。\n\n驱动上的话，NVIDIA 只为 Mac Pro 推出过显卡驱动，而不是 MacBook Pro。当然，操作系统层面的事情，当然我们可以魔改驱动，有一个一键安装的脚本项目在此 [automate-eGPU](https://github.com/goalque/automate-eGPU)。不过由于新的 Mac 的安全策略，你还需要 Command + R 开机进入恢复模式，在实用工具-终端中输入命令关闭驱动签名校验，才能正常使用，这一点这个一键脚本也会做出相应的提示。\n\n至此，我们解决了显卡性能上的问题。\n\n#### 存储\n\n买 256GB 版本 MacBook Pro 省下来的钱就是脑袋里进的水。为了解决把笔记本变为工作站后增加的大量数据，不得不寻找外置的存储方案进行妥协。最常见的解决方案当然就是移动硬盘。但事实上，移动硬盘通过 USB 3.0 连接，经常容易发生连接不稳定的情况，从而导致一些存储意外发生，我曾因这些原因导致过数据丢失一次。直到我见到了 Transcend 的 256GB 扩容存储卡，其长度比一般卡还要短一些，插入 MacBook Pro 中能几乎贴合于卡槽，从而避免了携带和使用上的不安全。唯一麻烦的是拿出来的时候需要使用一把面包刀或者尖锐的支架才能让卡与机器分离。\n\n#### 噪音\n\n虽然我们把显卡外置了，理论上机器散热没有任何压力。但实际上，Thunderbolt 2 的连接处由于非常巨大的数据交换，实际上左侧发热相对还是有点严重。考虑到，MacBook Pro 不止通过风道具有很强的散热能力，其铝合金外壳本身也被设计成其散热的一部分，我们大可通过降低外壳温度来降低整体温度。我选择了目前还只有在日本市场销售的 USB 水冷套件，为我的 MacBook Pro 做进一步降温。\n\n#### 外设\n\n关于键盘，不多说，参考之前的文章[《一款祖传的机械键盘》](http://blog.heckpsi.com/2016/05/14/customized-machanical-keyboard/)。在我使用的那么多的鼠标中，没有一款鼠标能比 Logitech M558 更适合 Mac 了，说实话 Apple Magic Mouse 还是省省吧，那东西就是个能挪动的触摸板。M558 从设计到重量甚至是电池，简直就是天生为 MacBook 准备的。而且，很便宜，并不是 Logitech 的高端产品。\n\n#### 便携\n\n虽然我们对整个 setup 进行了巨大的改动。但是其便携性没有遭到下降。我只需要关机后断开先开连接，就能带出门。而我的数据、执行了一半的工作流都能随身携带。续航也能维持在 8 - 9 小时的 MacBook Pro 的正常续航水平，而选择的 60% 键盘和 Logitech M558 也都很适合携带。这是单独搭建的工作站无法得到的优秀体验。\n\n### 购物列表\n\n| 选项                            | 价格（人民币元） | 备注        |\n| ----------------------------- | -------- | --------- |\n| MacBook Pro 15''              | 14288    | 国行        |\n| Transcent JetDrive Lite 256GB | 1099     |           |\n| x86 兼容机                       | 5000     |           |\n| AOC Q3477FQ                   | 2399     |           |\n| AKiTiO Thunderbolt 2 PCI-E    | 1200     | 二手        |\n| NVIDIA GTX 970 ITX            | 1700     | 二手        |\n| Dell DA-2 Adapter             | 32       | 二手        |\n| ViewSonic VA2462H             | 899      |           |\n| ViewSonic VA2349S             | 699      |           |\n| 乐歌 D3 显示器支架                   | 199      |           |\n| 乐歌 L1 显示器支架                   | 79       |           |\n| Logitech M558                 | 169      |           |\n| 客制化机械键盘                       | 1290     |           |\n| 笔记本水冷套价 USBWATC2              | 583.73   | 日本 Amazon |\n| **总计**                        | 29604.73 |           |\n\n### 缺点\n\n- **当 CPU 和内存遇到了瓶颈**：由于使用的是移动的 CPU 和内存，虽然都算不错，但在一些任务上依然会遇到瓶颈，比如机器学习或者大型编译。于是我在房间里准备了一台 22 核 44 线程 64GB 内存的服务器，让 Mac 可以随时随地远程登录来执行这部分任务。\n- **内置的屏幕无法关闭**：当系统默认显卡切换为 GTX 970 时，把屏幕盖子盖上后，虽然屏幕已不作显示，但操作系统仍然认为该屏幕存在并耗费资源进行渲染。这可以被认为是 macOS 的一个 bug。暂时没有解决方案。\n- **Synergy 在多屏下检测有误**：Synergy 跨机器的检测逻辑是你达到了屏幕的边缘，而这个边缘是指你最边缘的那块屏幕的边缘。比如我的设置中，我无法向 Synergy 正确描述我 PC 的位置。从而不能使得跨机器的使用完全符合直觉。\n- **音频**：由于盖上盖子的 MacBook Pro 发出的声音很奇怪会破音。而几块屏幕的声音几乎就是只能用「听个响」来形容，所以需要外接一个音响。同时 PC 和 MacBook Pro 的音频不能在同一个音响输出。我试图使用 3.5mm音频线一分二母 立体声音频转接线，但实际上还存在一点问题，仍然在解决中。\n\n### 以后的搭建\n\n由于这些都是在我卧室床头搭建的，以满足我起床就能写代码，写累了就睡的要求。当然我还购买了一把没有腿的椅子，这样我能长时间坐在床上而不至于腰背疼痛。那么既然是卧室，还需要点娱乐设施。所以打算把窗帘拆了改装成投影幕，加装投影仪供 PS4 使用，在 120 英寸的屏幕上畅玩 PS4。目前仍然在筹划中，如果搭建完了，会给大家分享相关的日志。","slug":"workstation-setup-guide","published":1,"updated":"2016-06-21T12:55:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciscy00a5001npp8zllul6nfm","content":"<h3 id=\"为什么\"><a href=\"#为什么\" class=\"headerlink\" title=\"为什么\"></a>为什么</h3><h4 id=\"为什么我一定要用-macOS？\"><a href=\"#为什么我一定要用-macOS？\" class=\"headerlink\" title=\"为什么我一定要用 macOS？\"></a>为什么我一定要用 macOS？</h4><p>这个问题需要放在一上来就被解释清楚，尤其当你发现这个 setup 的性价比其实非常低。然而这么设计自然有它存在的意义。首先，这和我的工作性质有关。我的日常开发同时涉及后端、前端和设计。尤其是我的后端围绕着 Ruby 展开。Ruby 的 native extensions 在 Windows 上不免没有那么好用，甚至在兼容性上有一些问题。使用一个 POSIX 兼容的操作系统是非常必要的。然而涉及前端的用户界面设计时，我还需要用到 Illustrator、Photoshop、Sketch 等一些软件。哪怕不使用 Sketch，剩下的软件也没有 Linux 的兼容版本。这使得 macOS 是我能避免频繁切换操作系统的唯一选择。</p>\n<a id=\"more\"></a>\n<h4 id=\"为什么不使用台式机的选项？\"><a href=\"#为什么不使用台式机的选项？\" class=\"headerlink\" title=\"为什么不使用台式机的选项？\"></a>为什么不使用台式机的选项？</h4><p>在组建这个工作站系统的一开始，我希望围绕一款苹果的台式机来开始。苹果目前仍然在销售的台式机有 Mac Mini、Mac Pro 和 iMac，其中 iMac 带一块 27 寸的 5K 屏幕。但是 Mac Mini 和 iMac 本质上使用的仍然是移动级别的 CPU。而 Mac Pro 由于长久没有更新，目前的购买选项性价实在太差，并且 Mac Pro 的风道虽然设计非常合理，但是很多使用经验表明，数个月后当灰尘覆盖底部后风道会收到极严重的影响，故不作考虑。</p>\n<h3 id=\"如何\"><a href=\"#如何\" class=\"headerlink\" title=\"如何\"></a>如何</h3><h4 id=\"屏幕设置\"><a href=\"#屏幕设置\" class=\"headerlink\" title=\"屏幕设置\"></a>屏幕设置</h4><p><img src=\"http://cdn.heckpsi.com/screen-setup.jpg\" alt=\"Screen Setup\"></p>\n<p>中间是 34 英寸 21:9 带鱼屏幕，用来做视频剪辑等素材复杂的工作时能很好胜任。写代码时也能同时照顾多个文件。右侧 24 英寸 16:9 屏幕竖放，用于看适合竖着看的内容，比如开发文档、论文，不看的时候把聊天窗口丢在右侧避免对主要工作视线的干扰。上方 23 英寸 16:9 屏幕，用于连接 PC，用于偶尔需要看的 Visual Studio 上的项目，或者玩一些 PC 独占的游戏等。</p>\n<p>这里我使用了 Synergy 软件，来给两台电脑共享键盘和鼠标。由于 Synergy 跨平台支持，只要简单配置屏幕的位置，就能提供鼠标、键盘和剪贴板的双机共享了。</p>\n<h4 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h4><p>当两块高分辨率的屏幕插入 MacBook Pro 后，你能看到显著的性能下滑，发热非常明显。如果试图利用 21:9 屏幕的优势玩一些 macOS 系统兼容的游戏比如 欧洲卡车模拟器 的时候哪怕在全低画质下也不能流畅运行。如果跑视频渲染、压片等操作时，同样的性能问题明显。相反在一些 CPU 密集的应用场景下，比如编译程序的时候，反而没有太大的问题。而内存上，16GB 也基本够使用，虽然如果是 32GB 或者 64GB 的配置的话，性能上更游刃有余一些。</p>\n<p>综上我们可以发现，主要问题出在 MacBook Pro 的显卡上。那么想到的方案自然就是外置显卡。不过，凡是做过 expressCard 外置显卡的人都知道，对显卡性能的损失是非常严重的。这是因为 expressCard 虽然是总线接口，但是其带宽只有 PCI-E x1。然而 MacBook Pro 所提供的雷电接口，在 Thunderbolt 2.0 协议下就有 20Gbps 的带宽，这相当于 PCI-E x4 的带宽，哪怕使用 GTX 970 这样的显卡，也只有 10% 的性能损失。</p>\n<p>我使用的外置 PCI-E 盒子是 AKiTiO 的产品。外包装上明显标注，不支持显卡。这是因为显卡需要额外的供电，而盒子只能提供 60W 的供电，远小于显卡的需求，直接插上用可能会把显卡烧坏。所以我们将显卡盒外壳拆开后，单独接一个 400W 电源到显卡的 8pin 上。只不过，只这么操作，电源并不会认为自己开机了，所以不会供电。我们还需要用回形针把电源 24pin 的 13 引脚短接到地线，来模拟一个开机的情况。在我用了一天后，我发现 Dell 曾经为他们的迷你电脑推出过一款电源，其输出正是 12V 的 8pin，并且功率高达 220W，这是 Dell DA-2 电源适配器。所以如果不想魔改电源的话，可以使用这一解决方案。</p>\n<p>驱动上的话，NVIDIA 只为 Mac Pro 推出过显卡驱动，而不是 MacBook Pro。当然，操作系统层面的事情，当然我们可以魔改驱动，有一个一键安装的脚本项目在此 <a href=\"https://github.com/goalque/automate-eGPU\" target=\"_blank\" rel=\"external\">automate-eGPU</a>。不过由于新的 Mac 的安全策略，你还需要 Command + R 开机进入恢复模式，在实用工具-终端中输入命令关闭驱动签名校验，才能正常使用，这一点这个一键脚本也会做出相应的提示。</p>\n<p>至此，我们解决了显卡性能上的问题。</p>\n<h4 id=\"存储\"><a href=\"#存储\" class=\"headerlink\" title=\"存储\"></a>存储</h4><p>买 256GB 版本 MacBook Pro 省下来的钱就是脑袋里进的水。为了解决把笔记本变为工作站后增加的大量数据，不得不寻找外置的存储方案进行妥协。最常见的解决方案当然就是移动硬盘。但事实上，移动硬盘通过 USB 3.0 连接，经常容易发生连接不稳定的情况，从而导致一些存储意外发生，我曾因这些原因导致过数据丢失一次。直到我见到了 Transcend 的 256GB 扩容存储卡，其长度比一般卡还要短一些，插入 MacBook Pro 中能几乎贴合于卡槽，从而避免了携带和使用上的不安全。唯一麻烦的是拿出来的时候需要使用一把面包刀或者尖锐的支架才能让卡与机器分离。</p>\n<h4 id=\"噪音\"><a href=\"#噪音\" class=\"headerlink\" title=\"噪音\"></a>噪音</h4><p>虽然我们把显卡外置了，理论上机器散热没有任何压力。但实际上，Thunderbolt 2 的连接处由于非常巨大的数据交换，实际上左侧发热相对还是有点严重。考虑到，MacBook Pro 不止通过风道具有很强的散热能力，其铝合金外壳本身也被设计成其散热的一部分，我们大可通过降低外壳温度来降低整体温度。我选择了目前还只有在日本市场销售的 USB 水冷套件，为我的 MacBook Pro 做进一步降温。</p>\n<h4 id=\"外设\"><a href=\"#外设\" class=\"headerlink\" title=\"外设\"></a>外设</h4><p>关于键盘，不多说，参考之前的文章<a href=\"http://blog.heckpsi.com/2016/05/14/customized-machanical-keyboard/\">《一款祖传的机械键盘》</a>。在我使用的那么多的鼠标中，没有一款鼠标能比 Logitech M558 更适合 Mac 了，说实话 Apple Magic Mouse 还是省省吧，那东西就是个能挪动的触摸板。M558 从设计到重量甚至是电池，简直就是天生为 MacBook 准备的。而且，很便宜，并不是 Logitech 的高端产品。</p>\n<h4 id=\"便携\"><a href=\"#便携\" class=\"headerlink\" title=\"便携\"></a>便携</h4><p>虽然我们对整个 setup 进行了巨大的改动。但是其便携性没有遭到下降。我只需要关机后断开先开连接，就能带出门。而我的数据、执行了一半的工作流都能随身携带。续航也能维持在 8 - 9 小时的 MacBook Pro 的正常续航水平，而选择的 60% 键盘和 Logitech M558 也都很适合携带。这是单独搭建的工作站无法得到的优秀体验。</p>\n<h3 id=\"购物列表\"><a href=\"#购物列表\" class=\"headerlink\" title=\"购物列表\"></a>购物列表</h3><table>\n<thead>\n<tr>\n<th>选项</th>\n<th>价格（人民币元）</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>MacBook Pro 15’’</td>\n<td>14288</td>\n<td>国行</td>\n</tr>\n<tr>\n<td>Transcent JetDrive Lite 256GB</td>\n<td>1099</td>\n<td></td>\n</tr>\n<tr>\n<td>x86 兼容机</td>\n<td>5000</td>\n<td></td>\n</tr>\n<tr>\n<td>AOC Q3477FQ</td>\n<td>2399</td>\n<td></td>\n</tr>\n<tr>\n<td>AKiTiO Thunderbolt 2 PCI-E</td>\n<td>1200</td>\n<td>二手</td>\n</tr>\n<tr>\n<td>NVIDIA GTX 970 ITX</td>\n<td>1700</td>\n<td>二手</td>\n</tr>\n<tr>\n<td>Dell DA-2 Adapter</td>\n<td>32</td>\n<td>二手</td>\n</tr>\n<tr>\n<td>ViewSonic VA2462H</td>\n<td>899</td>\n<td></td>\n</tr>\n<tr>\n<td>ViewSonic VA2349S</td>\n<td>699</td>\n<td></td>\n</tr>\n<tr>\n<td>乐歌 D3 显示器支架</td>\n<td>199</td>\n<td></td>\n</tr>\n<tr>\n<td>乐歌 L1 显示器支架</td>\n<td>79</td>\n<td></td>\n</tr>\n<tr>\n<td>Logitech M558</td>\n<td>169</td>\n<td></td>\n</tr>\n<tr>\n<td>客制化机械键盘</td>\n<td>1290</td>\n<td></td>\n</tr>\n<tr>\n<td>笔记本水冷套价 USBWATC2</td>\n<td>583.73</td>\n<td>日本 Amazon</td>\n</tr>\n<tr>\n<td><strong>总计</strong></td>\n<td>29604.73</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ul>\n<li><strong>当 CPU 和内存遇到了瓶颈</strong>：由于使用的是移动的 CPU 和内存，虽然都算不错，但在一些任务上依然会遇到瓶颈，比如机器学习或者大型编译。于是我在房间里准备了一台 22 核 44 线程 64GB 内存的服务器，让 Mac 可以随时随地远程登录来执行这部分任务。</li>\n<li><strong>内置的屏幕无法关闭</strong>：当系统默认显卡切换为 GTX 970 时，把屏幕盖子盖上后，虽然屏幕已不作显示，但操作系统仍然认为该屏幕存在并耗费资源进行渲染。这可以被认为是 macOS 的一个 bug。暂时没有解决方案。</li>\n<li><strong>Synergy 在多屏下检测有误</strong>：Synergy 跨机器的检测逻辑是你达到了屏幕的边缘，而这个边缘是指你最边缘的那块屏幕的边缘。比如我的设置中，我无法向 Synergy 正确描述我 PC 的位置。从而不能使得跨机器的使用完全符合直觉。</li>\n<li><strong>音频</strong>：由于盖上盖子的 MacBook Pro 发出的声音很奇怪会破音。而几块屏幕的声音几乎就是只能用「听个响」来形容，所以需要外接一个音响。同时 PC 和 MacBook Pro 的音频不能在同一个音响输出。我试图使用 3.5mm音频线一分二母 立体声音频转接线，但实际上还存在一点问题，仍然在解决中。</li>\n</ul>\n<h3 id=\"以后的搭建\"><a href=\"#以后的搭建\" class=\"headerlink\" title=\"以后的搭建\"></a>以后的搭建</h3><p>由于这些都是在我卧室床头搭建的，以满足我起床就能写代码，写累了就睡的要求。当然我还购买了一把没有腿的椅子，这样我能长时间坐在床上而不至于腰背疼痛。那么既然是卧室，还需要点娱乐设施。所以打算把窗帘拆了改装成投影幕，加装投影仪供 PS4 使用，在 120 英寸的屏幕上畅玩 PS4。目前仍然在筹划中，如果搭建完了，会给大家分享相关的日志。</p>\n","excerpt":"<h3 id=\"为什么\"><a href=\"#为什么\" class=\"headerlink\" title=\"为什么\"></a>为什么</h3><h4 id=\"为什么我一定要用-macOS？\"><a href=\"#为什么我一定要用-macOS？\" class=\"headerlink\" title=\"为什么我一定要用 macOS？\"></a>为什么我一定要用 macOS？</h4><p>这个问题需要放在一上来就被解释清楚，尤其当你发现这个 setup 的性价比其实非常低。然而这么设计自然有它存在的意义。首先，这和我的工作性质有关。我的日常开发同时涉及后端、前端和设计。尤其是我的后端围绕着 Ruby 展开。Ruby 的 native extensions 在 Windows 上不免没有那么好用，甚至在兼容性上有一些问题。使用一个 POSIX 兼容的操作系统是非常必要的。然而涉及前端的用户界面设计时，我还需要用到 Illustrator、Photoshop、Sketch 等一些软件。哪怕不使用 Sketch，剩下的软件也没有 Linux 的兼容版本。这使得 macOS 是我能避免频繁切换操作系统的唯一选择。</p>","more":"<h4 id=\"为什么不使用台式机的选项？\"><a href=\"#为什么不使用台式机的选项？\" class=\"headerlink\" title=\"为什么不使用台式机的选项？\"></a>为什么不使用台式机的选项？</h4><p>在组建这个工作站系统的一开始，我希望围绕一款苹果的台式机来开始。苹果目前仍然在销售的台式机有 Mac Mini、Mac Pro 和 iMac，其中 iMac 带一块 27 寸的 5K 屏幕。但是 Mac Mini 和 iMac 本质上使用的仍然是移动级别的 CPU。而 Mac Pro 由于长久没有更新，目前的购买选项性价实在太差，并且 Mac Pro 的风道虽然设计非常合理，但是很多使用经验表明，数个月后当灰尘覆盖底部后风道会收到极严重的影响，故不作考虑。</p>\n<h3 id=\"如何\"><a href=\"#如何\" class=\"headerlink\" title=\"如何\"></a>如何</h3><h4 id=\"屏幕设置\"><a href=\"#屏幕设置\" class=\"headerlink\" title=\"屏幕设置\"></a>屏幕设置</h4><p><img src=\"http://cdn.heckpsi.com/screen-setup.jpg\" alt=\"Screen Setup\"></p>\n<p>中间是 34 英寸 21:9 带鱼屏幕，用来做视频剪辑等素材复杂的工作时能很好胜任。写代码时也能同时照顾多个文件。右侧 24 英寸 16:9 屏幕竖放，用于看适合竖着看的内容，比如开发文档、论文，不看的时候把聊天窗口丢在右侧避免对主要工作视线的干扰。上方 23 英寸 16:9 屏幕，用于连接 PC，用于偶尔需要看的 Visual Studio 上的项目，或者玩一些 PC 独占的游戏等。</p>\n<p>这里我使用了 Synergy 软件，来给两台电脑共享键盘和鼠标。由于 Synergy 跨平台支持，只要简单配置屏幕的位置，就能提供鼠标、键盘和剪贴板的双机共享了。</p>\n<h4 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h4><p>当两块高分辨率的屏幕插入 MacBook Pro 后，你能看到显著的性能下滑，发热非常明显。如果试图利用 21:9 屏幕的优势玩一些 macOS 系统兼容的游戏比如 欧洲卡车模拟器 的时候哪怕在全低画质下也不能流畅运行。如果跑视频渲染、压片等操作时，同样的性能问题明显。相反在一些 CPU 密集的应用场景下，比如编译程序的时候，反而没有太大的问题。而内存上，16GB 也基本够使用，虽然如果是 32GB 或者 64GB 的配置的话，性能上更游刃有余一些。</p>\n<p>综上我们可以发现，主要问题出在 MacBook Pro 的显卡上。那么想到的方案自然就是外置显卡。不过，凡是做过 expressCard 外置显卡的人都知道，对显卡性能的损失是非常严重的。这是因为 expressCard 虽然是总线接口，但是其带宽只有 PCI-E x1。然而 MacBook Pro 所提供的雷电接口，在 Thunderbolt 2.0 协议下就有 20Gbps 的带宽，这相当于 PCI-E x4 的带宽，哪怕使用 GTX 970 这样的显卡，也只有 10% 的性能损失。</p>\n<p>我使用的外置 PCI-E 盒子是 AKiTiO 的产品。外包装上明显标注，不支持显卡。这是因为显卡需要额外的供电，而盒子只能提供 60W 的供电，远小于显卡的需求，直接插上用可能会把显卡烧坏。所以我们将显卡盒外壳拆开后，单独接一个 400W 电源到显卡的 8pin 上。只不过，只这么操作，电源并不会认为自己开机了，所以不会供电。我们还需要用回形针把电源 24pin 的 13 引脚短接到地线，来模拟一个开机的情况。在我用了一天后，我发现 Dell 曾经为他们的迷你电脑推出过一款电源，其输出正是 12V 的 8pin，并且功率高达 220W，这是 Dell DA-2 电源适配器。所以如果不想魔改电源的话，可以使用这一解决方案。</p>\n<p>驱动上的话，NVIDIA 只为 Mac Pro 推出过显卡驱动，而不是 MacBook Pro。当然，操作系统层面的事情，当然我们可以魔改驱动，有一个一键安装的脚本项目在此 <a href=\"https://github.com/goalque/automate-eGPU\">automate-eGPU</a>。不过由于新的 Mac 的安全策略，你还需要 Command + R 开机进入恢复模式，在实用工具-终端中输入命令关闭驱动签名校验，才能正常使用，这一点这个一键脚本也会做出相应的提示。</p>\n<p>至此，我们解决了显卡性能上的问题。</p>\n<h4 id=\"存储\"><a href=\"#存储\" class=\"headerlink\" title=\"存储\"></a>存储</h4><p>买 256GB 版本 MacBook Pro 省下来的钱就是脑袋里进的水。为了解决把笔记本变为工作站后增加的大量数据，不得不寻找外置的存储方案进行妥协。最常见的解决方案当然就是移动硬盘。但事实上，移动硬盘通过 USB 3.0 连接，经常容易发生连接不稳定的情况，从而导致一些存储意外发生，我曾因这些原因导致过数据丢失一次。直到我见到了 Transcend 的 256GB 扩容存储卡，其长度比一般卡还要短一些，插入 MacBook Pro 中能几乎贴合于卡槽，从而避免了携带和使用上的不安全。唯一麻烦的是拿出来的时候需要使用一把面包刀或者尖锐的支架才能让卡与机器分离。</p>\n<h4 id=\"噪音\"><a href=\"#噪音\" class=\"headerlink\" title=\"噪音\"></a>噪音</h4><p>虽然我们把显卡外置了，理论上机器散热没有任何压力。但实际上，Thunderbolt 2 的连接处由于非常巨大的数据交换，实际上左侧发热相对还是有点严重。考虑到，MacBook Pro 不止通过风道具有很强的散热能力，其铝合金外壳本身也被设计成其散热的一部分，我们大可通过降低外壳温度来降低整体温度。我选择了目前还只有在日本市场销售的 USB 水冷套件，为我的 MacBook Pro 做进一步降温。</p>\n<h4 id=\"外设\"><a href=\"#外设\" class=\"headerlink\" title=\"外设\"></a>外设</h4><p>关于键盘，不多说，参考之前的文章<a href=\"http://blog.heckpsi.com/2016/05/14/customized-machanical-keyboard/\">《一款祖传的机械键盘》</a>。在我使用的那么多的鼠标中，没有一款鼠标能比 Logitech M558 更适合 Mac 了，说实话 Apple Magic Mouse 还是省省吧，那东西就是个能挪动的触摸板。M558 从设计到重量甚至是电池，简直就是天生为 MacBook 准备的。而且，很便宜，并不是 Logitech 的高端产品。</p>\n<h4 id=\"便携\"><a href=\"#便携\" class=\"headerlink\" title=\"便携\"></a>便携</h4><p>虽然我们对整个 setup 进行了巨大的改动。但是其便携性没有遭到下降。我只需要关机后断开先开连接，就能带出门。而我的数据、执行了一半的工作流都能随身携带。续航也能维持在 8 - 9 小时的 MacBook Pro 的正常续航水平，而选择的 60% 键盘和 Logitech M558 也都很适合携带。这是单独搭建的工作站无法得到的优秀体验。</p>\n<h3 id=\"购物列表\"><a href=\"#购物列表\" class=\"headerlink\" title=\"购物列表\"></a>购物列表</h3><table>\n<thead>\n<tr>\n<th>选项</th>\n<th>价格（人民币元）</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>MacBook Pro 15’’</td>\n<td>14288</td>\n<td>国行</td>\n</tr>\n<tr>\n<td>Transcent JetDrive Lite 256GB</td>\n<td>1099</td>\n<td></td>\n</tr>\n<tr>\n<td>x86 兼容机</td>\n<td>5000</td>\n<td></td>\n</tr>\n<tr>\n<td>AOC Q3477FQ</td>\n<td>2399</td>\n<td></td>\n</tr>\n<tr>\n<td>AKiTiO Thunderbolt 2 PCI-E</td>\n<td>1200</td>\n<td>二手</td>\n</tr>\n<tr>\n<td>NVIDIA GTX 970 ITX</td>\n<td>1700</td>\n<td>二手</td>\n</tr>\n<tr>\n<td>Dell DA-2 Adapter</td>\n<td>32</td>\n<td>二手</td>\n</tr>\n<tr>\n<td>ViewSonic VA2462H</td>\n<td>899</td>\n<td></td>\n</tr>\n<tr>\n<td>ViewSonic VA2349S</td>\n<td>699</td>\n<td></td>\n</tr>\n<tr>\n<td>乐歌 D3 显示器支架</td>\n<td>199</td>\n<td></td>\n</tr>\n<tr>\n<td>乐歌 L1 显示器支架</td>\n<td>79</td>\n<td></td>\n</tr>\n<tr>\n<td>Logitech M558</td>\n<td>169</td>\n<td></td>\n</tr>\n<tr>\n<td>客制化机械键盘</td>\n<td>1290</td>\n<td></td>\n</tr>\n<tr>\n<td>笔记本水冷套价 USBWATC2</td>\n<td>583.73</td>\n<td>日本 Amazon</td>\n</tr>\n<tr>\n<td><strong>总计</strong></td>\n<td>29604.73</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ul>\n<li><strong>当 CPU 和内存遇到了瓶颈</strong>：由于使用的是移动的 CPU 和内存，虽然都算不错，但在一些任务上依然会遇到瓶颈，比如机器学习或者大型编译。于是我在房间里准备了一台 22 核 44 线程 64GB 内存的服务器，让 Mac 可以随时随地远程登录来执行这部分任务。</li>\n<li><strong>内置的屏幕无法关闭</strong>：当系统默认显卡切换为 GTX 970 时，把屏幕盖子盖上后，虽然屏幕已不作显示，但操作系统仍然认为该屏幕存在并耗费资源进行渲染。这可以被认为是 macOS 的一个 bug。暂时没有解决方案。</li>\n<li><strong>Synergy 在多屏下检测有误</strong>：Synergy 跨机器的检测逻辑是你达到了屏幕的边缘，而这个边缘是指你最边缘的那块屏幕的边缘。比如我的设置中，我无法向 Synergy 正确描述我 PC 的位置。从而不能使得跨机器的使用完全符合直觉。</li>\n<li><strong>音频</strong>：由于盖上盖子的 MacBook Pro 发出的声音很奇怪会破音。而几块屏幕的声音几乎就是只能用「听个响」来形容，所以需要外接一个音响。同时 PC 和 MacBook Pro 的音频不能在同一个音响输出。我试图使用 3.5mm音频线一分二母 立体声音频转接线，但实际上还存在一点问题，仍然在解决中。</li>\n</ul>\n<h3 id=\"以后的搭建\"><a href=\"#以后的搭建\" class=\"headerlink\" title=\"以后的搭建\"></a>以后的搭建</h3><p>由于这些都是在我卧室床头搭建的，以满足我起床就能写代码，写累了就睡的要求。当然我还购买了一把没有腿的椅子，这样我能长时间坐在床上而不至于腰背疼痛。那么既然是卧室，还需要点娱乐设施。所以打算把窗帘拆了改装成投影幕，加装投影仪供 PS4 使用，在 120 英寸的屏幕上畅玩 PS4。目前仍然在筹划中，如果搭建完了，会给大家分享相关的日志。</p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ciscy00850000pp8z0hxqk1nk","tag_id":"ciscy008b0002pp8zuy0kxiri","_id":"ciscy008n000app8z896k5ijp"},{"post_id":"ciscy00850000pp8z0hxqk1nk","tag_id":"ciscy008g0005pp8zzkol7mgq","_id":"ciscy008r000cpp8z30n972hp"},{"post_id":"ciscy008a0001pp8znlh4yjwo","tag_id":"ciscy008m0009pp8z1haf9e2e","_id":"ciscy008y000jpp8zega8xjx2"},{"post_id":"ciscy008a0001pp8znlh4yjwo","tag_id":"ciscy008t000epp8z78fam3vw","_id":"ciscy008z000lpp8zs0ltr538"},{"post_id":"ciscy008e0003pp8zwal8sedu","tag_id":"ciscy008w000hpp8zyeyrlsra","_id":"ciscy009a000vpp8zn7xac64g"},{"post_id":"ciscy008e0003pp8zwal8sedu","tag_id":"ciscy008z000mpp8zbjbbmchy","_id":"ciscy009c000xpp8z0wnk31un"},{"post_id":"ciscy008e0003pp8zwal8sedu","tag_id":"ciscy0094000qpp8z22v8nf2n","_id":"ciscy009f0010pp8zio2tp5bi"},{"post_id":"ciscy009c000wpp8zwv5yyfgs","tag_id":"ciscy0097000tpp8zliqjbfkp","_id":"ciscy009h0012pp8zc1oedvgo"},{"post_id":"ciscy008f0004pp8za1kzx3o6","tag_id":"ciscy0097000tpp8zliqjbfkp","_id":"ciscy009j0015pp8zlgu3bp65"},{"post_id":"ciscy008f0004pp8za1kzx3o6","tag_id":"ciscy009d000ypp8zd5x4fjzk","_id":"ciscy009k0017pp8z30g9hys1"},{"post_id":"ciscy008g0006pp8zu3akkg03","tag_id":"ciscy009h0013pp8zr5xh6uvj","_id":"ciscy009x001hpp8zmnvm4fbo"},{"post_id":"ciscy008g0006pp8zu3akkg03","tag_id":"ciscy009m0019pp8z55l5h0vx","_id":"ciscy00a0001jpp8zouxrl73d"},{"post_id":"ciscy008g0006pp8zu3akkg03","tag_id":"ciscy009t001cpp8z9syqxnx9","_id":"ciscy00a5001mpp8zjmpdwfgq"},{"post_id":"ciscy008i0007pp8zqonwrzin","tag_id":"ciscy009w001fpp8zqi433sxe","_id":"ciscy00a7001ppp8zjswwybyj"},{"post_id":"ciscy008i0007pp8zqonwrzin","tag_id":"ciscy009h0013pp8zr5xh6uvj","_id":"ciscy00a7001qpp8zrft5ja0x"},{"post_id":"ciscy008l0008pp8zb70fc1kd","tag_id":"ciscy00a6001opp8zj8l6udap","_id":"ciscy00a7001spp8zy84r874j"},{"post_id":"ciscy008o000bpp8zqckg43iy","tag_id":"ciscy00a7001rpp8z4dvudsd5","_id":"ciscy00aa001wpp8ztdae43ig"},{"post_id":"ciscy008o000bpp8zqckg43iy","tag_id":"ciscy00a8001tpp8zw5n3qznr","_id":"ciscy00aa001xpp8zisw2klty"},{"post_id":"ciscy008o000bpp8zqckg43iy","tag_id":"ciscy008t000epp8z78fam3vw","_id":"ciscy00aa001zpp8znw4vcvti"},{"post_id":"ciscy008s000dpp8ze0xqsfd2","tag_id":"ciscy009h0013pp8zr5xh6uvj","_id":"ciscy00ab0021pp8zfr1xa1zo"},{"post_id":"ciscy008s000dpp8ze0xqsfd2","tag_id":"ciscy009w001fpp8zqi433sxe","_id":"ciscy00ab0022pp8zivphuvuj"},{"post_id":"ciscy008u000fpp8zadvwmnzo","tag_id":"ciscy00ab0020pp8z1ddwbprt","_id":"ciscy00al0026pp8z847f3c9j"},{"post_id":"ciscy008u000fpp8zadvwmnzo","tag_id":"ciscy00ab0023pp8z7t7kxaqc","_id":"ciscy00am0027pp8z4rgu4fay"},{"post_id":"ciscy008u000fpp8zadvwmnzo","tag_id":"ciscy00ac0024pp8z94q5nqlf","_id":"ciscy00an0029pp8zexn5uawp"},{"post_id":"ciscy008v000gpp8zls8474cc","tag_id":"ciscy00ad0025pp8z404y25xr","_id":"ciscy00an002app8zkvof66jo"},{"post_id":"ciscy008x000ipp8zlqn1u6qf","tag_id":"ciscy00ad0025pp8z404y25xr","_id":"ciscy00ap002dpp8z5fvttjco"},{"post_id":"ciscy008x000ipp8zlqn1u6qf","tag_id":"ciscy00an002bpp8zg5oejch3","_id":"ciscy00ap002epp8zek2vhy82"},{"post_id":"ciscy008z000kpp8zgto2q1it","tag_id":"ciscy00ap002cpp8z4yjxgjej","_id":"ciscy00aq002jpp8zpkv69rmb"},{"post_id":"ciscy008z000kpp8zgto2q1it","tag_id":"ciscy00ap002fpp8ze67g1b72","_id":"ciscy00ar002kpp8zxbx70e6i"},{"post_id":"ciscy008z000kpp8zgto2q1it","tag_id":"ciscy00aq002gpp8zl4px15x1","_id":"ciscy00ar002mpp8z321fr0b9"},{"post_id":"ciscy008z000kpp8zgto2q1it","tag_id":"ciscy00aq002hpp8z3bxneu1p","_id":"ciscy00ar002npp8z7m26l78o"},{"post_id":"ciscy0090000npp8zl7r36npw","tag_id":"ciscy0097000tpp8zliqjbfkp","_id":"ciscy00as002ppp8zbacpt8zh"},{"post_id":"ciscy0092000opp8z4rs0lln5","tag_id":"ciscy00ar002lpp8znmh55qop","_id":"ciscy00au002upp8z8b429x2j"},{"post_id":"ciscy0092000opp8z4rs0lln5","tag_id":"ciscy00as002opp8zjuorojs6","_id":"ciscy00au002vpp8zoi54z42z"},{"post_id":"ciscy0092000opp8z4rs0lln5","tag_id":"ciscy00ad0025pp8z404y25xr","_id":"ciscy00aw002xpp8zzsz5ayn8"},{"post_id":"ciscy0092000opp8z4rs0lln5","tag_id":"ciscy00as002rpp8z3oqc6nfk","_id":"ciscy00aw002ypp8zq2yv4syt"},{"post_id":"ciscy0092000opp8z4rs0lln5","tag_id":"ciscy00at002spp8z7erome3j","_id":"ciscy00aw0030pp8zszfod080"},{"post_id":"ciscy0093000ppp8z33djx77p","tag_id":"ciscy00at002spp8z7erome3j","_id":"ciscy00aw0031pp8zhoidqqdj"},{"post_id":"ciscy0093000ppp8z33djx77p","tag_id":"ciscy00au002wpp8zridw3ogu","_id":"ciscy00ax0033pp8z6iib6k22"},{"post_id":"ciscy0094000rpp8zfdzvv5md","tag_id":"ciscy00aw002zpp8z46zq3wf8","_id":"ciscy00ay0035pp8zqijwx8th"},{"post_id":"ciscy0094000rpp8zfdzvv5md","tag_id":"ciscy00at002spp8z7erome3j","_id":"ciscy00ay0036pp8zi3upsnte"},{"post_id":"ciscy0096000spp8zwzd3a52x","tag_id":"ciscy00ax0034pp8zylth1ekl","_id":"ciscy00az0039pp8zhjq894lx"},{"post_id":"ciscy0096000spp8zwzd3a52x","tag_id":"ciscy008t000epp8z78fam3vw","_id":"ciscy00az003app8zauv45hab"},{"post_id":"ciscy0096000spp8zwzd3a52x","tag_id":"ciscy00ay0037pp8zdwqv9666","_id":"ciscy00az003cpp8zvrm6ysnm"},{"post_id":"ciscy0099000upp8z9ytkhbq3","tag_id":"ciscy00az0038pp8z4thifr61","_id":"ciscy00b3003fpp8zuepswd21"},{"post_id":"ciscy0099000upp8z9ytkhbq3","tag_id":"ciscy00az003bpp8z0fq7tx5c","_id":"ciscy00b3003gpp8ziikwg7iw"},{"post_id":"ciscy0099000upp8z9ytkhbq3","tag_id":"ciscy00b0003dpp8zku7a05ae","_id":"ciscy00b3003ipp8zuwb3b1d2"},{"post_id":"ciscy009d000zpp8zxdhngwep","tag_id":"ciscy00b1003epp8zn0ak1cam","_id":"ciscy00b3003kpp8z920r0her"},{"post_id":"ciscy009d000zpp8zxdhngwep","tag_id":"ciscy00b3003hpp8zu0rno98t","_id":"ciscy00b3003lpp8zotoxsyd3"},{"post_id":"ciscy009g0011pp8zt7v7aahm","tag_id":"ciscy00b3003jpp8z58ottjhr","_id":"ciscy00b5003opp8zpbk2uxec"},{"post_id":"ciscy009g0011pp8zt7v7aahm","tag_id":"ciscy00b4003mpp8z48p5lvpb","_id":"ciscy00b6003ppp8zu8ob0pu0"},{"post_id":"ciscy009i0014pp8zp3grkicl","tag_id":"ciscy008w000hpp8zyeyrlsra","_id":"ciscy00b8003upp8z8mz2yirt"},{"post_id":"ciscy009i0014pp8zp3grkicl","tag_id":"ciscy00ad0025pp8z404y25xr","_id":"ciscy00b8003vpp8zjctuqt5m"},{"post_id":"ciscy009i0014pp8zp3grkicl","tag_id":"ciscy00b6003qpp8z1b5ip4j1","_id":"ciscy00b8003xpp8zmelcpiq7"},{"post_id":"ciscy009i0014pp8zp3grkicl","tag_id":"ciscy00b6003rpp8zrjxk5pwa","_id":"ciscy00b8003ypp8zz7u31iaa"},{"post_id":"ciscy009i0014pp8zp3grkicl","tag_id":"ciscy00b7003spp8zvaaq7vrm","_id":"ciscy00b80040pp8zeg7h2dv0"},{"post_id":"ciscy009k0016pp8z8j5jyoev","tag_id":"ciscy00at002spp8z7erome3j","_id":"ciscy00b90042pp8z863uzbgj"},{"post_id":"ciscy009k0016pp8z8j5jyoev","tag_id":"ciscy00b8003wpp8zadxs12az","_id":"ciscy00b90043pp8z76xepz5n"},{"post_id":"ciscy009k0016pp8z8j5jyoev","tag_id":"ciscy00b8003zpp8znd30kyir","_id":"ciscy00b90045pp8z8npgj0tj"},{"post_id":"ciscy009l0018pp8zdbgypqbj","tag_id":"ciscy00at002spp8z7erome3j","_id":"ciscy00ba0047pp8zfzvlrcm9"},{"post_id":"ciscy009l0018pp8zdbgypqbj","tag_id":"ciscy00b90044pp8zwwsnlyki","_id":"ciscy00ba0048pp8zzkxt8oty"},{"post_id":"ciscy009n001app8za8fd1nmh","tag_id":"ciscy00at002spp8z7erome3j","_id":"ciscy00bc004cpp8zgjolphyb"},{"post_id":"ciscy009n001app8za8fd1nmh","tag_id":"ciscy00ba0049pp8ztdzkyucx","_id":"ciscy00bc004dpp8zul7nuy3k"},{"post_id":"ciscy009n001app8za8fd1nmh","tag_id":"ciscy00b7003spp8zvaaq7vrm","_id":"ciscy00bc004fpp8zifq509iy"},{"post_id":"ciscy009r001bpp8zi0p57gzm","tag_id":"ciscy00ay0037pp8zdwqv9666","_id":"ciscy00bc004gpp8zwclrik80"},{"post_id":"ciscy009t001dpp8z6ilfkown","tag_id":"ciscy00at002spp8z7erome3j","_id":"ciscy00be004kpp8zer830x1d"},{"post_id":"ciscy009t001dpp8z6ilfkown","tag_id":"ciscy00bd004hpp8z5t2rgq97","_id":"ciscy00be004lpp8z05gc959c"},{"post_id":"ciscy009t001dpp8z6ilfkown","tag_id":"ciscy00be004ipp8zqoafy8m4","_id":"ciscy00be004npp8zfa9pk4g5"},{"post_id":"ciscy009v001epp8zbqxdeekg","tag_id":"ciscy00be004jpp8zmawd9c7f","_id":"ciscy00bf004qpp8zaiagmx0p"},{"post_id":"ciscy009v001epp8zbqxdeekg","tag_id":"ciscy00be004mpp8z0l4r9iuh","_id":"ciscy00bf004rpp8zggmfi1hd"},{"post_id":"ciscy009v001epp8zbqxdeekg","tag_id":"ciscy00be004opp8z2wxmdvx7","_id":"ciscy00bf004tpp8z7e48u9z6"},{"post_id":"ciscy009w001gpp8zepaj6ppe","tag_id":"ciscy00bf004ppp8zjccgepei","_id":"ciscy00bg004vpp8zsymq7uke"},{"post_id":"ciscy009w001gpp8zepaj6ppe","tag_id":"ciscy00at002spp8z7erome3j","_id":"ciscy00bg004wpp8zlnostzc4"},{"post_id":"ciscy009y001ipp8z2e4j30j2","tag_id":"ciscy00bf004upp8zk7bjve3l","_id":"ciscy00bg004zpp8z40k9iiwj"},{"post_id":"ciscy009y001ipp8z2e4j30j2","tag_id":"ciscy00ad0025pp8z404y25xr","_id":"ciscy00bg0050pp8zhzhfflr1"},{"post_id":"ciscy009y001ipp8z2e4j30j2","tag_id":"ciscy008w000hpp8zyeyrlsra","_id":"ciscy00bh0052pp8z6a4bhgwl"},{"post_id":"ciscy00a1001lpp8zmtcwtnyz","tag_id":"ciscy00b6003qpp8z1b5ip4j1","_id":"ciscy00bi0054pp8zz4jm551z"},{"post_id":"ciscy00a1001lpp8zmtcwtnyz","tag_id":"ciscy00bh0051pp8zyvoxdlyn","_id":"ciscy00bi0055pp8zaq2yja9t"},{"post_id":"ciscy00a5001npp8zllul6nfm","tag_id":"ciscy00bh0053pp8z36gj3wwl","_id":"ciscy00bi0056pp8z30a7nffi"}],"Tag":[{"name":"互联网","_id":"ciscy008b0002pp8zuy0kxiri"},{"name":"广告","_id":"ciscy008g0005pp8zzkol7mgq"},{"name":"杀毒软件","_id":"ciscy008m0009pp8z1haf9e2e"},{"name":"安全","_id":"ciscy008t000epp8z78fam3vw"},{"name":"Android","_id":"ciscy008w000hpp8zyeyrlsra"},{"name":"JavaScript","_id":"ciscy008z000mpp8zbjbbmchy"},{"name":"架构","_id":"ciscy0094000qpp8z22v8nf2n"},{"name":"站务","_id":"ciscy0097000tpp8zliqjbfkp"},{"name":"百度","_id":"ciscy009d000ypp8zd5x4fjzk"},{"name":"数学","_id":"ciscy009h0013pp8zr5xh6uvj"},{"name":"统计","_id":"ciscy009m0019pp8z55l5h0vx"},{"name":"概率","_id":"ciscy009t001cpp8z9syqxnx9"},{"name":"算法","_id":"ciscy009w001fpp8zqi433sxe"},{"name":"键盘","_id":"ciscy00a6001opp8zj8l6udap"},{"name":"App","_id":"ciscy00a7001rpp8z4dvudsd5"},{"name":"Hybrid","_id":"ciscy00a8001tpp8zw5n3qznr"},{"name":"Nexus","_id":"ciscy00ab0020pp8z1ddwbprt"},{"name":"硬件","_id":"ciscy00ab0023pp8z7t7kxaqc"},{"name":"维修","_id":"ciscy00ac0024pp8z94q5nqlf"},{"name":"Google","_id":"ciscy00ad0025pp8z404y25xr"},{"name":"Google I/O","_id":"ciscy00an002bpp8zg5oejch3"},{"name":"Microsoft","_id":"ciscy00ap002cpp8z4yjxgjej"},{"name":"Spartan","_id":"ciscy00ap002fpp8ze67g1b72"},{"name":"Edge","_id":"ciscy00aq002gpp8zl4px15x1"},{"name":"浏览器","_id":"ciscy00aq002hpp8z3bxneu1p"},{"name":"AlphaGo","_id":"ciscy00ar002lpp8znmh55qop"},{"name":"AI","_id":"ciscy00as002opp8zjuorojs6"},{"name":"机器学习","_id":"ciscy00as002rpp8z3oqc6nfk"},{"name":"科普","_id":"ciscy00at002spp8z7erome3j"},{"name":"影像","_id":"ciscy00au002wpp8zridw3ogu"},{"name":"字体","_id":"ciscy00aw002zpp8z46zq3wf8"},{"name":"HTTPS","_id":"ciscy00ax0034pp8zylth1ekl"},{"name":"通讯","_id":"ciscy00ay0037pp8zdwqv9666"},{"name":"Lambda","_id":"ciscy00az0038pp8z4thifr61"},{"name":"编程","_id":"ciscy00az003bpp8z0fq7tx5c"},{"name":"Lisp","_id":"ciscy00b0003dpp8zku7a05ae"},{"name":"HeckPsi","_id":"ciscy00b1003epp8zn0ak1cam"},{"name":"Genji","_id":"ciscy00b3003hpp8zu0rno98t"},{"name":"Ruby","_id":"ciscy00b3003jpp8z58ottjhr"},{"name":"PHP","_id":"ciscy00b4003mpp8z48p5lvpb"},{"name":"Apple","_id":"ciscy00b6003qpp8z1b5ip4j1"},{"name":"iOS","_id":"ciscy00b6003rpp8zrjxk5pwa"},{"name":"操作系统","_id":"ciscy00b7003spp8zvaaq7vrm"},{"name":"Samsung","_id":"ciscy00b8003wpp8zadxs12az"},{"name":"SuperAmoled","_id":"ciscy00b8003zpp8znd30kyir"},{"name":"魅族","_id":"ciscy00b90044pp8zwwsnlyki"},{"name":"DPI","_id":"ciscy00ba0049pp8ztdzkyucx"},{"name":"DDoS","_id":"ciscy00bd004hpp8z5t2rgq97"},{"name":"网络","_id":"ciscy00be004ipp8zqoafy8m4"},{"name":"LGBT","_id":"ciscy00be004jpp8zmawd9c7f"},{"name":"女权","_id":"ciscy00be004mpp8z0l4r9iuh"},{"name":"权利","_id":"ciscy00be004opp8z2wxmdvx7"},{"name":"12306","_id":"ciscy00bf004ppp8zjccgepei"},{"name":"设计","_id":"ciscy00bf004upp8zk7bjve3l"},{"name":"屏幕","_id":"ciscy00bh0051pp8zyvoxdlyn"},{"name":"日志","_id":"ciscy00bh0053pp8z36gj3wwl"}]}}
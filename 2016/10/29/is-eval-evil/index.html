<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="theme-color" content="#43bea2"><title> 关于 eval 是否 evil 的一些想法 · HeckPsi Blog</title><meta name="description" content="关于 eval 是否 evil 的一些想法 - 上海骇咕赛信息科技有限公司"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://blog.heckpsi.com/atom.xml" title="HeckPsi Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="http://heckpsi.com" target="_blank" class="nav-list-link">HOME</a></li><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/heckpsi" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/heckpsi-lab" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">关于 eval 是否 evil 的一些想法</h1><div class="post-info">2016年10月29日</div><div class="post-content"><h3 id="引"><a href="#引" class="headerlink" title="引"></a>引</h3><p>对于大多数动态语言，都支持 <code>eval</code> 这个神奇的函数。这打他们太爷爷 Lisp 开始就支持这种方法。虽然写法（eg: <code>(eval &#39;(+ 1 2 3))</code> ）有稍许不同，但语义是一样的，就是说 <code>eval</code> 函数接受一个字符串类型作为参数，将其解析成语句并混合在当前作用域内运行。但我想大家也都听过这么一句话：</p>
<blockquote>
<p>eval is evil.</p>
</blockquote>
<p>但是 How evil is eval？那么既然 <code>eval</code> 如此罪恶，那么为什么它仍被那么多动态语言作为接口暴露呢？我们不妨来仔细探讨一下 <code>eval</code> 在使用中究竟会产生什么问题，在日常编程中究竟该不该使用 <code>eval</code>，如果要用，那么又该如何使用。</p>
<a id="more"></a>
<h3 id="字符串安全"><a href="#字符串安全" class="headerlink" title="字符串安全"></a>字符串安全</h3><p>说到 <code>eval</code> 第一个会被讨论的当然就是其安全性。比如说，我们现在来实现一个四则运算器：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">loop <span class="keyword">do</span></div><div class="line">  print(<span class="string">'Expression: '</span>)</div><div class="line">  puts(<span class="string">"result: <span class="subst">#&#123;eval gets.chomp&#125;</span>"</span>)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Expression: 1+1</div><div class="line">result: 2</div><div class="line">Expression: 2+2</div><div class="line">result: 4</div><div class="line">Expression: 3*4</div><div class="line">result: 12</div><div class="line">Expression: 4+(1*1)</div><div class="line">result: 6</div></pre></td></tr></table></figure>
<p>Awesome! 这段程序实现了全部四则运算的功能！只不过，这东西实现了 <strong>不止</strong> 四则运算的功能，事实上，它能处理任意 Ruby 语句，实际上这已经是一个 REPL（Read-Eval-Print Loop）了。我们可以运行一些「危险」的代码，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Expression: exit</div><div class="line">Process exit with code 0</div></pre></td></tr></table></figure>
<p>更实际的应用是，在 JavaScript 中，如果你想要支持 IE7 的话，<code>JSON.parse()</code> 是不被支持的，除非你引入一个 JSON 解析库，最方便的写法就是 <code>eval(json)</code>，因为毕竟 JSON 也是合法的 JavaScript 语句，这样的方法安全性问题是显然的。</p>
<p>这样的问题不止 <code>eval</code> 有，事实上，所有和字符串打交道的事情，或多或少都有类似的问题。比如「SQL 注入」说到底也就是这么一回事。再比如你在 Ruby 代码中试图操作 <code>git</code> 命令的时候，如果你使用反引号，也可能遇到这样的问题。</p>
<p>不过我们来看下面这个例子：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># gems/rest-client-1.6.7/bin/restclient 摘自《Ruby 元编程(第二版)》第 142 页</span></div><div class="line">POSSIBLE_VERBS = [<span class="string">'get'</span>, <span class="string">'put'</span>, <span class="string">'post'</span>, <span class="string">'delete'</span>]</div><div class="line">POSSIBLE_VERBS.each <span class="keyword">do</span> <span class="params">|m|</span></div><div class="line">  eval <span class="string">&lt;&lt;-end_eval</span></div><div class="line">    def <span class="subst">#&#123;m&#125;</span>(path, *args, &amp;b)</div><div class="line">      r[path].<span class="subst">#&#123;m&#125;</span>(*args, &amp;b)</div><div class="line">     end</div><div class="line">  end_eval</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>在这个例子中，也使用了 <code>eval</code>，也在 <code>eval</code> 中拼接了字符串，存在字符串拼接的安全性问题吗？并没有。因为是从常量数组中读取的字符串，并不存在用户任意输入导致注入的问题。</p>
<p>但，我们反过来说，SQL 驱动自带的 <code>query</code> 函数都可能存在注入，难道我们就不用 SQL 了吗？并没有。事实上，注入问题是可以被解决的。如果我们做好对用户输入的 <strong>过滤</strong> 和 <strong>转义</strong> 同样也能解决。问题就在于，这么做的成本和 <code>eval</code> 带来的动态性好处，哪个更大的权衡问题。</p>
<h3 id="Lexer-amp-Parser"><a href="#Lexer-amp-Parser" class="headerlink" title="Lexer &amp; Parser"></a>Lexer &amp; Parser</h3><blockquote>
<p>本来想用中文写这个小标题，但感觉「词法分析器和语法分析器」实在这标题太长了</p>
</blockquote>
<p>学过一些《编译原理》都知道，无论是解释器还是编译器，拿到字符串无非就是</p>
<p><code>词法分析 -&gt; 语法分析 -&gt; 语义检查 -&gt; 生成语法树 -&gt; 代码优化 -&gt; 生成目标代码/执行</code></p>
<p>使用 <code>eval</code> 函数意味着，你的程序需要在运行时经历全部的这些步骤。通常来说即使是脚本语言，在你加载所有文件初始化运行的过程中。前期步骤通常都已经完成了，只剩下最后一步执行了。不过加入 <code>eval</code> 之后就不一样了。因为 <code>eval</code> 传入的是字符串，所以这意味着它需要对这一部分代码从词法分析开始重新走一遍。事实上，词法分析、语法分析、语义检查并不快。</p>
<p>比如说，我们对比下面的代码</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">GC.disable <span class="comment"># 禁用 GC 以避免后一段代码在运行过程中遭遇 GC 对其不公</span></div><div class="line"></div><div class="line">time = Time.now.to_f</div><div class="line"><span class="number">1000000</span>.times <span class="keyword">do</span></div><div class="line">  rand+rand</div><div class="line"><span class="keyword">end</span></div><div class="line">puts <span class="string">"Without eval: <span class="subst">#&#123;Time.now.to_f - time&#125;</span>"</span></div><div class="line"></div><div class="line">time = Time.now.to_f</div><div class="line"><span class="number">1000000</span>.times <span class="keyword">do</span></div><div class="line">  eval(<span class="string">'rand+rand'</span>)</div><div class="line"><span class="keyword">end</span></div><div class="line">puts <span class="string">"With eval: <span class="subst">#&#123;Time.now.to_f - time&#125;</span>"</span></div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Without eval: 0.11499691009521484</div><div class="line">With eval: 6.516125917434692</div></pre></td></tr></table></figure>
<p>慢了 55 倍。如果我们用 Ruby 自带的 profiler 对这两段代码跑一下的话，结果如下：</p>
<p>没有 eval：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"> %   cumulative   self              self     total</div><div class="line">time   seconds   seconds    calls  ms/call  ms/call  name</div><div class="line">62.15    17.03     17.03  1000000     0.02     0.02  nil#</div><div class="line">18.65    22.14      5.11        1  5110.00 27400.00  Integer#times</div><div class="line">12.77    25.64      3.50  2000000     0.00     0.00  Kernel#rand</div><div class="line"> 6.42    27.40      1.76  1000000     0.00     0.00  Float#+</div><div class="line"> 0.00    27.40      0.00        2     0.00     0.00  Time.now</div><div class="line"> 0.00    27.40      0.00        2     0.00     0.00  Fixnum#fdiv</div><div class="line"> 0.00    27.40      0.00        2     0.00     0.00  Numeric#quo</div><div class="line"> 0.00    27.40      0.00        2     0.00     0.00  Time#to_f</div><div class="line"> 0.00    27.40      0.00        1     0.00     0.00  Float#-</div><div class="line"> 0.00    27.40      0.00        1     0.00     0.00  Float#to_s</div><div class="line"> 0.00    27.40      0.00        2     0.00     0.00  IO#write</div><div class="line"> 0.00    27.40      0.00        1     0.00     0.00  IO#puts</div><div class="line"> 0.00    27.40      0.00        1     0.00     0.00  Kernel#puts</div><div class="line"> 0.00    27.40      0.00        1     0.00     0.00  TracePoint#enable</div><div class="line"> 0.00    27.40      0.00        1     0.00     0.00  TracePoint#disable</div><div class="line"> 0.00    27.40      0.00        2     0.00     0.00  IO#set_encoding</div><div class="line"> 0.00    27.40      0.00        2     0.00     0.00  Fixnum#+</div><div class="line"> 0.00    27.40      0.00        2     0.00     0.00  Time#initialize</div><div class="line"> 0.00    27.40      0.00        1     0.00 27400.00  #toplevel</div></pre></td></tr></table></figure>
<p>有 eval：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"> %   cumulative   self              self     total</div><div class="line">time   seconds   seconds    calls  ms/call  ms/call  name</div><div class="line">57.58    25.67     25.67  1000000     0.03     0.03  Kernel#eval</div><div class="line">16.02    32.81      7.14  1000000     0.01     0.04  nil#</div><div class="line">13.14    38.67      5.86        1  5860.00 44580.00  Integer#times</div><div class="line"> 9.17    42.76      4.09  2000000     0.00     0.00  Kernel#rand</div><div class="line"> 4.08    44.58      1.82  1000000     0.00     0.00  Float#+</div><div class="line"> 0.00    44.58      0.00        2     0.00     0.00  Fixnum#fdiv</div><div class="line"> 0.00    44.58      0.00        2     0.00     0.00  Numeric#quo</div><div class="line"> 0.00    44.58      0.00        2     0.00     0.00  Time#to_f</div><div class="line"> 0.00    44.58      0.00        1     0.00     0.00  Float#-</div><div class="line"> 0.00    44.58      0.00        1     0.00     0.00  Float#to_s</div><div class="line"> 0.00    44.58      0.00        2     0.00     0.00  IO#write</div><div class="line"> 0.00    44.58      0.00        1     0.00     0.00  IO#puts</div><div class="line"> 0.00    44.58      0.00        1     0.00     0.00  Kernel#puts</div><div class="line"> 0.00    44.58      0.00        1     0.00     0.00  TracePoint#enable</div><div class="line"> 0.00    44.58      0.00        1     0.00     0.00  TracePoint#disable</div><div class="line"> 0.00    44.58      0.00        2     0.00     0.00  IO#set_encoding</div><div class="line"> 0.00    44.58      0.00        2     0.00     0.00  Fixnum#+</div><div class="line"> 0.00    44.58      0.00        2     0.00     0.00  Time#initialize</div><div class="line"> 0.00    44.58      0.00        2     0.00     0.00  Time.now</div><div class="line"> 0.00    44.58      0.00        1     0.00 44580.00  #toplevel</div></pre></td></tr></table></figure>
<p>虽然在 profile 的掺和下，差距被缩小到了几倍之内，但也可以看出 <code>eval</code> 函数自行的语法解析有多么耗时。所以说，如果你的 <code>eval</code> 是一次性运行与加载时候的，比如上面那个 Rest Client 的例子里，问题并不大，但如果你的 <code>eval</code> 是被频繁调用的话，使用 <code>eval</code> 是非常影响性能的，不应该这么使用。</p>
<h3 id="静态分析与代码优化"><a href="#静态分析与代码优化" class="headerlink" title="静态分析与代码优化"></a>静态分析与代码优化</h3><p>在分析这个问题前，我们先来看两段代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">recursion_loop</span><span class="params">(<span class="keyword">int</span> count)</span></span>&#123;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"Count: %d\n"</span>, count);</div><div class="line">  <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;<span class="keyword">return</span>;&#125;</div><div class="line">  recursion_loop(count - <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">  recursion_loop(<span class="number">100000</span>);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">recursion_loop</span><span class="params">(count)</span></span></div><div class="line">  puts(<span class="string">"Count: <span class="subst">#&#123;count&#125;</span>"</span>)</div><div class="line">  <span class="keyword">return</span> <span class="keyword">if</span> count == <span class="number">0</span></div><div class="line">  recursion_loop(count - <span class="number">1</span>)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">recursion_loop(<span class="number">100000</span>)</div></pre></td></tr></table></figure>
<p>为什么第一段代码在 C++ 中可以正确运行（注：需要开启 -O2 编译选项），而第二段代码在 Ruby 下会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/Users/Delton/RubymineProjects/untitled/script4.rb:2:in `puts&apos;: stack level too deep (SystemStackError)</div><div class="line">	from /Users/Delton/RubymineProjects/untitled/script4.rb:2:in `puts&apos;</div><div class="line">	from /Users/Delton/RubymineProjects/untitled/script4.rb:2:in `recursion_loop&apos;</div><div class="line">	from /Users/Delton/RubymineProjects/untitled/script4.rb:4:in `recursion_loop&apos;</div><div class="line">	from /Users/Delton/RubymineProjects/untitled/script4.rb:4:in `recursion_loop&apos;</div><div class="line">	from /Users/Delton/RubymineProjects/untitled/script4.rb:4:in `recursion_loop&apos;</div><div class="line">	from /Users/Delton/RubymineProjects/untitled/script4.rb:4:in `recursion_loop&apos;</div><div class="line">	from /Users/Delton/RubymineProjects/untitled/script4.rb:4:in `recursion_loop&apos;</div><div class="line">	from /Users/Delton/RubymineProjects/untitled/script4.rb:4:in `recursion_loop&apos;</div><div class="line">	 ... 10908 levels...</div><div class="line">	from /Users/Delton/RubymineProjects/untitled/script4.rb:4:in `recursion_loop&apos;</div><div class="line">	from /Users/Delton/RubymineProjects/untitled/script4.rb:7:in `&lt;top (required)&gt;&apos;</div><div class="line">	from -e:1:in `load&apos;</div><div class="line">	from -e:1:in `&lt;main&gt;&apos;</div></pre></td></tr></table></figure>
<p>报错的原因很显然，栈太深了。这个用递归实现的循环，需要建一个深度高达 100000 层深栈。一般的运行时都不会允许这么深的栈。诶？等一下，那为什么在 C++ 中这段代码可以正常运行呢？因为你的 C++ 编译器发现了这是一个「尾递归」，可以进行「尾递归优化」。尾递归可以被优化成一个非递归形式，自然就不需要那么深的栈了。</p>
<p>这就是 <code>词法分析 -&gt; 语法分析 -&gt; 语义检查 -&gt; 生成语法树 -&gt; 代码优化 -&gt; 生成目标代码/执行</code> 的倒数第二步。Ruby 中也有尾递归优化的选项，但默认不开启。开启的话方法也比较复杂，需要用到 <code>InstrctionSequence</code> 这个编译中间码的类，代码如下：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">RubyVM::InstructionSequence.compile_option = &#123;</div><div class="line">    <span class="symbol">:tailcall_optimization</span> =&gt; <span class="literal">true</span>,</div><div class="line">    <span class="symbol">:trace_instruction</span> =&gt; <span class="literal">false</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">source = <span class="string">&lt;&lt;-end_source</span></div><div class="line">  def recursion_loop(count)</div><div class="line">    puts("Count: \#&#123;count&#125;")</div><div class="line">    return if count == 0</div><div class="line">    recursion_loop(count - 1)</div><div class="line">  end</div><div class="line">  recursion_loop(<span class="number">100000</span>)</div><div class="line">end_source</div><div class="line"></div><div class="line">RubyVM::InstructionSequence.new(source).eval</div></pre></td></tr></table></figure>
<p><strong>注：事实上，这里开启的是尾调用优化，尾调用是尾递归的超集，开启尾调用优化不止会优化尾递归。</strong></p>
<p>但下面这段尾递归代码在即使开启优化的情况下，一样不会得到优化：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">recursion_loop</span><span class="params">(count)</span></span></div><div class="line">  puts(<span class="string">"Count: <span class="subst">#&#123;count&#125;</span>"</span>)</div><div class="line">  <span class="keyword">return</span> <span class="keyword">if</span> count == <span class="number">0</span></div><div class="line">  eval(<span class="string">'recursion_loop(count - 1)'</span>)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">recursion_loop(<span class="number">100000</span>)</div></pre></td></tr></table></figure>
<p>这段代码把一个明明是尾递归的情况破坏成了非尾递归。因为编译器静态分析的时候根本不知道你 <code>eval</code> 里是什么东西。怎么可能给你优化？</p>
<p>虽然这个例子非常极端，但其实不止 <code>eval</code>，比如：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@next_recursion = proc &#123; <span class="params">|count|</span></div><div class="line">  recursion_loop(count - <span class="number">1</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">recursion_loop</span><span class="params">(count)</span></span></div><div class="line">  puts(<span class="string">"Count: <span class="subst">#&#123;count&#125;</span>"</span>)</div><div class="line">  <span class="keyword">return</span> <span class="keyword">if</span> count == <span class="number">0</span></div><div class="line">  @next_recursion.call(count)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">recursion_loop(<span class="number">100000</span>)</div></pre></td></tr></table></figure>
<p>大多数动态方法，都没有办法被静态分析，以提供足够的优化。以至于动态语言的代码优化也一直是一大难点。</p>
<h3 id="对-eval-魔法的思考"><a href="#对-eval-魔法的思考" class="headerlink" title="对 eval 魔法的思考"></a>对 eval 魔法的思考</h3><p>总结一下，谈一谈对「eval 魔法」的思考。<code>eval</code> 在元编程里也一直属于接近于禁术的那种类型。就好像核武器一样可怕。在用 <code>eval</code> 的时候要充分认识到可能带来的后果，才能对其进行使用。核国家的战争也不一定非要互相丢核武器，如果常规武器可以解决的，不必如此大动干戈。比如说前面 rest-client 的例子，也可以不用 <code>eval</code>：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">POSSIBLE_VERBS = [<span class="string">'get'</span>, <span class="string">'put'</span>, <span class="string">'post'</span>, <span class="string">'delete'</span>]</div><div class="line">POSSIBLE_VERBS.each <span class="keyword">do</span> <span class="params">|m|</span></div><div class="line">  define_method(m) <span class="keyword">do</span> <span class="params">|path, *args, &amp;b|</span></div><div class="line">    r[path].send(m, *args, &amp;b)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>也可以解决这样的问题。不过 <code>define_method</code> 的方法，也不能给代码带来静态分析，而这又是在启动时一次性执行的代码，对性能的提升是微乎其微的。所以 rest-client 的 <code>eval</code> 实现并谈不上 evil。</p>
<p><code>eval</code> 被那么多语言至今沿用，其巨大的灵活性带来的便利是毋庸置疑的。只是说，使用 <code>eval</code> 包括使用任何元编程技巧的时候，都要充分考虑到这么做的可能造成的后果，以免莽撞瞎写，误伤自己。</p>
<h3 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h3><p>在 <a href="https://leetcode.com/problems/valid-parentheses/" target="_blank" rel="external">Leetcode #20</a> 括号匹配问题里，有一个可以用 JavaScript 的 <code>eval</code> 实现的魔法写法，非常有趣，大家可以看看开心开心。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * @param &#123;string&#125; s</div><div class="line"> * @return &#123;boolean&#125;</div><div class="line"> */</div><div class="line"><span class="keyword">var</span> isValid = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</div><div class="line">    s = s.replace(<span class="regexp">/\(/g</span>, <span class="string">'+('</span>);</div><div class="line">    s = s.replace(<span class="regexp">/\[/g</span>, <span class="string">'+['</span>);</div><div class="line">    s = s.replace(<span class="regexp">/\&#123;/g</span>, <span class="string">'+&#123;0:'</span>);</div><div class="line">    s = s.replace(<span class="regexp">/\)/g</span>, <span class="string">'+0)'</span>);</div><div class="line">    s = s.replace(<span class="regexp">/\]/g</span>, <span class="string">'+0]'</span>);</div><div class="line">    s = s.replace(<span class="regexp">/\&#125;/g</span>, <span class="string">'+0&#125;'</span>);</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">        <span class="built_in">eval</span>(s);</div><div class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</div></article></div></main><footer><div class="paginator"><a href="/2016/12/15/em-midori-100-days/" class="prev">上一篇</a><a href="/2016/10/18/em-midori-40-days/" class="next">下一篇</a></div><div data-thread-key="2016/10/29/is-eval-evil/" data-title="关于 eval 是否 evil 的一些想法" data-url="http://blog.heckpsi.com/2016/10/29/is-eval-evil/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"heckpsi-blog"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2013 - 2017 <a href="http://blog.heckpsi.com">上海骇咕赛信息科技有限公司</a> | <a href="http://www.miitbeian.gov.cn/publish/query/indexFirst.action">沪ICP备15046530号</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-61251352-2",'auto');ga('send','pageview');</script></body></html>
<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="theme-color" content="#43bea2"><title> em-midori 100 天记 · HeckPsi Blog</title><meta name="description" content="em-midori 100 天记 - 上海骇咕赛信息科技有限公司"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://blog.heckpsi.com/atom.xml" title="HeckPsi Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="http://heckpsi.com" target="_blank" class="nav-list-link">HOME</a></li><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/heckpsi" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/heckpsi-lab" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">em-midori 100 天记</h1><div class="post-info">2016年12月15日</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上次在 40 天的时候介绍了一些<a href="https://ruby-china.org/topics/31358" target="_blank" rel="external">人生的经验</a>，做了些<a href="https://ruby-china.org/topics/31885" target="_blank" rel="external">微小的贡献</a>。一个人的命运啊，当然要靠自我奋斗，但是也要考虑到历史的进程，我绝对不知道我刚写了能跑 Hello World 的程序怎么把我选到 GitHub Trending 去了。这之后就莫名其妙上了 Ruby Weekly，还被 Matsumoto 桑给 retweet 了。然而上次那篇文章用的是中文写的，这直接导致一些不明真相的外国友人进行了<a href="https://www.reddit.com/r/ruby/comments/58kaqe/em_midori_lightweight_flexible_and_fast/" target="_blank" rel="external">迷之看空</a>的讨论。</p>
<p>不过在之后 60 天里，这个项目的 API 逐渐完善，对于原先很多的问题逐渐都在修正。我已经开始使用 em-midori 开发逻辑复杂的业务的尝试，并且目前进展非常顺利。在这 100 天之际，将 em-midori 的设计思路更好得整理一下，来仔细说说 em-midori 在解决什么问题，以及怎么解决。</p>
<a id="more"></a>
<h2 id="异步的思考"><a href="#异步的思考" class="headerlink" title="异步的思考"></a>异步的思考</h2><h3 id="瘾君子-JavaScript"><a href="#瘾君子-JavaScript" class="headerlink" title="瘾君子 JavaScript"></a>瘾君子 JavaScript</h3><p>JavaScript 不是所有语言中最早做异步的，但却是近年来非常引人瞩目的一个。这是因为，在并不十分快的 V8 虚拟机上，JavaScript 在主流解释型动态类型语言网络后端对比中，达到了不俗的性能表现。一般认为这是由 Node 纯异步设计带来的性能优势，然而事实上真的如此吗？</p>
<p>随手拿一段 Node 的代码，比如 <a href="https://github.com/nodejs/node-v0.x-archive/blob/842eaf4/src/http.js#L303" target="_blank" rel="external">http-parser</a> 的 JavaScript 示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">connection.addListener(<span class="string">"headers_complete"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">info</span>) </span>&#123;</div><div class="line">  incoming.httpVersion = info.httpVersion;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (info.method) &#123;</div><div class="line">    <span class="comment">// server only</span></div><div class="line">    incoming.method = info.method; </div><div class="line">    incoming.uri = node.http.parseUri(incoming.uri); <span class="comment">// TODO parse the URI lazily?</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// client only</span></div><div class="line">    incoming.statusCode = info.statusCode; </div><div class="line">  &#125;</div><div class="line"></div><div class="line">  stream.emit(<span class="string">"incoming"</span>, [incoming, info.should_keep_alive]);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">connection.addListener(<span class="string">"body"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</div><div class="line">  incoming.emit(<span class="string">"body"</span>, [chunk]);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">connection.addListener(<span class="string">"message_complete"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  incoming.emit(<span class="string">"complete"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>通过三个 <code>Listener</code> 来完成的 http parse 工作显然是异步的，画成流程应该是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">+-----------------+     callback     +----------------------------+</div><div class="line">|   parse header  | +--------------&gt; | req.header = parser.header |</div><div class="line">+-----------------+                  +----------------------------+</div><div class="line"></div><div class="line">+-----------------+     callback     +----------------------------+</div><div class="line">|   parse body    | +--------------&gt; | req.body.push(chunk)       |</div><div class="line">+-----------------+                  +----------------------------+</div><div class="line"></div><div class="line">+-----------------+     callback     +----------------------------+</div><div class="line">|   complete      | +--------------&gt; | ...                        |</div><div class="line">+-----------------+                  +----------------------------+</div></pre></td></tr></table></figure>
<p>然而事实上这整个异步都是假的，是特技的魔法。因为它的执行只有一种可能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">+-----------------+                  +----------------------------+</div><div class="line">|   parse header  | +--------------&gt; | req.header = parser.header |</div><div class="line">+-----------------+                  +---------------+------------+</div><div class="line">                                                     |</div><div class="line">         +-------------------------------------------+</div><div class="line">         |</div><div class="line">+--------v--------+                  +----------------------------+</div><div class="line">|   parse body    | +--------------&gt; | req.body.push(chunk)       |</div><div class="line">+---+-------------+                  +---------------+------------+</div><div class="line">    ^                                                |</div><div class="line">   N|    +-------------------------------------------+</div><div class="line">    |    |</div><div class="line">+---+----v--------+        Y         +----------------------------+</div><div class="line">|   complete?     | +--------------&gt; | ...                        |</div><div class="line">+-----------------+                  +----------------------------+</div></pre></td></tr></table></figure>
<p>如果你觉得这图有点晕，不如我们换个方向来看这个图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">     +-----------------+</div><div class="line">     |   parse header  |</div><div class="line">     +--------+--------+</div><div class="line">              |</div><div class="line">+-------------v--------------+</div><div class="line">| req.header = parser.header |</div><div class="line">+-------------+--------------+</div><div class="line">              |</div><div class="line">     +--------v--------+</div><div class="line">     |   parse body    |</div><div class="line">     +--------+--------+</div><div class="line">              |</div><div class="line">+-------------v--------------+</div><div class="line">| req.body.push(chunk)       &lt;---+</div><div class="line">+-------------+--------------+   |</div><div class="line">              |                  | N</div><div class="line">      +-------v---------+        |</div><div class="line">      |   complete?     +--------+</div><div class="line">      +-------+---------+</div></pre></td></tr></table></figure>
<p>这就算现在找个高中生来，也看得出这东西就是个依次运行的同步流程了吧。因为这几步之间是有关系的。如果 header 没处理完，你连 body 在哪都还没找到，怎么可能能异步呢？Node 的许多地方都是 <strong>语义异步，运行同步</strong> 的。之所以要这么做很大程度上是为了贯彻 Node 纯异步的本身，希望编程者把思路完全变成异步的思路。如果说想上面这个例子中，同步和异步并不存在运行上的差异，那么影响运行效率的到底是什么呢？</p>
<p>说到底是 <strong>阻塞</strong> 在作怪。 </p>
<p>如果一个核心一个线程一次只能正在处理一个队列的任务，每个任务耗时需要 1s 完成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">+---+  +---+  +---+  +---+  +---+</div><div class="line">|   |  |   |  |   |  |   |  |   |</div><div class="line">| 1 |  | 2 |  | 3 |  | 4 |  | 5 |</div><div class="line">|   |  |   |  |   |  |   |  |   |</div><div class="line">+---+  +---+  +---+  +---+  +---+</div><div class="line"></div><div class="line">+-------------------------------&gt;</div></pre></td></tr></table></figure>
<p>那么这个任务必然需要 5s 才能完成，无论这其中这几个任务如何排列顺序。异步在这种情况下不会带来任何性能上的好处。真正的好处出现在下面的图里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">+---+        +---+  +---+  +---+  +---+</div><div class="line">|   |        |   |  |   |  |   |  |   |</div><div class="line">| 1 |        | 1 |  | 2 |  | 3 |  | 4 |</div><div class="line">|   |        |   |  |   |  |   |  |   |</div><div class="line">+---+        +---+  +---+  +---+  +---+</div><div class="line"></div><div class="line">+-------------------------------------&gt;</div></pre></td></tr></table></figure>
<p>1 号任务处理了一半休眠了 1 秒，不处理任何东西，只是白白贡献了自己的 1 秒。如果我们的程序时异步的。那么 1 号任务可以让出处理权，先让 2 3 4 处理。而这种情况除非是有意的 <code>sleep</code> 操作，通常都是由于 <strong>I/O 阻塞</strong> 造成的，也就是处理了一半，正在等待一个网络请求或文件读写完成才能继续处理的这种情况。所以 Node 与其说是异步，不如说是由异步产生了一个无阻塞的网络框架产生的性能提升。</p>
<h3 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a>回调地狱</h3><p>那么说清楚了上面这个问题，我们就来说说，我们都不想这么写的原因：回调地狱 (callback hell)。如果我们在网上搜索一下，我想可以看到无数有关的段子。</p>
<p><img src="http://cdn.heckpsi.com/midori_3.png" alt="回调地狱"></p>
<p>然而事实上，在 Node 自己的样例中我们很少看到这种糟糕的代码，这种代码更多的是出现在我们的业务中。因为业务的实现主要就是 CRUD，而这些操作的明显特点就是每个业务都存在其自己内在的逻辑关系，有其自己的执行顺序，即使抽象也很难复用。而业务 API 通常都有着及时的反馈，这使得我们一定是：</p>
<ol>
<li>读入请求</li>
<li>解析请求</li>
<li>检查合法性</li>
<li>操作数据库</li>
<li>返回结果</li>
</ol>
<p>这四个操作的顺序不能颠倒的，但问题在于读入请求、操作数据库、返回结果都涉及 I/O 操作，确实将这几步通过回调异步可以有效避免阻塞提高性能。如果你的数据库操作复杂，涉及多次数据库操作，那么这个回调地狱自然而然就产生了。伪代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">connection.on(<span class="string">'received'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">  DB.query(<span class="string">'SELECT * FROM A WHERE x='</span> + data[<span class="string">'test'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</div><div class="line">    DB.query(<span class="string">'SELECT * FROM B WHERE x'</span> + data[<span class="string">'test2'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">result2</span>)</span>&#123;</div><div class="line">      connection.response(result + result2, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">        <span class="comment">// Response failed</span></div><div class="line">      &#125;)</div><div class="line">    &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">      <span class="comment">// DB query failed at query 2</span></div><div class="line">    &#125;))</div><div class="line">  &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="comment">// DB query failed at query 1</span></div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>显然，这种混乱的代码是 Node 工程师的日常。但是，回调地狱真的是不可避免的吗？事实上，暴露在业务中的 I/O 大多是有逻辑关联的，一旦有回调，就会回调地狱。但只要我们能把 CPU idle 率降到 0，避免掉所有的阻塞，我们的目的就已经达成，回调并不是异步必须要有的。</p>
<p>为了更好地解决问题，我们现在不妨忽略所有的细节，忘记业务本身，就看看回调地狱的形状长得像啥？</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(</div><div class="line">  (</div><div class="line">    (</div><div class="line">      ()</div><div class="line">    )</div><div class="line">  )</div><div class="line">)</div></pre></td></tr></table></figure>
<p>这种括号组成的语法关系是不是让人有一种：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="name">on</span> connection 'received (<span class="name">lambda</span> (<span class="name">data</span>)</div><div class="line">  (<span class="name">query</span> DB (<span class="name">format</span> <span class="literal">nil</span> <span class="string">"SELECT * FROM A WHERE x=~A"</span> (<span class="name">data</span> 'test)) (<span class="name">lambda</span> (<span class="name">result</span>) </div><div class="line">    (<span class="name">query</span> DB (<span class="name">format</span> <span class="literal">nil</span> <span class="string">"SELECT * FROM B WHERE x=~A"</span> (<span class="name">data</span> 'test2)) (<span class="name">lambda</span> (<span class="name">result2</span>) </div><div class="line">      (<span class="name">response</span> connection (<span class="name">+</span> result result2))</div><div class="line">    ) (<span class="name">lambda</span> (<span class="name">err2</span>) ())</div><div class="line">  )) (<span class="name">lambda</span> (<span class="name">err</span>) ())</div><div class="line">)))</div></pre></td></tr></table></figure>
<p>的错觉。这个错觉并没有错，JavaScript 可以说就是披着 C 语言外衣的 Lisp。它除了长得像 C 语法以外都和 Lisp 比较像。那么 Lisp 的括号嵌套是什么关系？本质上是栈的关系。所以一系列的回调本质是栈吗？稍有一些区别。回调被调用之时就是入栈之时，然而回调执行完并不是出栈之时，因为栈底的东西已经被执行完了。但如果我们更近一步，假设栈底什么都没有的话，那么我们就已经找到了一种非常基础的数据结构来描述这一行为的本质，这东西更像是一个 <strong>队列</strong>。</p>
<p>也就是说，每个请求的处理都是一个队列，每个 I/O 操作都是队列中的一项，当这个队列被运行完了，这个请求就被处理完了。它和原先同步的代码比起来的唯一区别是，同步代码可以被认为这个队列是依次接连执行的，而现在队列中的每一项只在它可以执行的时候再执行，否则，我可以去执行其他队列里的东西，把 CPU 的 Idle 吃完，就能达到很好的性能。</p>
<h3 id="已有的尝试"><a href="#已有的尝试" class="headerlink" title="已有的尝试"></a>已有的尝试</h3><p>事实上在比如 Thin 或者 Puma 之类的 Web 服务器中都已经使用 EventMachine 实现了一部分的异步，也就是将网络的 I/O，读取请求和写回返回部分写了非阻塞的写法。所以如果你跑一个 Hello World 服务器，那么其实性能并不太差。</p>
<p>比如最简单的 sinatra 例子</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">require</span> <span class="string">'sinatra'</span></div><div class="line">get <span class="string">'/'</span> <span class="keyword">do</span></div><div class="line">  <span class="string">'Hello World'</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>如果用 Thin 来跑的话，一个核心大概有 2500+ req/s 的性能，如果再拿掉一些中间件，还能更快。即使和 Node 有一些差距，但是这种差距是线性的，并不是什么显著的问题。</p>
<p>只不过阻塞问题有个巨大的特点，那就是一处阻塞。Ruby 中常用的数据库连接、文件 IO 都是一些阻塞模型。一旦涉及数据库，Sinatra on Thin 的性能就会显著下滑。本质上来说，这件事情毫无道理，因为数据库的运算和 Web 框架无关，之和数据库程序有关。但由于 Web 程序一直在等待数据库返回而不去处理手上的事物了，这才导致了性能上的下滑。</p>
<p>要想彻底解决阻塞的问题，要把每一个 I/O 操作都变成非阻塞的才行。</p>
<h3 id="小绿的异步"><a href="#小绿的异步" class="headerlink" title="小绿的异步"></a>小绿的异步</h3><p>em-midori 与其说是一个异步的 Web 框架，不如说是提供了一系列无回调非阻塞 I/O 的工具集合。em-midori 利用 Fiber 存储当前作用域和让步/恢复的特性来处理刚刚我们所说的 <strong>队列</strong> 的特征。每个 I/O 操作都会被看作队列的一项，一旦被执行，它就会保存自己当前作用域下变量，然后让出自己的处理权让系统处理其它任务，而等 I/O 完毕后再恢复这个代码的继续运行。比如：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">require</span> <span class="string">'em-midori'</span></div><div class="line"><span class="keyword">require</span> <span class="string">'json'</span></div><div class="line"><span class="keyword">require</span> <span class="string">'em-midori/extension/file'</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Route</span> &lt; Midori::Route</span></div><div class="line">  get <span class="string">'/'</span> <span class="keyword">do</span></div><div class="line">    file = Midori::File.read(<span class="string">'./hello.txt'</span>)</div><div class="line">    &#123;<span class="symbol">text:</span> file&#125;.to_json</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line">Midori::Runner.new(Route).start</div></pre></td></tr></table></figure>
<p>当请求进来后，运行到</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Midori::File.read(<span class="string">'./hello.txt'</span>)</div></pre></td></tr></table></figure>
<p>这里时，程序就会让出自己的处理权，直到文件读取完，它会继续完成赋值</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">file = ...</div></pre></td></tr></table></figure>
<p>然后把整个 API 的接下来内容跑完。在业务代码中不会出现一行回调，但已经完成了所有的非阻塞的封装。</p>
<h2 id="API-设计"><a href="#API-设计" class="headerlink" title="API 设计"></a>API 设计</h2><h3 id="为什么不-await？"><a href="#为什么不-await？" class="headerlink" title="为什么不 await？"></a>为什么不 await？</h3><p>事实上，虽然出发点不同，但是从语义上看，这和 C# 中 <code>await</code> 的语义是非常接近的。意识到问题的 ECMAScript 7 标准中，也加入了类似的 <code>await</code> 语义。我非常支持 <code>await</code> 语义，并且 em-midori 内也提供了 <code>await</code> 语法的封装，但是我并不打算将其作为一个可以直接使用的 API 来看，而是各个驱动程序封装的工具。</p>
<p>因为当我们在使用 <strong>Web 框架</strong> 而不是在 <strong>造轮子</strong> 的时候，我们更关心的其实是业务。而一个业务处理的逻辑本身就是耦合的，是最小不可分的。使用 <code>await</code> 应该是默认的，而不是需要手动加入的。否则充斥 <code>await</code> 的语法并不是一个 <strong>Web DSL</strong> 该有的东西。</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>上述设计在实现时有个非常 tricky 的一点，就是异常处理。由于启动 Fiber 来处理异步的程序，在里面抛出的异常无法被外面的 <code>begin</code> <code>end</code> 语法捕获。而这一语法又恰恰只实现了程序的正确回调，却没有实现异常回调。为了弥补这一问题，<code>em-midori</code> 会自动捕获 Fiber 代码块中的一切异常，并遇到后在异常回调中抛出。开发者就可以正常使用 <code>begin</code> <code>end</code>  语法来捕获异常了。</p>
<p>同时，<code>em-midori</code> 还支持通过 <code>capture</code> 语法来定义全局错误处理，以更好处理一些常规错误例如 404, 500 等的通用处理返回。形如：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">require</span> <span class="string">'em-midori'</span></div><div class="line"><span class="keyword">require</span> <span class="string">'json'</span></div><div class="line"><span class="keyword">require</span> <span class="string">'em-midori/extension/file'</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Route</span> &lt; Midori::Route</span></div><div class="line">  get <span class="string">'/'</span> <span class="keyword">do</span></div><div class="line">    <span class="keyword">begin</span></div><div class="line">      file = Midori::File.read(<span class="string">'./hello.txt'</span>)</div><div class="line">      &#123;<span class="symbol">text:</span> file&#125;.to_json</div><div class="line">    <span class="keyword">rescue</span> Errno::ENOENT =&gt; _e</div><div class="line">      Midori::Response(<span class="number">404</span>,</div><div class="line">        &#123;&#125;,</div><div class="line">        &#123;<span class="symbol">err:</span><span class="string">'File not found'</span>&#125;.to_json)</div><div class="line">    <span class="keyword">rescue</span> =&gt; e</div><div class="line">      Midori::Response(<span class="number">500</span>,</div><div class="line">        &#123;&#125;,</div><div class="line">        &#123;<span class="symbol">err:</span> <span class="string">'Internal Server Error'</span>, <span class="symbol">detail:</span> e.traceback&#125;.to_json)</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line">Midori::Runner.new(Route).start</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">require</span> <span class="string">'em-midori'</span></div><div class="line"><span class="keyword">require</span> <span class="string">'json'</span></div><div class="line"><span class="keyword">require</span> <span class="string">'em-midori/extension/file'</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Route</span> &lt; Midori::Route</span></div><div class="line">  capture StandardError <span class="keyword">do</span> <span class="params">|e|</span></div><div class="line">    Midori::Response(<span class="number">500</span>,</div><div class="line">      &#123;&#125;,</div><div class="line">      &#123;<span class="symbol">err:</span> <span class="string">'Internal Server Error'</span>, <span class="symbol">detail:</span> e.traceback&#125;.to_json)</div><div class="line">  <span class="keyword">end</span></div><div class="line">  capture Errno::ENOENT <span class="keyword">do</span></div><div class="line">    Midori::Response(<span class="number">404</span>,</div><div class="line">      &#123;&#125;,</div><div class="line">      &#123;<span class="symbol">err:</span> <span class="string">'File not found'</span>&#125;.to_json)</div><div class="line">  <span class="keyword">end</span></div><div class="line">  get <span class="string">'/'</span> <span class="keyword">do</span></div><div class="line">    file = Midori::File.read(<span class="string">'./hello.txt'</span>)</div><div class="line">    &#123;<span class="symbol">text:</span> file&#125;.to_json</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line">Midori::Runner.new(Route).start</div></pre></td></tr></table></figure>
<h3 id="路由挂载"><a href="#路由挂载" class="headerlink" title="路由挂载"></a>路由挂载</h3><p><code>em-midori</code> 被设计成一个面向实际 Web 业务开发的框架，自然不是一个简单的轮子游戏，它为工程化的抽象做了不少考虑。比如支持 <code>mount</code> 来将一整个路由定义挂载到主路由上。</p>
<p>语法：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &lt; Midori::Route</span></div><div class="line">  get <span class="string">'/'</span> <span class="keyword">do</span></div><div class="line">    <span class="string">'Hello'</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &lt; Midori::Route</span></div><div class="line">  get <span class="string">'/'</span> <span class="keyword">do</span></div><div class="line">    <span class="string">'World'</span></div><div class="line">  <span class="keyword">end</span></div><div class="line">  mount <span class="string">'/a'</span>, A</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">Midori::Runner.new(B).start</div><div class="line"><span class="comment"># / =&gt; 'World'</span></div><div class="line"><span class="comment"># /a/ =&gt; 'Hello'</span></div></pre></td></tr></table></figure>
<p>事实上，这个路由挂载并不是一个栈递归调用，而是在初始化时通过一个深度优先搜索算法遍历，建立出整个中间件调用链。尽可能减少运行时的性能消耗，是个非常实用的设计。</p>
<h2 id="现有进度和未来路线"><a href="#现有进度和未来路线" class="headerlink" title="现有进度和未来路线"></a>现有进度和未来路线</h2><p><code>em-midori</code> 现在已经是一个勉强可用的状态。除了框架本身，简易的文件 I/O、Postgres 驱动、Sequel ORM 都已经被实现好。我已经开始着手使用这一框架用于生产，并已经有一些好的结果。并通过实际项目的建设也修复了不少不易察觉的 bug。</p>
<p>就目前的版本来说 <code>em-midori</code> 虽然较上次增加了很多功能，但性能和仍然能比 <code>sinatra</code> 快一倍以上，比 <code>rails 5 api mode</code> 快大约 6 倍。和 Node.js 上的 <code>express</code> 框架比较，性能不分上下，取决于具体运行机器。</p>
<p>不过，这个版本距离生产就绪的版本还有不少距离。从可用角度上来说，项目的测试覆盖率已达到 100%，但很多边缘情况都没有得到妥善的测试。在接下来的几个月需要更好的测试这一框架。</p>
<p>从学习角度来说，<code>em-midori</code> 还需要完善各方面的文档，补充 Tutorial 和 Guidelines 才能被其他人使用。并不可能让大家边读源代码边写业务。</p>
<p>在样例上，我选择了论坛项目作为一个官方 example，项目将作为 Tutorial 的一部分，给大家演示实际使用框架用于业务开发的各种细节。这些内容也会在 v1.0 版本前就绪。</p>
<p>从功能上来说，<code>em-midori</code> 抛弃了 Rack 作为 Web 接口，很大程度是我希望在接下来版本中加入完整的 HTTP/2 支持。但这也导致了需要重复造很多轮子，比如 rack-test 之类的配套功能。</p>
<p>时间上，我希望生产版本能在明年 3 月前发布。考虑到目前路线图的进度，开发进度仍领先于设定好的时间，所以我还是有不少把我做好这件事的。</p>
<p>最后祝大家写 Ruby 都能写得开心，写得愉快！</p>
<blockquote>
<p>Ruby is designed to make programmers happy.</p>
<p>–Yukihiro Matsumoto</p>
</blockquote>
<p><img src="http://cdn.heckpsi.com/midori_2.jpg" alt="If you are not happy"></p>
<p>项目地址：<a href="https://github.com/heckpsi-lab/em-midori" target="_blank" rel="external">em-midori</a></p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/10/29/is-eval-evil/" class="next">下一篇</a></div><div data-thread-key="2016/12/15/em-midori-100-days/" data-title="em-midori 100 天记" data-url="http://blog.heckpsi.com/2016/12/15/em-midori-100-days/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"heckpsi-blog"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><script src="http://7u2lcg.com1.z0.glb.clouddn.com/tw_cn.js"></script><div class="copyright"><p><a id="translateLink" href="javascript:translatePage();">轉換成繁體中文</a></p><script>var defaultEncoding = 2;var translateDelay = 0;
var cookieDomain = "http://blog.heckpsi.com/";
var msgToTraditionalChinese = "轉換成繁體中文";
var msgToSimplifiedChinese = "转换成简体中文";
var translateButtonId = "translateLink";
translateInitilization();</script><p>© 2013 - 2016 <a href="http://blog.heckpsi.com">上海骇咕赛信息科技有限公司</a> | <a href="http://www.miitbeian.gov.cn/publish/query/indexFirst.action">沪ICP备15046530号</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-61251352-2",'auto');ga('send','pageview');</script></body></html>